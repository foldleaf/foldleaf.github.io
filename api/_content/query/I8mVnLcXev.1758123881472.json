{"_path":"/essay/15.go的数据类型深入解析","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"go的数据类型深入解析","description":"int bool float string array slice map chan\n主要是 map 和 chan","subtitle":"Edit or delete users","index":15,"date":"2023-02-18 00:16:50","lunar_date":"正月廿八","year":"2023","month":"02","month_en":"Feb","day":"8","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/015.jpg","categories":"golang","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int bool float string array slice map chan"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n主要是 map 和 chan"}]},{"type":"element","tag":"h1","props":{"id":"int"},"children":[{"type":"text","value":"int"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"int(有符号)和uint(无符号)的大小与操作系统相关，在32位操作系统中大小为32位(4字节)，64位操作系统中大小为64位(8字节)"}]},{"type":"element","tag":"pre","props":{"className":["language-txt"],"code":"int      8 字节\nint8     1 字节\nint16    2 字节\nint32    4 字节\nint64    8 字节\n","language":"txt","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"int      8 字节\nint8     1 字节\nint16    2 字节\nint32    4 字节\nint64    8 字节\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它们是不同的类型(type)"}]},{"type":"element","tag":"h1","props":{"id":"float"},"children":[{"type":"text","value":"float"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"float32，即单精度，32位(4字节)，其中1位用来符号，8位用来指数，剩下的23位表示尾数，精确到小数点后7位\nfloat64，即双精度，64位(8字节)，其中1位用来符号，11位用来指数，剩下的52位表示尾数，精确到小数点后15位"}]},{"type":"element","tag":"h1","props":{"id":"bool"},"children":[{"type":"text","value":"bool"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只有2种：true和false\nbool值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换："}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"i := 0\nif b {\n    i = 1\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"i := 0\nif b {\n    i = 1\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"string"},"children":[{"type":"text","value":"string"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。\n一个字符串是一个不可改变的字节序列，实际上就是占用了一片连续的内存空间，所以能理解为一个字符数组\n在go的源码中可以找到string的数据结构"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type stringStruct struct {\n    array unsafe.Pointer   // 指向一个 [length]byte 的数组\n    length int             // 长度\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type stringStruct struct {\n    array unsafe.Pointer   // 指向一个 [length]byte 的数组\n    length int             // 长度\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其成员有2个，一个指向数组的指针，一个是所指数组的长度\n示例图：go语言圣经3.5.1"}]},{"type":"element","tag":"h1","props":{"id":"array"},"children":[{"type":"text","value":"array"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"cmd/compile/internal/types2.Array\ngo 源码中数组的结构"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type Array struct {\n    len  int64 // 数组长度，即元素个数\n    elem Type  // 元素类型\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type Array struct {\n    len  int64 // 数组长度，即元素个数\n    elem Type  // 元素类型\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"数组占用一片连续的内存空间"}]},{"type":"element","tag":"h1","props":{"id":"slice"},"children":[{"type":"text","value":"slice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"src/runtime/slice.go\ngo 源码中slice的结构"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type slice struct {\n    array unsafe.Pointer  // 指向数组的指针\n    len   int             // 切片长度\n    cap   int             // 切片容量\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type slice struct {\n    array unsafe.Pointer  // 指向数组的指针\n    len   int             // 切片长度\n    cap   int             // 切片容量\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其成员有3个，一个指向数组的指针，一个是切片的长度，还有一个是切片的容量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"切片的长度就是切片所包含的元素个数。\n切片的容量是从它的第一个元素开始数，到其"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"底层数组"}]},{"type":"text","value":"元素末尾的个数。"}]},{"type":"element","tag":"h1","props":{"id":"map"},"children":[{"type":"text","value":"map"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"go 源码中map的结构\nsrc/runtime/map.go"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type hmap struct {\n    \n    count     int // map当前元素个数\n    flags     uint8 // 读、写、扩容、迭代等标记，用于记录map当前状态\n    B         uint8  // 用于计算桶大小， bucketSize = 1 << B ;log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n    noverflow uint16 // 溢出桶个数，当溢出桶个数过多时，这个值是一个近似值  approximate number of overflow buckets; see incrnoverflow for details\n    hash0     uint32 // hash seed,计算key哈希值的随机值，保证一个key在不同map中存放的位置是随机的\n\n    buckets    unsafe.Pointer // 当前哈希桶首地址   array of 2^B Buckets. may be nil if count==0.\n    oldbuckets unsafe.Pointer // 旧哈希桶首地址  previous bucket array of half the size, non-nil only when growing\n    nevacuate  uintptr        // 已迁移哈希桶个数   progress counter for evacuation (buckets less than this have been evacuated)\n\n    extra *mapextra // 扩展字段，不一定每个map都需要    optional fields\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type hmap struct {\n    \n    count     int // map当前元素个数\n    flags     uint8 // 读、写、扩容、迭代等标记，用于记录map当前状态\n    B         uint8  // 用于计算桶大小， bucketSize = 1 << B ;log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n    noverflow uint16 // 溢出桶个数，当溢出桶个数过多时，这个值是一个近似值  approximate number of overflow buckets; see incrnoverflow for details\n    hash0     uint32 // hash seed,计算key哈希值的随机值，保证一个key在不同map中存放的位置是随机的\n\n    buckets    unsafe.Pointer // 当前哈希桶首地址   array of 2^B Buckets. may be nil if count==0.\n    oldbuckets unsafe.Pointer // 旧哈希桶首地址  previous bucket array of half the size, non-nil only when growing\n    nevacuate  uintptr        // 已迁移哈希桶个数   progress counter for evacuation (buckets less than this have been evacuated)\n\n    extra *mapextra // 扩展字段，不一定每个map都需要    optional fields\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"map是使用hash表(哈希表/散列表)来实现的,一个hash表里可以有多个hash节点，也叫bucket(桶/哈希桶),而每个bucket就保存了map中的一个或一组键值对。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/fengshenyun/article/details/100582679","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/fengshenyun/article/details/100582679"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"bucket的数据结构"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type bmap struct {\n    tophash [8]uint8 //存储哈希值的高8位,哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。\n    data    byte[1]  //key value数据:key/key/key/.../value/value/value...,如此存放是为了节省字节对齐带来的空间浪费\n    overflow *bmap   //溢出bucket的地址,指向的是下一个bucket，据此将所有冲突的键连接起来。\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type bmap struct {\n    tophash [8]uint8 //存储哈希值的高8位,哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。\n    data    byte[1]  //key value数据:key/key/key/.../value/value/value...,如此存放是为了节省字节对齐带来的空间浪费\n    overflow *bmap   //溢出bucket的地址,指向的是下一个bucket，据此将所有冲突的键连接起来。\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/failymao/p/14902607.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/failymao/p/14902607.html"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/dawnlight/p/15552513.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/dawnlight/p/15552513.html"}]}]},{"type":"element","tag":"h2","props":{"id":"map数据结构最终梳理"},"children":[{"type":"text","value":"map数据结构最终梳理"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"hmap是数组(切片)，组成元素是bucket(bmap,以便区分，这里后面都用bucket替代bmap)；bucket是链表，指针指向下一个扩充的bucket。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"map存储的是key/value对(k/v对、键值对)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当key传进来时，会经过一个hash函数运算得到一个唯一的hash值，在go中会将这个hash值分为高位和低位"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如hash值：1314131425002500，高8位为13141314，低8位为25002500"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"低位用于寻找key属于hmap的哪个bucket，高位用于寻找bucket中的哪个key"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果key计算出的hash值低位相同，那么这些key存入相同的bucket中，在bucket中会存储它们的高位，用于存入的key的快速预览"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"bucket是以key/key/key/.../value/value/value...的方式存储k/v对的，这是为了节省字节对齐带来的空间浪费"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个bucket只能存储8个k/v对，超过8个则会扩充一个新的bucket存放溢出的k/v对，然后指针指向新的bucket，以此类推，形成一个链表"}]}]},{"type":"element","tag":"h2","props":{"id":"负载因子与渐进式扩容"},"children":[{"type":"text","value":"负载因子与渐进式扩容"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"负载因子 = key数量/bucket数量\t(len(map)/2^B)"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"因子过小，说明空间利用率低:key少bucket多，说明map的bucket数组个数多，一个bucket中存放的key少"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"因子过大，说明冲突严重，存取效率低:key多bucket少，说明map的bucket数组个数少，一个bucket中存放的key多，溢出bucket严重"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个哈希表的实现对负载因子容忍程度不同，go的阈值为6.5，即平均每个bucket存放6.5个k/v对；而redis的阈值为1，因为redis里每个bucket只存放一个k/v对"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"扩容条件"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1.负载因子 > 6.5时，也即平均每个bucket存储的键值对达到6.5个。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2.overflow(溢出bucket)数量 > 2^15时，也即overflow数量超过32768时。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"增量扩容"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n因子过大，则会新建一个bucket数组将hmap,大小为原有bucket数组的两倍，并将原有bucket数组的数据渐进式地迁移到新bucket数组，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"hmap的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"buckets"}]},{"type":"text","value":"  "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"oldbuckets"}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"nevacuate"}]},{"type":"text","value":" 字段就是用来干这个的"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"等量扩容"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nbuckets数量不变，只是重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。例如过于频繁的对k/v进行增删操作，而这些k/v集中在某个bucket里，则会导致溢出bucket严重，影响存取效率"}]},{"type":"element","tag":"h2","props":{"id":"插入与查找"},"children":[{"type":"text","value":"插入与查找"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插入"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据key值算出哈希值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"取哈希值低位与hmap.B取模确定bucket位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查找该key是否已经存在，如果存在则直接更新值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果没找到将key，将key插入"}]},{"type":"element","tag":"li","props":{},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"查找"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据key值算出哈希值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"取哈希值低位与hmap.B取模确定bucket位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"取哈希值高位在tophash数组中查询"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果tophash"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"i"}]},{"type":"text","value":"中存储值也哈希值相等，则去找到该bucket中的key值进行比较"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当前bucket没有找到，则继续从下个overflow的bucket中查找。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果当前处于搬迁过程，则优先从oldbuckets查找\n注：如果查找不到，也不会返回空值，而是返回相应类型的0值。"}]}]},{"type":"element","tag":"h1","props":{"id":"chan"},"children":[{"type":"text","value":"chan"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"src/runtime/chan.go"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type hchan struct {\n    qcount   uint           // 当前队列中剩余元素个数          total data in the queue\n    dataqsiz uint           // 环形队列长度，即可以存放的元素个数      size of the circular queue\n    buf      unsafe.Pointer // 环形队列指针                points to an array of dataqsiz elements\n    elemsize uint16     // 每个元素的大小\n    closed   uint32     // 标识关闭状态\n    elemtype *_type // 元素类型                        element type\n    sendx    uint   // 队列下标，指示元素写入时存放到队列中的位置       send index\n    recvx    uint   //队列下标，指示元素从队列的该位置读出          receive index\n    recvq    waitq  //等待读消息的goroutine队列            list of recv waiters\n    sendq    waitq  // 等待写消息的goroutine队列               list of send waiters\n    lock mutex  //互斥锁，chan不允许并发读写\n    // lock protects all fields in hchan, as well as several\n    // fields in sudogs blocked on this channel.\n    //\n    // Do not change another G's status while holding this lock\n    // (in particular, do not ready a G), as this can deadlock\n    // with stack shrinking.\n    \n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type hchan struct {\n    qcount   uint           // 当前队列中剩余元素个数          total data in the queue\n    dataqsiz uint           // 环形队列长度，即可以存放的元素个数      size of the circular queue\n    buf      unsafe.Pointer // 环形队列指针                points to an array of dataqsiz elements\n    elemsize uint16     // 每个元素的大小\n    closed   uint32     // 标识关闭状态\n    elemtype *_type // 元素类型                        element type\n    sendx    uint   // 队列下标，指示元素写入时存放到队列中的位置       send index\n    recvx    uint   //队列下标，指示元素从队列的该位置读出          receive index\n    recvq    waitq  //等待读消息的goroutine队列            list of recv waiters\n    sendq    waitq  // 等待写消息的goroutine队列               list of send waiters\n    lock mutex  //互斥锁，chan不允许并发读写\n    // lock protects all fields in hchan, as well as several\n    // fields in sudogs blocked on this channel.\n    //\n    // Do not change another G's status while holding this lock\n    // (in particular, do not ready a G), as this can deadlock\n    // with stack shrinking.\n    \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"chan最核心的部分由一个环形队列和2个waitq组成，环形队列用于存放数据（带缓冲的情况下），waitq用于实现阻塞和恢复goroutine。"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"type waitq struct {\n    first *sudog\n    last  *sudog\n}\n\ntype sudog struct {\n    g *g\n\n    next *sudog\n    prev *sudog\n    elem unsafe.Pointer // data element (may point to stack)\n\n    acquiretime int64\n    releasetime int64\n    ticket      uint32\n\n    // isSelect indicates g is participating in a select, so\n    // g.selectDone must be CAS'd to win the wake-up race.\n    isSelect bool\n\n    // success indicates whether communication over channel c\n    // succeeded. It is true if the goroutine was awoken because a\n    // value was delivered over channel c, and false if awoken\n    // because c was closed.\n    success bool\n\n    parent   *sudog // semaRoot binary tree\n    waitlink *sudog // g.waiting list or semaRoot\n    waittail *sudog // semaRoot\n    c        *hchan // channel\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"type waitq struct {\n    first *sudog\n    last  *sudog\n}\n\ntype sudog struct {\n    g *g\n\n    next *sudog\n    prev *sudog\n    elem unsafe.Pointer // data element (may point to stack)\n\n    acquiretime int64\n    releasetime int64\n    ticket      uint32\n\n    // isSelect indicates g is participating in a select, so\n    // g.selectDone must be CAS'd to win the wake-up race.\n    isSelect bool\n\n    // success indicates whether communication over channel c\n    // succeeded. It is true if the goroutine was awoken because a\n    // value was delivered over channel c, and false if awoken\n    // because c was closed.\n    success bool\n\n    parent   *sudog // semaRoot binary tree\n    waitlink *sudog // g.waiting list or semaRoot\n    waittail *sudog // semaRoot\n    c        *hchan // channel\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.cnblogs.com/failymao/p/14891813.html","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.cnblogs.com/failymao/p/14891813.html"}]},{"type":"element","tag":"a","props":{"href":"https://i6448038.github.io/2019/04/11/go-channel/","rel":["nofollow"]},"children":[{"type":"text","value":"https://i6448038.github.io/2019/04/11/go-channel/"}]},{"type":"element","tag":"a","props":{"href":"https://cloud.tencent.com/developer/article/1750350","rel":["nofollow"]},"children":[{"type":"text","value":"https://cloud.tencent.com/developer/article/1750350"}]}]},{"type":"element","tag":"h2","props":{"id":"最终梳理"},"children":[{"type":"text","value":"最终梳理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"channel在源码是hchan结构体，核心为1个循环队列、以及2个 分别等待读和写的 goroutine 等待队列(双向链表)"}]},{"type":"element","tag":"h2","props":{"id":"循环队列"},"children":[{"type":"text","value":"循环队列"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"qcount   uint             // 当前队列中剩余元素\ndataqsiz uint             // 队列长度，即可以存放的元素个数\nbuf      unsafe.Pointer   // 队列\nsendx    uint         // 队列下标，指示元素写入时存放到队列中的位置 \nrecvx    uint         // 队列下标，指示元素从队列的该位置读出\nlock     mutex        // 互斥锁\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"qcount   uint             // 当前队列中剩余元素\ndataqsiz uint             // 队列长度，即可以存放的元素个数\nbuf      unsafe.Pointer   // 队列\nsendx    uint         // 队列下标，指示元素写入时存放到队列中的位置 \nrecvx    uint         // 队列下标，指示元素从队列的该位置读出\nlock     mutex        // 互斥锁\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在创建channel时,在内存中实例化了一个hchan的结构体，并返回一个ch指针。channel 是一个指针。"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"ch := make(chan int, 3)\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ch := make(chan int, 3)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在讨论之前先统一一下概念："},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n对于发送给channel的消息，channel是接收者，对channel来说是写操作；对于channel发送出去的消息，channel是发送者，对channel来说是读操作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"sendx: 等待发送。需要发送给channel的元素的索引位置(index)，即元素写入时存放到队列中的位置。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"recvx: 等待接收。需要从channel接收的元素的索引位置(index)，即从队列的该位置读出元素。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"给channel发(send)数据  (ch<-xx)"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 1.创建一个channel\n// 在内存中实例化了一个hchan的结构体，并返回一个ch指针。\n// ch是指针，ch用使用队列 buf 来缓存数据\n// 队列长度为dataqsiz为3，当前元素 qcount 为 0\n// sendx和recvx均为 0\nch := make(chan int, 3)\n// 2.将 一个元素写入 buf，\n// 首先先加锁\n// 将元素拷贝，传递给channel\n// 索引 0 位置写入了新的元素，sendx变为1，即下一个元素需要写入索引1的位置；recvx不变，即下一个读操作从索引0的位置读取\n// 队列长度为dataqsiz为3，当前元素 qcount 为 1\n// 释放锁\nch<-1\nch<-1\nch<-1\n// 队列缓存已满，再次写入会发生堵塞，这点我们后面再讲\n// 每次写入sendx+1，写入了3个元素，因为是循环队列 sendx又变为0；因为没有读取，recvx一直不变还是0\n\n// 3.从buf读取一个元素,和写元素类似\n// 首先先加锁\n// channel将元素传递给接收者\n// 从索引 0 位置读出元素，recvx变为1，即需要读取的下一个元素位置为索引1；sendx为0，即下一个元素需要写入索引0的位置\n// 队列长度为dataqsiz为3，当前元素 qcount 为 2\n// 释放锁\n<-ch\n<-ch\n<-ch\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 1.创建一个channel\n// 在内存中实例化了一个hchan的结构体，并返回一个ch指针。\n// ch是指针，ch用使用队列 buf 来缓存数据\n// 队列长度为dataqsiz为3，当前元素 qcount 为 0\n// sendx和recvx均为 0\nch := make(chan int, 3)\n// 2.将 一个元素写入 buf，\n// 首先先加锁\n// 将元素拷贝，传递给channel\n// 索引 0 位置写入了新的元素，sendx变为1，即下一个元素需要写入索引1的位置；recvx不变，即下一个读操作从索引0的位置读取\n// 队列长度为dataqsiz为3，当前元素 qcount 为 1\n// 释放锁\nch<-1\nch<-1\nch<-1\n// 队列缓存已满，再次写入会发生堵塞，这点我们后面再讲\n// 每次写入sendx+1，写入了3个元素，因为是循环队列 sendx又变为0；因为没有读取，recvx一直不变还是0\n\n// 3.从buf读取一个元素,和写元素类似\n// 首先先加锁\n// channel将元素传递给接收者\n// 从索引 0 位置读出元素，recvx变为1，即需要读取的下一个元素位置为索引1；sendx为0，即下一个元素需要写入索引0的位置\n// 队列长度为dataqsiz为3，当前元素 qcount 为 2\n// 释放锁\n<-ch\n<-ch\n<-ch\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个应该很有用，但太长了不想看\n"},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/kesenzhang/article/details/104488727","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/kesenzhang/article/details/104488727"}]}]},{"type":"element","tag":"h2","props":{"id":"双向链表"},"children":[{"type":"text","value":"双向链表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主要实现了堵塞"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"recvq    waitq  //等待读消息的goroutine队列 \nsendq    waitq  // 等待写消息的goroutine队列  \n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"recvq    waitq  //等待读消息的goroutine队列 \nsendq    waitq  // 等待写消息的goroutine队列  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这部分与GPM调度有关，等我写好内存模型和调度后再继续写，to be continent ..."}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[{"id":"map数据结构最终梳理","depth":2,"text":"map数据结构最终梳理"},{"id":"负载因子与渐进式扩容","depth":2,"text":"负载因子与渐进式扩容"},{"id":"插入与查找","depth":2,"text":"插入与查找"},{"id":"最终梳理","depth":2,"text":"最终梳理"},{"id":"循环队列","depth":2,"text":"循环队列"},{"id":"双向链表","depth":2,"text":"双向链表"}]}},"_type":"markdown","_id":"content:essay:15.go的数据类型深入解析.md","_source":"content","_file":"essay/15.go的数据类型深入解析.md","_stem":"essay/15.go的数据类型深入解析","_extension":"md"}