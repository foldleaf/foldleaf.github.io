{"_path":"/essay/17.web框架-前缀路由树","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"web框架-前缀路由树","description":"极客兔兔的web框架，该框架是参考gin的造轮子项目。前缀路由树这篇注释太少，不易于理解，个人写了写自己的理解。","subtitle":"Real-time data acquisition","index":17,"date":"2023-03-01","lunar_date":"二月初十","year":"2023","month":"03","month_en":"Mar","day":"01","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/017.jpg","categories":"golang","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"极客兔兔的web框架，该框架是参考gin的造轮子项目。前缀路由树这篇注释太少，不易于理解，个人写了写自己的理解。"}]},{"type":"element","tag":"h2","props":{"id":"树结构"},"children":[{"type":"text","value":"树结构"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 前缀路由树-树节点\ntype node struct {\n    pattern  string  // 待匹配路由 /p/:lang\n    part     string  // 路由的一部分 :lang，或者叫该节点存储的子路由好一点,在路由中是以 / 字符分隔的最小单位\n    children []*node // 子节点\n    isWild   bool    //是否精确匹配，part 含有 : 或 * 时为true，否则为false\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 前缀路由树-树节点\ntype node struct {\n    pattern  string  // 待匹配路由 /p/:lang\n    part     string  // 路由的一部分 :lang，或者叫该节点存储的子路由好一点,在路由中是以 / 字符分隔的最小单位\n    children []*node // 子节点\n    isWild   bool    //是否精确匹配，part 含有 : 或 * 时为true，否则为false\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"注册路由"},"children":[{"type":"text","value":"注册路由"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"匹配子节点的方法，可以先看下面的insert方法再倒回来看"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 匹配成功的节点，用于插入；插入时只会有一个节点的part匹配\nfunc (n *node) matchChild(part string) *node {\n    // 遍历节点的子节点，子节点的part与要匹配的part相同\n    for _, child := range n.children {\n        if child.part == part || child.isWild {\n            //返回匹配的节点\n            return child\n        }\n    }\n    return nil\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 匹配成功的节点，用于插入；插入时只会有一个节点的part匹配\nfunc (n *node) matchChild(part string) *node {\n    // 遍历节点的子节点，子节点的part与要匹配的part相同\n    for _, child := range n.children {\n        if child.part == part || child.isWild {\n            //返回匹配的节点\n            return child\n        }\n    }\n    return nil\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"插入节点的方法"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 注册路由规则\n// 对pattern解析，以 / 为分隔符分解为 parts 数组，递归插入路由树，height为插入树的高度\n// 例: pattern   -   \"/p/:lang/doc\"\n//  parts   -   []string{“p”,“lang”,“doc”}\nfunc (n *node) insert(pattern string, parts []string, height int) {\n    // n节点所在树的高度与分解的part数是否相等，即判断 part 是否全部插入完毕\n    if len(parts) == height {\n        // 只有最后一个节点才会设置pattern，用于查询时匹配，这之前的节点该pattern字段均为空\n        // 确保只有相同层级的相同part才能匹配\n        n.pattern = pattern\n        return\n    }\n    part := parts[height]\n    // 在子节点中查找匹配 part 的第一个节点，然后判断是否存在匹配 part的节点\n    // 存在则将其作为子节点，继续下一步\n    child := n.matchChild(part)\n    if child == nil {\n        // 不存在，则构建新节点，将part写入，根据该part第一个字符是否有:和*，设置isWild\n        child = &node{part: part, isWild: part[0] == ':' || part[0] == '*'}\n        // 将该节点作为n节点的子节点插入树中\n        n.children = append(n.children, child)\n    }\n    // 继续查找child的子节点，插入下一个part，直到把parts数组的part全部插入为止\n    child.insert(pattern, parts, height+1)\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 注册路由规则\n// 对pattern解析，以 / 为分隔符分解为 parts 数组，递归插入路由树，height为插入树的高度\n// 例: pattern   -   \"/p/:lang/doc\"\n//  parts   -   []string{“p”,“lang”,“doc”}\nfunc (n *node) insert(pattern string, parts []string, height int) {\n    // n节点所在树的高度与分解的part数是否相等，即判断 part 是否全部插入完毕\n    if len(parts) == height {\n        // 只有最后一个节点才会设置pattern，用于查询时匹配，这之前的节点该pattern字段均为空\n        // 确保只有相同层级的相同part才能匹配\n        n.pattern = pattern\n        return\n    }\n    part := parts[height]\n    // 在子节点中查找匹配 part 的第一个节点，然后判断是否存在匹配 part的节点\n    // 存在则将其作为子节点，继续下一步\n    child := n.matchChild(part)\n    if child == nil {\n        // 不存在，则构建新节点，将part写入，根据该part第一个字符是否有:和*，设置isWild\n        child = &node{part: part, isWild: part[0] == ':' || part[0] == '*'}\n        // 将该节点作为n节点的子节点插入树中\n        n.children = append(n.children, child)\n    }\n    // 继续查找child的子节点，插入下一个part，直到把parts数组的part全部插入为止\n    child.insert(pattern, parts, height+1)\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"查询路由"},"children":[{"type":"text","value":"查询路由"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样，你可以先看下面的search方法再倒回来看这个"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 所有匹配成功的节点，用于查找；与插入时匹配不同的是，有可能存在多个part能匹配的节点,例如动态路由 /:xxx\nfunc (n *node) matchChildren(part string) []*node {\n    nodes := make([]*node, 0)\n    // 遍历节点的子节点，子节点的part与要匹配的part相同\n    for _, child := range n.children {\n        if child.part == part || child.isWild {\n            nodes = append(nodes, child)\n        }\n    }\n    // 返回所有匹配的节点\n    return nodes\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 所有匹配成功的节点，用于查找；与插入时匹配不同的是，有可能存在多个part能匹配的节点,例如动态路由 /:xxx\nfunc (n *node) matchChildren(part string) []*node {\n    nodes := make([]*node, 0)\n    // 遍历节点的子节点，子节点的part与要匹配的part相同\n    for _, child := range n.children {\n        if child.part == part || child.isWild {\n            nodes = append(nodes, child)\n        }\n    }\n    // 返回所有匹配的节点\n    return nodes\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"search方法"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 查询匹配路由\nfunc (n *node) search(parts []string,height int)*node{\n    // n节点所在树的高度与分解的part数相等，或n节点的part字段以字符 * 开头，则匹配完毕\n    if len(parts)==height||strings.HasPrefix(n.part,\"*\"){\n        // 注册路由插入该节点的最大高度并不是该层级，pattern字段为空，也无法匹配(详见insert方法的第一个if语句)\n        if n.pattern==\"\"{\n            return nil\n        }\n        // 匹配到了，返回该节点\n        return n\n    }\n    part:=parts[height]\n    // 在n节点的子节点中查找所有与part匹配的节点\n    chirldren:=n.matchChildren(part)\n\n    for _,child:=range chirldren{\n        // 继续递归查询子节点，匹配下一个part，直到parts数组的part完全匹配为止\n        result:=child.search(parts,height+1)\n        if result!=nil{\n            return result\n        }\n    }\n    return nil\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 查询匹配路由\nfunc (n *node) search(parts []string,height int)*node{\n    // n节点所在树的高度与分解的part数相等，或n节点的part字段以字符 * 开头，则匹配完毕\n    if len(parts)==height||strings.HasPrefix(n.part,\"*\"){\n        // 注册路由插入该节点的最大高度并不是该层级，pattern字段为空，也无法匹配(详见insert方法的第一个if语句)\n        if n.pattern==\"\"{\n            return nil\n        }\n        // 匹配到了，返回该节点\n        return n\n    }\n    part:=parts[height]\n    // 在n节点的子节点中查找所有与part匹配的节点\n    chirldren:=n.matchChildren(part)\n\n    for _,child:=range chirldren{\n        // 继续递归查询子节点，匹配下一个part，直到parts数组的part完全匹配为止\n        result:=child.search(parts,height+1)\n        if result!=nil{\n            return result\n        }\n    }\n    return nil\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[{"id":"树结构","depth":2,"text":"树结构"},{"id":"注册路由","depth":2,"text":"注册路由"},{"id":"查询路由","depth":2,"text":"查询路由"}]}},"_type":"markdown","_id":"content:essay:17.web框架-前缀路由树.md","_source":"content","_file":"essay/17.web框架-前缀路由树.md","_stem":"essay/17.web框架-前缀路由树","_extension":"md"}