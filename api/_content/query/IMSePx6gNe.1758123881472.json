{"_path":"/essay/32.(翻译)半小时学习rust","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"（翻译）半小时学习rust","description":"https://fasterthanli.me/articles/a-half-hour-to-learn-rust\n本文为粗略的翻译\n为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？","subtitle":"A half-hour to learn Rust","index":32,"date":"2023-04-10","lunar_date":"闰二二十","year":"2023","month":"04","month_en":"Apr","day":"10","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/032.jpg","categories":"rust","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://fasterthanli.me/articles/a-half-hour-to-learn-rust","rel":["nofollow"]},"children":[{"type":"text","value":"https://fasterthanli.me/articles/a-half-hour-to-learn-rust"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n本文为粗略的翻译"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在本文中，我将不会关注于一两个概念，而是试着通过尽可能多的Rust 代码段，解释其中的关键字和符号的含义。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"准备好了吗？让我们开始吧！"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"let"}]},{"type":"text","value":"引入了变量绑定(variable binding)"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x;  // 声明 \"x\"\nx = 42; // 将 42 分配给 \"x\"\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x;  // 声明 \"x\"\nx = 42; // 将 42 分配给 \"x\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也可以写成一行"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 42;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 42;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"您可以显式地指定变量的类型，用冒号表示类型注释:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":":"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x: i32; // i32是一个有符号的32位整数\nx = 42;\n// 有符号整数有: i8, i16, i32, i64, i128\n// 无符号整数有: u8, u16, u32, u64, u128 \n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x: i32; // i32是一个有符号的32位整数\nx = 42;\n// 有符号整数有: i8, i16, i32, i64, i128\n// 无符号整数有: u8, u16, u32, u64, u128 \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也可以写成一行"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x: i32 = 42;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x: i32 = 42;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果您声明一个变量,之后再初始化，编译器将会阻止你初始化之前使用这个变量"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x;\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\n// 借用可能未初始化的变量: `x`\nx = 42;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x;\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\n// 借用可能未初始化的变量: `x`\nx = 42;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"正确的写法是这样:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x;\nx = 42;\nfoobar(x); //  `x` 的类型将会在这被推断出来\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x;\nx = 42;\nfoobar(x); //  `x` 的类型将会在这被推断出来\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下划线是一个特殊的变量名,更确切地说是 “空缺名”,意思就是扔掉一些东西:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"_"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// 42是常数，所以无事发生\nlet _ = 42;\n\n// 调用 `get_thing` 函数但是舍弃了扔掉了的结果\nlet _ = get_thing();\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 42是常数，所以无事发生\nlet _ = 42;\n\n// 调用 `get_thing` 函数但是舍弃了扔掉了的结果\nlet _ = get_thing();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以下划线开头的变量名是普通名称，只是编译器不会警告它们不被使用:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// 变量声明但不使用会被编译器警告\n// 在变量名前面加下划线可以去掉警告\nlet _x = 42;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 变量声明但不使用会被编译器警告\n// 在变量名前面加下划线可以去掉警告\nlet _x = 42;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以对同一个变量名多次绑定-你可以掩盖(shadow)变量绑定"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 13;\nlet x = x + 3;\n// 在这之后使用 `x` 指代的都是第二个 `x`\n// 第一个  `x` 已不存在.（关于这点本人有补充，见下）\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 13;\nlet x = x + 3;\n// 在这之后使用 `x` 指代的都是第二个 `x`\n// 第一个  `x` 已不存在.（关于这点本人有补充，见下）\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"译者注: 掩盖(shadowing)是在作用域之内掩盖掉原有的变量名，在作用域结束之后掩盖失效，因为此处两个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" 作用域相同，所以第二个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x"}]},{"type":"text","value":"会一直掩盖第一个 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"x"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rust 有元组(tuples)，您可以将其视为“不同类型的值的固定长度集合”。"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let pair = ('a', 17);\npair.0; // 这是 'a'\npair.1; // 这是 17\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let pair = ('a', 17);\npair.0; // 这是 'a'\npair.1; // 这是 17\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果想添加类型注释:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let pair: (char, i32) = ('a', 17);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let pair: (char, i32) = ('a', 17);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"元组在执行任务时可以被解构(destructured)，这意味着它们被分解为独立的字段:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let (some_char, some_int) = ('a', 17);\n// 现在 some_char是 'a'，some_int是 17\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let (some_char, some_int) = ('a', 17);\n// 现在 some_char是 'a'，some_int是 17\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这点在函数返回元组时特别有用:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let (left, right) = slice.split_at(middle);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let (left, right) = slice.split_at(middle);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当然，在解构元组时，可以用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"_"}]},{"type":"text","value":"来丢弃它的一部分"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let (_, right) = slice.split_at(middle);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let (_, right) = slice.split_at(middle);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分号表示语句的结尾:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 3;\nlet y = 5;\nlet z = y + x;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 3;\nlet y = 5;\nlet z = y + x;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这意味着语句可以跨越多行"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = vec![1, 2, 3, 4, 5, 6, 7, 8]\n    .iter()\n    .map(|x| x + 3)\n    .fold(0, |x, y| x + y);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = vec![1, 2, 3, 4, 5, 6, 7, 8]\n    .iter()\n    .map(|x| x + 3)\n    .fold(0, |x, y| x + y);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(我们待会儿再讨论它们的意思)\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"fn"}]},{"type":"text","value":"声明一个没有返回值的函数"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn greet() {\n    println!(\"Hi there!\");\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn greet() {\n    println!(\"Hi there!\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面的函数返回32位有符号整数，箭头"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"->"}]},{"type":"text","value":"表示它的返回类型:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn fair_dice_roll() -> i32 {\n    4\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn fair_dice_roll() -> i32 {\n    4\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一对花括号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":"声明一个代码块(block)，它有自己的作用域"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// This prints \"in\", then \"out\"\nfn main() {\n    let x = \"out\";\n    {\n        // this is a different `x`\n        let x = \"in\";\n        println!(\"{}\", x);\n    }\n    println!(\"{}\", x);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// This prints \"in\", then \"out\"\nfn main() {\n    let x = \"out\";\n    {\n        // this is a different `x`\n        let x = \"in\";\n        println!(\"{}\", x);\n    }\n    println!(\"{}\", x);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码块也是表达式，可以计算为(evaluate)一个值"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 42;\n// 两者等价\nlet x = { 42 };\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 42;\n// 两者等价\nlet x = { 42 };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一个代码块中，可以有多个语句"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = {\n    let y = 1; // first statement\n    let z = 2; // second statement\n    y + z // 这是代码块的结尾 - 整个代码块返回的值\n};\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = {\n    let y = 1; // first statement\n    let z = 2; // second statement\n    y + z // 这是代码块的结尾 - 整个代码块返回的值\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以省略函数末尾语句的分号等价于return语句"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn fair_dice_roll() -> i32 {\n    return 4;\n}\n\nfn fair_dice_roll() -> i32 {\n    4\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn fair_dice_roll() -> i32 {\n    return 4;\n}\n\nfn fair_dice_roll() -> i32 {\n    4\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"if"}]},{"type":"text","value":" 条件语句也是表达式"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn fair_dice_roll() -> i32 {\n    if feeling_lucky {\n        6\n    } else {\n        4\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn fair_dice_roll() -> i32 {\n    if feeling_lucky {\n        6\n    } else {\n        4\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"match"}]},{"type":"text","value":"语句也是表达式"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn fair_dice_roll() -> i32 {\n    match feeling_lucky {\n        true => 6,\n        false => 4,\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn fair_dice_roll() -> i32 {\n    match feeling_lucky {\n        true => 6,\n        false => 4,\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"符号点"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"."}]},{"type":"text","value":"通常用于访问值的字段:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let a = (10, 20);\na.0; // this is 10\n\nlet amos = get_some_struct();\namos.nickname; // this is \"fasterthanlime\"\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let a = (10, 20);\na.0; // this is 10\n\nlet amos = get_some_struct();\namos.nickname; // this is \"fasterthanlime\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者调用值的某个方法:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let nick = \"fasterthanlime\";\nnick.len(); // this is 14\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let nick = \"fasterthanlime\";\nnick.len(); // this is 14\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"双冒号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"::"}]},{"type":"text","value":"类似，但是它用于命名空间"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这个例子中，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"std"}]},{"type":"text","value":"是一个crate,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cmd"}]},{"type":"text","value":"是一个模块(module),"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"min"}]},{"type":"text","value":"是一个函数"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"译者注:package、crate、module概念不要以其他语言的概念先入为主，这里简要提一下，不作展开"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"package为项目，就是cargo new创建的项目就称为package"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"crate是一个独立的编译单元，又分为binary(二进制) crate和library crate，硬要翻译这个名词的话叫做分隔箱比较恰当。\nbinary crate的充要条件是有src/main.rs\nlibrary crate的充要条件是有src/lib.rs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"module是模块，用于内部代码的组织，可以控制作用域及私有性"}]}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let least = std::cmp::min(3, 8); // this is 3\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let least = std::cmp::min(3, 8); // this is 3\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"use directives can be used to \"bring in scope\" names from other namespace:\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"use"}]},{"type":"text","value":"关键字用来引入其他命名空间的作用域里的内容，例如函数"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"use std::cmp::min;\nlet least = min(7, 1); // this is 1\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"use std::cmp::min;\nlet least = min(7, 1); // this is 1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 use 关键字中，花括号还有另一个意思: 它们来源相同\n如果我们想同时导入 min 和 max，我们可以执行以下任何操作:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类似于javascript的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"import {min,max} from 'xxx'"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A wildcard () lets you import every symbol from a namespace:*\n通配符"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"*"}]},{"type":"text","value":"允许你从命名空间导入所有内容"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// this brings `min` and `max` in scope, and many other things\nuse std::cmp::*;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// this brings `min` and `max` in scope, and many other things\nuse std::cmp::*;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类型也命名空间，类型的方法可以作为常规函数调用:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = \"amos\".len(); // this is 4\nlet x = str::len(\"amos\"); // this is also 4\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = \"amos\".len(); // this is 4\nlet x = str::len(\"amos\"); // this is also 4\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"str is a primitive type, but many non-primitive types are also in scope by default.\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"str"}]},{"type":"text","value":"是原始类型，但也有许多非原始类型"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// `Vec` is a regular struct, not a primitive type\nlet v = Vec::new();\n\n// this is exactly the same code, but with the *full* path to `Vec`\nlet v = std::vec::Vec::new();\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// `Vec` is a regular struct, not a primitive type\nlet v = Vec::new();\n\n// this is exactly the same code, but with the *full* path to `Vec`\nlet v = std::vec::Vec::new();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这会正常编译，因为Rust会在每个模块的开头插入:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"use std::prelude::v1::*;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"use std::prelude::v1::*;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(这引入了很多东西，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vec"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"String"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Option"}]},{"type":"text","value":" ,"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Result"}]},{"type":"text","value":" 等等)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":"关键字用于声明结构体"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Vec2 {\n    x: f64, // 64-bit floating point, aka \"double precision\"\n    y: f64,\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Vec2 {\n    x: f64, // 64-bit floating point, aka \"double precision\"\n    y: f64,\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用结构体字面量初始化"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"Rust code\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n// the order does not matter, only the names do\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Rust code\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n// the order does not matter, only the names do\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用另一个结构体初始化剩余字段的快捷方式:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let v3 = Vec2 {\n    x: 14.0,\n    ..v2\n    // 只能在最后使用，后面不能有逗号\n};\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let v3 = Vec2 {\n    x: 14.0,\n    ..v2\n    // 只能在最后使用，后面不能有逗号\n};\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意，剩余字段前面不加任何东西时可以表示所有字段:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let v4 = Vec2 { ..v3 };\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let v4 = Vec2 { ..v3 };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结构体可以像元组一样被解构"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let (left, right) = slice.split_at(middle);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let (left, right) = slice.split_at(middle);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"像这样"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let v = Vec2 { x: 3.0, y: 6.0 };\nlet Vec2 { x, y } = v;\n// `x` 为 3.0, `y` 为 `6.0`\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let v = Vec2 { x: 3.0, y: 6.0 };\nlet Vec2 { x, y } = v;\n// `x` 为 3.0, `y` 为 `6.0`\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"还有这样"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let Vec2 { x, .. } = v;\n// 舍弃了 `v.y`\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let Vec2 { x, .. } = v;\n// 舍弃了 `v.y`\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"let"}]},{"type":"text","value":"模式匹配可以作为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"if"}]},{"type":"text","value":"的判断条件"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    if let Number { odd: true, value } = n {\n        println!(\"Odd number: {}\", value);\n    } else if let Number { odd: false, value } = n {\n        println!(\"Even number: {}\", value);\n    }\n}\n\n// this prints:\n// Odd number: 1\n// Even number: 2\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    if let Number { odd: true, value } = n {\n        println!(\"Odd number: {}\", value);\n    } else if let Number { odd: false, value } = n {\n        println!(\"Even number: {}\", value);\n    }\n}\n\n// this prints:\n// Odd number: 1\n// Even number: 2\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"match选择支也是模式匹配，类似与 if let"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } => println!(\"Odd number: {}\", value),\n        Number { odd: false, value } => println!(\"Even number: {}\", value),\n    }\n}\n\n// this prints the same as before\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } => println!(\"Odd number: {}\", value),\n        Number { odd: false, value } => println!(\"Even number: {}\", value),\n    }\n}\n\n// this prints the same as before\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"match必须是详尽的，即必须至少有一个选择支能够匹配上"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } => println!(\"One\"),\n        Number { value: 2, .. } => println!(\"Two\"),\n        Number { value, .. } => println!(\"{}\", value),\n        // if that last arm didn't exist, we would get a compile-time error\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } => println!(\"One\"),\n        Number { value: 2, .. } => println!(\"Two\"),\n        Number { value, .. } => println!(\"{}\", value),\n        // if that last arm didn't exist, we would get a compile-time error\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果很难穷尽所有情形, 可以使用下划线"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"_"}]},{"type":"text","value":"匹配剩下的所有情形"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_number(n: Number) {\n    match n.value {\n        1 => println!(\"One\"),\n        2 => println!(\"Two\"),\n        _ => println!(\"{}\", n.value),\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_number(n: Number) {\n    match n.value {\n        1 => println!(\"One\"),\n        2 => println!(\"Two\"),\n        _ => println!(\"{}\", n.value),\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以声明你自己的类型的方法"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -> bool {\n        self.value > 0\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -> bool {\n        self.value > 0\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后普通地使用"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let minus_two = Number {\n        odd: false,\n        value: -2,\n    };\n    println!(\"positive? {}\", minus_two.is_strictly_positive());\n    // this prints \"positive? false\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let minus_two = Number {\n        odd: false,\n        value: -2,\n    };\n    println!(\"positive? {}\", minus_two.is_strictly_positive());\n    // this prints \"positive? false\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Variable bindings are immutable by default, which means their interior can't be mutated:\n变量绑定在默认情况下是不可变的，这意味着它们的内部不能变化"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n.odd = false; // error: cannot assign to `n.odd`,\n                   // as `n` is not declared to be mutable\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n.odd = false; // error: cannot assign to `n.odd`,\n                   // as `n` is not declared to be mutable\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这也意味着该变量不能被再次分配"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n = Number {\n        odd: false,\n        value: 22,\n    }; // error: cannot assign twice to immutable variable `n`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n = Number {\n        odd: false,\n        value: 22,\n    }; // error: cannot assign twice to immutable variable `n`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"mut"}]},{"type":"text","value":" 可以使变量绑定为可变的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let mut n = Number {\n        odd: true,\n        value: 17,\n    }\n    n.value = 19; // all good\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let mut n = Number {\n        odd: true,\n        value: 17,\n    }\n    n.value = 19; // all good\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Traits"}]},{"type":"text","value":"(特型) 是多种类型共有的东西(类似于其他编程语言的接口)"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"trait Signed {\n    fn is_strictly_negative(self) -> bool;\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"trait Signed {\n    fn is_strictly_negative(self) -> bool;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“孤儿规则”(orphan rules):\n如果要实现某个trait，那么该trait和要实现该trait的类型至少有一个要在当前crate中定义"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在上面已经定义了\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trait"}]},{"type":"text","value":":Signed\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"struct"}]},{"type":"text","value":":Number"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在自定义的的类型中实现自定义的trait"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl Signed for Number {\n    fn is_strictly_negative(self) -> bool {\n        self.value < 0\n    }\n}\n\nfn main() {\n    let n = Number { odd: false, value: -44 };\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl Signed for Number {\n    fn is_strictly_negative(self) -> bool {\n        self.value < 0\n    }\n}\n\nfn main() {\n    let n = Number { odd: false, value: -44 };\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在其他类型中实现自定义trait(i32是一个原始类型):"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl Signed for i32 {\n    fn is_strictly_negative(self) -> bool {\n        self < 0\n    }\n}\n\nfn main() {\n    let n: i32 = -44;\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl Signed for i32 {\n    fn is_strictly_negative(self) -> bool {\n        self < 0\n    }\n}\n\nfn main() {\n    let n: i32 = -44;\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在自定义类型中实现其他trait"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"//  `Neg` trait 用于一元运算符 `-`的重载\n\nimpl std::ops::Neg for Number {\n    type Output = Number;\n\n    fn neg(self) -> Number {\n        Number {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n\nfn main() {\n    let n = Number { odd: true, value: 987 };\n    let m = -n; // this is only possible because we implemented `Neg`\n    println!(\"{}\", m.value); // prints \"-987\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//  `Neg` trait 用于一元运算符 `-`的重载\n\nimpl std::ops::Neg for Number {\n    type Output = Number;\n\n    fn neg(self) -> Number {\n        Number {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n\nfn main() {\n    let n = Number { odd: true, value: 987 };\n    let m = -n; // this is only possible because we implemented `Neg`\n    println!(\"{}\", m.value); // prints \"-987\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"An block is always for a type, so, inside that block, means that type:implSelf\n一个代码块用于一个类型，所以在这个代码块的内部意味着这个类型的自我实现"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type.\n有些trait是marker(标记)——它们不是说类型实现了某些方法，而是说某些事情可以用类型来完成。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"举个例子，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"i32"}]},{"type":"text","value":" 实现了trait "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Copy"}]},{"type":"text","value":"(i32可以认为是Copy类型)，所以"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let a: i32 = 15;\n    let b = a; // `a` 被拷贝\n    let c = a; // `a` 再次被拷贝\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let a: i32 = 15;\n    let b = a; // `a` 被拷贝\n    let c = a; // `a` 再次被拷贝\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这同样也可以"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_i32(x: i32) {\n    println!(\"x = {}\", x);\n}\n\nfn main() {\n    let a: i32 = 15;\n    print_i32(a); // `a` is copied\n    print_i32(a); // `a` is copied again\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_i32(x: i32) {\n    println!(\"x = {}\", x);\n}\n\nfn main() {\n    let a: i32 = 15;\n    print_i32(a); // `a` is copied\n    print_i32(a); // `a` is copied again\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但结构体"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Number"}]},{"type":"text","value":"不是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Copy"}]},{"type":"text","value":",所以这样不行:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这同样不行:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_number(n: Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(n); // `n` is moved\n    print_number(n); // error: use of moved value: `n`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_number(n: Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(n); // `n` is moved\n    print_number(n); // error: use of moved value: `n`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"print_number"}]},{"type":"text","value":"使用不可变引用(immutable reference)后则可以"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(&n); // `n` is borrowed for the time of the call\n    print_number(&n); // `n` is borrowed again\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(&n); // `n` is borrowed for the time of the call\n    print_number(&n); // `n` is borrowed again\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果一个函数接受一个可变的引用，那么它也可以工作——但是只有当我们的变量绑定也是 mut 的时候"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn invert(n: &mut Number) {\n    n.value = -n.value;\n}\n\nfn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    // this time, `n` is mutable\n    let mut n = Number { odd: true, value: 51 };\n    print_number(&n);\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\n    print_number(&n);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn invert(n: &mut Number) {\n    n.value = -n.value;\n}\n\nfn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    // this time, `n` is mutable\n    let mut n = Number { odd: true, value: 51 };\n    print_number(&n);\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\n    print_number(&n);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Trait methods can also take by reference or mutable reference:self\nTrait 方法可以通过引用或可变引用接收"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"self"}]},{"type":"text","value":":"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当调用 trait 方法时，接收方是隐式借用的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n    \n    print_number(&n);\n    print_number(&m);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n    \n    print_number(&n);\n    print_number(&m);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意:这两种写法是等价的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let m = n.clone();\nlet m = std::clone::Clone::clone(&n);\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let m = n.clone();\nlet m = std::clone::Clone::clone(&n);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Marker traits like have no methods:Copy\n像 Copy 这样的 Marker trait没有方法:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// note: `Copy` requires that `Clone` is implemented too\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n\nimpl std::marker::Copy for Number {}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// note: `Copy` requires that `Clone` is implemented too\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n\nimpl std::marker::Copy for Number {}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在Clone仍然可用"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n.clone();\n    let o = n.clone();\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n.clone();\n    let o = n.clone();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是 Number的值不再移动(move)"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `m` is a copy of `n`\n    let o = n; // same. `n` is neither moved nor borrowed.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `m` is a copy of `n`\n    let o = n; // same. `n` is neither moved nor borrowed.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有些trait非常常见，它们可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"derive"}]},{"type":"text","value":"属性自动实现:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n// 扩展了 `impl Clone for Number` 以及 `impl Copy for Number` 的代码块.\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n// 扩展了 `impl Clone for Number` 以及 `impl Copy for Number` 的代码块.\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"函数可以是泛型的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<T>(arg: T) {\n    // do something with `arg`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<T>(arg: T) {\n    // do something with `arg`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它们可以有多个类型参数，然后可以在函数的声明和函数体中使用这些参数，而不是具体的类型:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<L, R>(left: L, right: R) {\n    // do something with `left` and `right`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<L, R>(left: L, right: R) {\n    // do something with `left` and `right`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类型参数通常也有约束，因此您可以对它们进行一些实际操作。\n最简单的是通过 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trait"}]},{"type":"text","value":" 来约束"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print<T: Display>(value: T) {\n    println!(\"value = {}\", value);\n}\n\nfn print<T: Debug>(value: T) {\n    println!(\"value = {:?}\", value);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print<T: Display>(value: T) {\n    println!(\"value = {}\", value);\n}\n\nfn print<T: Debug>(value: T) {\n    println!(\"value = {:?}\", value);\n}\n"}]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Display 和 Debug都是一种trait，用于格式化输出"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类型参数约束有更长的语法:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print<T>(value: T)\nwhere\n    T: Display,\n{\n    println!(\"value = {}\", value);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print<T>(value: T)\nwhere\n    T: Display,\n{\n    println!(\"value = {}\", value);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"约束可能更复杂: 可能需要一个类型参数来实现多个 trait:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"use std::fmt::Debug;\n\nfn compare<T>(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!(\"{:?} {} {:?}\", left, if left == right { \"==\" } else { \"!=\" }, right);\n}\n\nfn main() {\n    compare(\"tea\", \"coffee\");\n    // prints: \"tea\" != \"coffee\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"use std::fmt::Debug;\n\nfn compare<T>(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!(\"{:?} {} {:?}\", left, if left == right { \"==\" } else { \"!=\" }, right);\n}\n\nfn main() {\n    compare(\"tea\", \"coffee\");\n    // prints: \"tea\" != \"coffee\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.\n泛型函数可以被看作是命名空间，包含无数具有不同具体类型的函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Same as with crates, and modules, and types, generic functions can be \"explored\" (navigated?) using ::\n与crate、module和type一样，泛型函数也可以使用双冒号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"::"}]},{"type":"text","value":"进行访问"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    use std::any::type_name;\n    println!(\"{}\", type_name::<i32>()); // prints \"i32\"\n    println!(\"{}\", type_name::<(f64, char)>()); // prints \"(f64, char)\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    use std::any::type_name;\n    println!(\"{}\", type_name::<i32>()); // prints \"i32\"\n    println!(\"{}\", type_name::<(f64, char)>()); // prints \"(f64, char)\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is lovingly called turbofish syntax, because looks like a fish.::<>\n这被亲切地称为 turbofish(涡轮鱼?) 语法，因为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"::<>"}]},{"type":"text","value":" 看起来像一条鱼。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"结构体也可以是泛型的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Pair<T> {\n    a: T,\n    b: T,\n}\n\nfn print_type_name<T>(_val: &T) {\n    println!(\"{}\", std::any::type_name::<T>());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&p1); // prints \"Pair<i32>\"\n    print_type_name(&p2); // prints \"Pair<bool>\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Pair<T> {\n    a: T,\n    b: T,\n}\n\nfn print_type_name<T>(_val: &T) {\n    println!(\"{}\", std::any::type_name::<T>());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&p1); // prints \"Pair<i32>\"\n    print_type_name(&p2); // prints \"Pair<bool>\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"标准库类型 Vec (分配在堆上的数组)是泛型的的\nThe standard library type (~ a heap-allocated array), is generic:Vec"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n    print_type_name(&v1); // prints \"Vec<i32>\"\n    print_type_name(&v2); // prints \"Vec<bool>\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n    print_type_name(&v1); // prints \"Vec<i32>\"\n    print_type_name(&v2); // prints \"Vec<bool>\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Speaking of , it comes with a macro that gives more or less \"vec literals\":Vec\n说到 Vec，它或多或少都会用到宏来提供“ vec 字面值”:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n    print_type_name(&v1); // prints \"Vec<i32>\"\n    print_type_name(&v2); // prints \"Vec<bool>\"\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n    print_type_name(&v1); // prints \"Vec<i32>\"\n    print_type_name(&v2); // prints \"Vec<bool>\"\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"All of , or invoke a macro. Macros just expand to regular code.name!()name![]name!{}\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"name!()"}]},{"type":"text","value":" ，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"name![]"}]},{"type":"text","value":"或"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"name!{}"}]},{"type":"text","value":"都调用了宏。宏只是扩展为常规代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其实"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"println"}]},{"type":"text","value":" 就是一个宏"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    println!(\"{}\", \"Hello there!\");\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    println!(\"{}\", \"Hello there!\");\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这段代码会扩展为以下等效的代码:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    use std::io::{self, Write};\n    io::stdout().lock().write_all(b\"Hello there!\\n\").unwrap();\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    use std::io::{self, Write};\n    io::stdout().lock().write_all(b\"Hello there!\\n\").unwrap();\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"panic"}]},{"type":"text","value":"(恐慌/异常) 也是一个宏。它通过一条错误消息和错误的文件名/行号(如果启用的话)强制停止执行:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    panic!(\"This panics\");\n}\n// output: thread 'main' panicked at 'This panics', src/main.rs:3:5\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    panic!(\"This panics\");\n}\n// output: thread 'main' panicked at 'This panics', src/main.rs:3:5\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Some methods also panic. For example, the type can contain something, or it can contain nothing. If is called on it, and it contains nothing, it panics:Option.unwrap()\n有些方法也会引起"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"panic"}]},{"type":"text","value":"。例如，Option 类型可以包含某些内容，也可以不包含。如果。在它上面调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".unpack()"}]},{"type":"text","value":"但不包含任何东西的话，就会发生"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"panic"}]},{"type":"text","value":":"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Option"}]},{"type":"text","value":" 不是一个结构体 - 而是一个enum(枚举类)，它有两种变体(variant)"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"enum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        // enums variants 可以用于模式匹配:\n        match self {\n            Self::Some(t) => t,\n            Self::None => panic!(\".unwrap() called on a None option\"),\n        }\n    }\n}\n\nuse self::Option::{None, Some};\n\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"enum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        // enums variants 可以用于模式匹配:\n        match self {\n            Self::Some(t) => t,\n            Self::None => panic!(\".unwrap() called on a None option\"),\n        }\n    }\n}\n\nuse self::Option::{None, Some};\n\nfn main() {\n    let o1: Option<i32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option<i32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Result"}]},{"type":"text","value":" 也是一个 enum, 包含一个内容和一个错误"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It also panics when unwrapped and containing an error.\n当被解析出一个错误(error)时，它也会panic"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"变量绑定具有生命周期 (lifetime):"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        println!(\"x = {}\", x);\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        println!(\"x = {}\", x);\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引用同样也有生命周期"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\n        println!(\"x_ref = {}\", x_ref);\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\n        println!(\"x_ref = {}\", x_ref);\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引用的生命周期不能超过其借用的变量绑定的生命周期期:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let x_ref = {\n        let x = 42;\n        &x\n    };\n    println!(\"x_ref = {}\", x_ref);\n    // error: `x` does not live long enough\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let x_ref = {\n        let x = 42;\n        &x\n    };\n    println!(\"x_ref = {}\", x_ref);\n    // error: `x` does not live long enough\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A variable binding can be immutably borrowed multiple times:\n可以多次不可变地借用变量绑定:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &x;\n    let x_ref3 = &x;\n    println!(\"{} {} {}\", x_ref1, x_ref2, x_ref3);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &x;\n    let x_ref3 = &x;\n    println!(\"{} {} {}\", x_ref1, x_ref2, x_ref3);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"借用时，变量绑定不能发生变化"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let mut x = 42;\n    let x_ref = &x;\n    x = 13;\n    println!(\"x_ref = {}\", x_ref);\n    // error: cannot assign to `x` because it is borrowed\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let mut x = 42;\n    let x_ref = &x;\n    x = 13;\n    println!(\"x_ref = {}\", x_ref);\n    // error: cannot assign to `x` because it is borrowed\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不可变借用时，变量不能再被可变借用"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let mut x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &mut x;\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\n    println!(\"x_ref1 = {}\", x_ref1);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let mut x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &mut x;\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\n    println!(\"x_ref1 = {}\", x_ref1);\n}\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"引用必须总是有效的。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"函数参数中的引用也有生命周期:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn print(x: &i32) {\n    // `x` is borrowed (from the outside) for the\n    // entire time this function is called.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn print(x: &i32) {\n    // `x` is borrowed (from the outside) for the\n    // entire time this function is called.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具有引用参数的函数可以通过具有不同生命周期的借用来调用，因此:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有接受引用参数的函数都是泛型的"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生命周期是一个泛型的参数"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生命周期的名称以单引号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"'"}]},{"type":"text","value":"开头"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// elided (non-named) lifetimes:\nfn print(x: &i32) {}\n\n// named lifetimes:\nfn print<'a>(x: &'a i32) {}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// elided (non-named) lifetimes:\nfn print(x: &i32) {}\n\n// named lifetimes:\nfn print<'a>(x: &'a i32) {}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This allows returning references whose lifetime depend on the lifetime of the arguments:\n谁的生命周期依赖于参数的生命周期，就返回谁的引用"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Number {\n    value: i32,\n}\n\nfn number_value<'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn main() {\n    let n = Number { value: 47 };\n    let v = number_value(&n);\n    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.\n    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Number {\n    value: i32,\n}\n\nfn number_value<'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn main() {\n    let n = Number { value: 47 };\n    let v = number_value(&n);\n    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.\n    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当输入只有一个生命周期时，不需要命名，并且所有东西都有相同的生命周期，因此下面的两个函数是等价的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn number_value<'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn number_value(num: &Number) -> &i32 {\n    &num.value\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn number_value<'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn number_value(num: &Number) -> &i32 {\n    &num.value\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Structs can also be generic over lifetimes, which allows them to hold references:\n结构体可以在生命周期里都是泛型的，这使其可以接受引用"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = NumRef { x: &x };\n    // `x_ref` cannot outlive `x`, etc.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = NumRef { x: &x };\n    // `x_ref` cannot outlive `x`, etc.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同样的代码，额外添加了函数"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The same code, but with \"elided\" lifetimes:\n同样的代码，省略了声明周期"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref(x: &i32) -> NumRef<'_> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct NumRef<'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref(x: &i32) -> NumRef<'_> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"impl"}]},{"type":"text","value":" 代码块在生命周期里也是泛型的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl<'a> NumRef<'a> {\n    fn as_i32_ref(&'a self) -> &'a i32 {\n        self.x\n    }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_num_ref = NumRef { x: &x };\n    let x_i32_ref = x_num_ref.as_i32_ref();\n    // neither ref can outlive `x`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl<'a> NumRef<'a> {\n    fn as_i32_ref(&'a self) -> &'a i32 {\n        self.x\n    }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_num_ref = NumRef { x: &x };\n    let x_i32_ref = x_num_ref.as_i32_ref();\n    // neither ref can outlive `x`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但你也可以省略"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl<'a> NumRef<'a> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl<'a> NumRef<'a> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果不需要这个生命周期的名字，你可以狠狠地省略:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"impl NumRef<'_> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"impl NumRef<'_> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有一个特殊的生命周期:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"static"}]},{"type":"text","value":"，它对整个程序的生命周期都有效。(类比其他语言里的静态全局变量)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"String 是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"'static"}]},{"type":"text","value":"(静态全局)的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let p = Person {\n        name: \"fasterthanlime\",\n    };\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let p = Person {\n        name: \"fasterthanlime\",\n    };\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是 string的所有者不是"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"static"}]},{"type":"text","value":"的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // error: `name` does not live long enough\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // error: `name` does not live long enough\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在最后一个示例中，变量"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"name"}]},{"type":"text","value":"不是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&'static str"}]},{"type":"text","value":"，而是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"String"}]},{"type":"text","value":"。它是动态分配的，会被释放。它的生命周期小于整个程序(即使它在 main 中)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To store a non- string in , it needs to either:'staticPerson\n要想在结构体"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Person"}]},{"type":"text","value":"中存储非"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"'static"}]},{"type":"text","value":"的string，需要满足\nA) 在生命周期里是泛型:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Person<'a> {\n    name: &'a str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // `p` cannot outlive `name`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Person<'a> {\n    name: &'a str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // `p` cannot outlive `name`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者\nB) 获得string的所有权"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Person {\n    name: String,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: name };\n    // `name` was moved into `p`, their lifetimes are no longer tied.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Person {\n    name: String,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: name };\n    // `name` was moved into `p`, their lifetimes are no longer tied.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在结构体中，当字段与变量绑定同名时"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"    let p = Person { name: name };\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    let p = Person { name: name };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以简写成:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"    let p = Person { name };\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    let p = Person { name };\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rust 中的许多类型，有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"所有者"}]},{"type":"text","value":"(owned)的和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"非所有者"}]},{"type":"text","value":"(nom-owned)的变体:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"引用可以在没有所有权的情况下使用被绑定的变量"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Strings: String 是所有者, &str 是引用(reference)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Paths: PathBuf 是所有者, &Path 是引用"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Collections: "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vec<T>"}]},{"type":"text","value":" 所有者, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&[T]"}]},{"type":"text","value":"是引用"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rust 有切片(slice)-切片是对多个连续元素的引用\n可以借用 vector 的切片，例如"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    let v2 = &v[2..4];\n    println!(\"v2 = {:?}\", v2);\n}\n\n// output:\n// v2 = [3, 4]\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    let v2 = &v[2..4];\n    println!(\"v2 = {:?}\", v2);\n}\n\n// output:\n// v2 = [3, 4]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这不足为奇。利用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Index"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"IndexMut"}]},{"type":"text","value":"的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"trait"}]},{"type":"text","value":"就可以重载索引运算("},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"foo[index]"}]},{"type":"text","value":")。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(两个点)"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".."}]},{"type":"text","value":"语法只是表示范围(range),range只是在标准库里定义的少数结构体"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"范围是开放式的，一般是左闭右开区间，如果最右端使用等号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"="}]},{"type":"text","value":"，右端就是闭区间"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    // 0 or greater\n    println!(\"{:?}\", (0..).contains(&100)); // true\n    // strictly less than 20\n    println!(\"{:?}\", (..20).contains(&20)); // false\n    // 20 or less than 20\n    println!(\"{:?}\", (..=20).contains(&20)); // true\n    // only 3, 4, 5\n    println!(\"{:?}\", (3..6).contains(&4)); // true\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    // 0 or greater\n    println!(\"{:?}\", (0..).contains(&100)); // true\n    // strictly less than 20\n    println!(\"{:?}\", (..20).contains(&20)); // false\n    // 20 or less than 20\n    println!(\"{:?}\", (..=20).contains(&20)); // true\n    // only 3, 4, 5\n    println!(\"{:?}\", (3..6).contains(&4)); // true\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"借用规则也适用于切片"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn tail(s: &[u8]) -> &[u8] {\n  &s[1..] \n}\n\nfn main() {\n    let x = &[1, 2, 3, 4, 5];\n    let y = tail(x);\n    println!(\"y = {:?}\", y);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn tail(s: &[u8]) -> &[u8] {\n  &s[1..] \n}\n\nfn main() {\n    let x = &[1, 2, 3, 4, 5];\n    let y = tail(x);\n    println!(\"y = {:?}\", y);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"等价于"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn tail<'a>(s: &'a [u8]) -> &'a [u8] {\n  &s[1..] \n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn tail<'a>(s: &'a [u8]) -> &'a [u8] {\n  &s[1..] \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是合法的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let y = {\n        let x = &[1, 2, 3, 4, 5];\n        tail(x)\n    };\n    println!(\"y = {:?}\", y);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let y = {\n        let x = &[1, 2, 3, 4, 5];\n        tail(x)\n    };\n    println!(\"y = {:?}\", y);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但这因为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[1,2,3,4,5]"}]},{"type":"text","value":"是一个静态数组"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这是不合法的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let y = {\n        let v = vec![1, 2, 3, 4, 5];\n        tail(&v)\n        // error: `v` does not live long enough\n    };\n    println!(\"y = {:?}\", y);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let y = {\n        let v = vec![1, 2, 3, 4, 5];\n        tail(&v)\n        // error: `v` does not live long enough\n    };\n    println!(\"y = {:?}\", y);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为vector是分配在堆上的，没有"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"'static"}]},{"type":"text","value":"的生命周期"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"&str实际上是切片:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn file_ext(name: &str) -> Option<&str> {\n    // this does not create a new string - it returns\n    // a slice of the argument.\n    name.split(\".\").last()\n}\n\nfn main() {\n    let name = \"Read me. Or don't.txt\";\n    if let Some(ext) = file_ext(name) {\n        println!(\"file extension: {}\", ext);\n    } else {\n        println!(\"no file extension\");\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn file_ext(name: &str) -> Option<&str> {\n    // this does not create a new string - it returns\n    // a slice of the argument.\n    name.split(\".\").last()\n}\n\nfn main() {\n    let name = \"Read me. Or don't.txt\";\n    if let Some(ext) = file_ext(name) {\n        println!(\"file extension: {}\", ext);\n    } else {\n        println!(\"no file extension\");\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以借用规则也适用于此:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let ext = {\n        let name = String::from(\"Read me. Or don't.txt\");\n        file_ext(&name).unwrap_or(\"\")\n        // error: `name` does not live long enough\n    };\n    println!(\"extension: {:?}\", ext);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let ext = {\n        let name = String::from(\"Read me. Or don't.txt\");\n        file_ext(&name).unwrap_or(\"\")\n        // error: `name` does not live long enough\n    };\n    println!(\"extension: {:?}\", ext);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"函数可以失败并特别地返回一个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Result"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]);\n    println!(\"{:?}\", s);\n    // prints: Ok(\"🍉\")\n\n    let s = std::str::from_utf8(&[195, 40]);\n    println!(\"{:?}\", s);\n    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]);\n    println!(\"{:?}\", s);\n    // prints: Ok(\"🍉\")\n\n    let s = std::str::from_utf8(&[195, 40]);\n    println!(\"{:?}\", s);\n    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果你想在失败的情况下"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"panic"}]},{"type":"text","value":",可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":".unwrap()"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();\n    println!(\"{:?}\", s);\n    // prints: \"🍉\"\n\n    let s = std::str::from_utf8(&[195, 40]).unwrap();\n    // prints: thread 'main' panicked at 'called `Result::unwrap()`\n    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',\n    // src/libcore/result.rs:1165:5\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();\n    println!(\"{:?}\", s);\n    // prints: \"🍉\"\n\n    let s = std::str::from_utf8(&[195, 40]).unwrap();\n    // prints: thread 'main' panicked at 'called `Result::unwrap()`\n    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',\n    // src/libcore/result.rs:1165:5\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者用 .expect(), 可以自定义信息"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let s = std::str::from_utf8(&[195, 40]).expect(\"valid utf-8\");\n    // prints: thread 'main' panicked at 'valid utf-8: Utf8Error\n    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let s = std::str::from_utf8(&[195, 40]).expect(\"valid utf-8\");\n    // prints: thread 'main' panicked at 'valid utf-8: Utf8Error\n    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者使用模式匹配"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"match"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => panic!(e),\n    }\n    // prints 🍉\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => panic!(e),\n    }\n    // prints 🍉\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者使用:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"if let"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {\n        println!(\"{}\", s);\n    }\n    // prints 🍉\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {\n        println!(\"{}\", s);\n    }\n    // prints 🍉\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者将错误上报:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() -> Result<(), std::str::Utf8Error> {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => return Err(e),\n    }\n    Ok(())\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() -> Result<(), std::str::Utf8Error> {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => return Err(e),\n    }\n    Ok(())\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"?"}]},{"type":"text","value":" 简单处理"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() -> Result<(), std::str::Utf8Error> {\n    let s = std::str::from_utf8(&[240, 159, 141, 137])?;\n    println!(\"{}\", s);\n    Ok(())\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() -> Result<(), std::str::Utf8Error> {\n    let s = std::str::from_utf8(&[240, 159, 141, 137])?;\n    println!(\"{}\", s);\n    Ok(())\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"操作符 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 可以用于解引用，但是您不需要这样来访问字段或调用方法:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    println!(\"({}, {})\", p_ref.x, p_ref.y);\n}\n\n// prints `(1, 3)`\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    println!(\"({}, {})\", p_ref.x, p_ref.y);\n}\n\n// prints `(1, 3)`\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果类型为Copy时只需要这样:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref);\n    // error: cannot move out of `*p_ref` which is behind a shared reference\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref);\n    // error: cannot move out of `*p_ref` which is behind a shared reference\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// now `Point` is `Copy`\n#[derive(Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref); // ...and now this works\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// now `Point` is `Copy`\n#[derive(Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref); // ...and now this works\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Closure"}]},{"type":"text","value":"(闭包)只是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Fn"}]},{"type":"text","value":"、 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"FnMut"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"FnOnce"}]},{"type":"text","value":" 类型的函数，具有一定的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"context"}]},{"type":"text","value":"(语境/运行环境/上下文)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Their parameters are a comma-separated list of names within a pair of pipes (). They don't need curly braces, unless you want to have multiple statements.|\nClosure的参数是一对管道(|)中以逗号分隔的名称列表。不需要花括号，除非您想要有多个语句。"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    for_each_planet(|planet| println!(\"Hello, {}\", planet));\n}\n\n// prints:\n// Hello, Earth\n// Hello, Mars\n// Hello, Jupiter\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    for_each_planet(|planet| println!(\"Hello, {}\", planet));\n}\n\n// prints:\n// Hello, Earth\n// Hello, Mars\n// Hello, Jupiter\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"借用规则也适用与此"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // our closure borrows `greeting`, so it cannot outlive it\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // our closure borrows `greeting`, so it cannot outlive it\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个例子不能运行:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str) + 'static // `F` must now have \"'static\" lifetime\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n\nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // error: closure may outlive the current function, but it borrows\n    // `greeting`, which is owned by the current function\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn for_each_planet<F>(f: F)\n    where F: Fn(&'static str) + 'static // `F` must now have \"'static\" lifetime\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n\nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // error: closure may outlive the current function, but it borrows\n    // `greeting`, which is owned by the current function\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但这个可以:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let greeting = String::from(\"You're doing great\");\n    for_each_planet(move |planet| println!(\"{}, {}\", greeting, planet));\n    // `greeting` is no longer borrowed, it is *moved* into\n    // the closure.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let greeting = String::from(\"You're doing great\");\n    for_each_planet(move |planet| println!(\"{}, {}\", greeting, planet));\n    // `greeting` is no longer borrowed, it is *moved* into\n    // the closure.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"An needs to be mutably borrowed to be called, so it can only be called once at a time.FnMut\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"FnMut"}]},{"type":"text","value":" 需要可变地借用才能被调用，因此一次只能调用一次"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是合法的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而这不合法:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n    // error: cannot borrow `f` as mutable more than once at a time\n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n    // error: cannot borrow `f` as mutable more than once at a time\n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这也是合法的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"FnMut"}]},{"type":"text","value":" 之所以存在，是因为一些闭包可变地借用本地变量"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        x * acc\n    });\n}\n\n// output: 24\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        x * acc\n    });\n}\n\n// output: 24\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些闭包不能被传递给期望的 Fn 函数:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        // error: cannot assign to `acc`, as it is a\n        // captured variable in a `Fn` closure.\n        // the compiler suggests \"changing foobar\n        // to accept closures that implement `FnMut`\"\n        x * acc\n    });\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        // error: cannot assign to `acc`, as it is a\n        // captured variable in a `Fn` closure.\n        // the compiler suggests \"changing foobar\n        // to accept closures that implement `FnMut`\"\n        x * acc\n    });\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"FnOnce 闭包只能调用一次。它们之所以存在，是因为某些闭包移出了在捕获时被移动的变量"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n}\n \nfn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    // `s` was moved into our closure, and our\n    // closures moves it to the caller by returning\n    // it. Remember that `String` is not `Copy`.\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n}\n \nfn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    // `s` was moved into our closure, and our\n    // closures moves it to the caller by returning\n    // it. Remember that `String` is not `Copy`.\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是自然执行的，因为需要移动 FnOnce 闭包才能被调用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以这个例子是不合法的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n    println!(\"{}\", f()); \n    // error: use of moved value: `f`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n    println!(\"{}\", f()); \n    // error: use of moved value: `f`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而且，如果你需要说服我们的关闭确实移动 s，这也是非法的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    foobar(move || s);\n    // use of moved value: `s`\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    foobar(move || s);\n    // use of moved value: `s`\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但这个是对的:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let s = String::from(\"alright\");\n    foobar(|| s.clone());\n    foobar(|| s.clone());\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let s = String::from(\"alright\");\n    foobar(|| s.clone());\n    foobar(|| s.clone());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"带有两个参数的闭包:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn foobar<F>(x: i32, y: i32, is_greater: F)\n    where F: Fn(i32, i32) -> bool\n{\n    let (greater, smaller) = if is_greater(x, y) {\n        (x, y)\n    } else {\n        (y, x)\n    };\n    println!(\"{} is greater than {}\", greater, smaller);\n}\n \nfn main() {\n    foobar(32, 64, |x, y| x > y);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn foobar<F>(x: i32, y: i32, is_greater: F)\n    where F: Fn(i32, i32) -> bool\n{\n    let (greater, smaller) = if is_greater(x, y) {\n        (x, y)\n    } else {\n        (y, x)\n    };\n    println!(\"{} is greater than {}\", greater, smaller);\n}\n \nfn main() {\n    foobar(32, 64, |x, y| x > y);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"省略所有参数的闭包:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    foobar(32, 64, |_, _| panic!(\"Comparing is futile!\"));\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    foobar(32, 64, |_, _| panic!(\"Comparing is futile!\"));\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here's a slightly worrying closure:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn countdown<F>(count: usize, tick: F)\n    where F: Fn(usize)\n{\n    for i in (1..=count).rev() {\n        tick(i);\n    }\n}\n \nfn main() {\n    countdown(3, |i| println!(\"tick {}...\", i));\n}\n\n// output:\n// tick 3...\n// tick 2...\n// tick 1...\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn countdown<F>(count: usize, tick: F)\n    where F: Fn(usize)\n{\n    for i in (1..=count).rev() {\n        tick(i);\n    }\n}\n \nfn main() {\n    countdown(3, |i| println!(\"tick {}...\", i));\n}\n\n// output:\n// tick 3...\n// tick 2...\n// tick 1...\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"And here's a toilet closure:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    countdown(3, |_| ());\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    countdown(3, |_| ());\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样叫是因为"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"|_| ()"}]},{"type":"text","value":"看起来像厕所"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"任何可迭代的内容都可以在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"for in"}]},{"type":"text","value":" 循环中使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We've just seen a range being used, but it also works with a "},{"type":"element","tag":"vec","props":{},"children":[]},{"type":"text","value":"\n我们之前看了range的使用，也可以用于Vec"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    for i in vec![52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    for i in vec![52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或用于切片:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    for i in &[52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n\n// output:\n// I like the number 52\n// I like the number 49\n// I like the number 21\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    for i in &[52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n\n// output:\n// I like the number 52\n// I like the number 49\n// I like the number 21\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或一个实际的迭代器(actual iterator)"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    // note: `&str` also has a `.bytes()` iterator.\n    // Rust's `char` type is a \"Unicode scalar value\"\n    for c in \"rust\".chars() {\n        println!(\"Give me a {}\", c);\n    }\n}\n\n// output:\n// Give me a r\n// Give me a u\n// Give me a s\n// Give me a t\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    // note: `&str` also has a `.bytes()` iterator.\n    // Rust's `char` type is a \"Unicode scalar value\"\n    for c in \"rust\".chars() {\n        println!(\"Give me a {}\", c);\n    }\n}\n\n// output:\n// Give me a r\n// Give me a u\n// Give me a s\n// Give me a t\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"即使迭代项被过滤、映射和扁平化"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    for c in \"SuRPRISE INbOUND\"\n        .chars()\n        .filter(|c| c.is_lowercase())\n        .flat_map(|c| c.to_uppercase())\n    {\n        print!(\"{}\", c);\n    }\n    println!();\n}\n\n// output: UB\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    for c in \"SuRPRISE INbOUND\"\n        .chars()\n        .filter(|c| c.is_lowercase())\n        .flat_map(|c| c.to_uppercase())\n    {\n        print!(\"{}\", c);\n    }\n    println!();\n}\n\n// output: UB\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你可以从函数返回一个闭包"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn make_tester(answer: String) -> impl Fn(&str) -> bool {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    // you can use `.into()` to perform conversions\n    // between various types, here `&'static str` and `String`\n    let test = make_tester(\"hunter2\".into());\n    println!(\"{}\", test(\"******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn make_tester(answer: String) -> impl Fn(&str) -> bool {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    // you can use `.into()` to perform conversions\n    // between various types, here `&'static str` and `String`\n    let test = make_tester(\"hunter2\".into());\n    println!(\"{}\", test(\"******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你甚至可以将一个对函数参数的引用移动到它返回的闭包中:"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn make_tester<'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    let test = make_tester(\"hunter2\");\n    println!(\"{}\", test(\"*******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n\n// output:\n// false\n// true\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn make_tester<'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    let test = make_tester(\"hunter2\");\n    println!(\"{}\", test(\"*******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n\n// output:\n// false\n// true\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或者略掉生命周期"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {\n    move |challenge| {\n        challenge == answer\n    }\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {\n    move |challenge| {\n        challenge == answer\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[]}},"_type":"markdown","_id":"content:essay:32.(翻译)rust半小时学习.md","_source":"content","_file":"essay/32.(翻译)rust半小时学习.md","_stem":"essay/32.(翻译)rust半小时学习","_extension":"md"}