{"_path":"/essay/2.vue初学笔记-单文件组件","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"vue初学笔记-单文件组件","description":"一个 Vue 单文件组件 (SFC)，通常使用 *.vue 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。","subtitle":"Vue3 初心者のノート","index":2,"date":"2022-12-19 00:00:00","lunar_date":"霜月廿六","year":"2022","month":"12","month_en":"Dec","day":"19","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/002.jpg","categories":"vue","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个 Vue 单文件组件 (SFC)，通常使用 *.vue 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。"}]},{"type":"element","tag":"h1","props":{"id":"参考项目结构"},"children":[{"type":"text","value":"参考项目结构"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://doc.ruoyi.vip/ruoyi-vue/","rel":["nofollow"]},"children":[{"type":"text","value":"royi前后端分离的vue项目"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在vue项目的src文件夹下"}]},{"type":"element","tag":"pre","props":{"code":"|_src\n    |_api\n    |_assets\n    |_components\n    |_directive\n    |_icons\n    |_layout\n    |_plugins\n    |_router\n    |_store\n    |_styles\n    |_utils\n    |_views\n    \n    app.vue\n    main.js\n    permission.js\n    setting.js\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"|_src\n    |_api\n    |_assets\n    |_components\n    |_directive\n    |_icons\n    |_layout\n    |_plugins\n    |_router\n    |_store\n    |_styles\n    |_utils\n    |_views\n    \n    app.vue\n    main.js\n    permission.js\n    setting.js\n\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"api"}]},{"type":"text","value":"：接口文件夹，存放对数据接口封装的方法（前后端交互的接口，此处需要声明前端需要使用的方法，该方法在后端的URL路径，请求方式（get、post等），参数）。前端在处理业务需要调用后端方法时，import此处api文件夹里相应js文件里的方法，这个方法通过url，请求方式与参数与后端建立映射。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"assets"}]},{"type":"text","value":"：静态资源文件夹，存放图片，css样式等资源"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"components"}]},{"type":"text","value":"：组件库文件夹，存放组件（一些可复用，非独立的页面），也可以创建完整页面，但一般完整页面会在views文件夹编写"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"directive"}]},{"type":"text","value":"：指令文件夹，可以在这里自定义像v-for、v-if之类的指令以供使用"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/wuj1935/article/details/120705144","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/wuj1935/article/details/120705144"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"icons"}]},{"type":"text","value":"：图标文件夹"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"layout"}]},{"type":"text","value":"：公共布局组件文件，如项目页面顶部栏区域、侧边导航栏(大部分页面公共的布局)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"plugins"}]},{"type":"text","value":":插件文件夹，自定义插件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"router"}]},{"type":"text","value":":路由配置文件，存放路由跳转的配置信息,路由用于设定访问路径，并将路径和组件映射起来，访问对应的路径就会跳转到相应的页面（组件）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/wulala_hei/article/details/80488727","rel":["nofollow"]},"children":[{"type":"text","value":"vue路由"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"store"}]},{"type":"text","value":"：存放 vuex 为vue专门开发的状态管理器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"styles"}]},{"type":"text","value":"：全局样式文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"utils"}]},{"type":"text","value":":工具包文件夹，存放工具函数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"views"}]},{"type":"text","value":"：视图文件夹，存放各个页面的vue文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"app.vue"}]},{"type":"text","value":"：项目的主组件，页面入口文件 ，所有页面都在app.vue下进行切换，app.vue负责构建定义及页面组件归集"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"main.js"}]},{"type":"text","value":":实例化Vue、放置项目中经常会用到的插件和CSS样式、存储全局变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"permission.js"}]},{"type":"text","value":": 权限管理"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"setting.js"}]},{"type":"text","value":":配置"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://juejin.cn/post/7041506596597432334","rel":["nofollow"]},"children":[{"type":"text","value":"配置篇(settings.js)"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来说，我们只需要了解api、router、views文件夹、app.vue、main.js的内容即可上手"}]},{"type":"element","tag":"h1","props":{"id":"xxxvue文件单文件组件sfc"},"children":[{"type":"text","value":"xxx.vue文件（单文件组件/SFC）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://cn.vuejs.org/api/sfc-spec.html","rel":["nofollow"]},"children":[{"type":"text","value":"vue官方文档-单文件组件语法定义"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://cn.vuejs.org/guide/scaling-up/sfc.html","rel":["nofollow"]},"children":[{"type":"text","value":"vue官方文档-应用规模化-单文件组件"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/XOIIUUZZ/article/details/103095298","rel":["nofollow"]},"children":[{"type":"text","value":"https://blog.csdn.net/XOIIUUZZ/article/details/103095298"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先我们需要了解一下一个vue文件一般由哪些部分组成"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单个vue文件被称为单文件组件（Single-File Component，缩写为SFC），其内容为html、css、js的延伸"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue SFC 是一个框架指定的文件格式，因此必须交由 @vue/compiler-sfc 编译为标准的 JavaScript 和 CSS，一个编译后的 SFC 是一个标准的JavaScript(ES) 模块"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个.vue文件主要有3个部分"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<template>"}]},{"type":"text","value":"显示的内容"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"</template>"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<script>"}]},{"type":"text","value":"执行的功能（业务逻辑）"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"</script>"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<style>"}]},{"type":"text","value":"内容的样式"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"</style>"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可分别看成是html、js、css的功能，类比为名词、动词、形容词"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"官网示例如下"}]},{"type":"text","value":"："}]},{"type":"element","tag":"pre","props":{"code":"<template>\n  <div class=\"example\">{{ msg }}</div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n}\n</script>\n\n<style>\n.example {\n  color: red;\n}\n</style>\n\n<custom1>\n  This could be e.g. documentation for the component.\n</custom1>\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<template>\n  <div class=\"example\">{{ msg }}</div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n}\n</script>\n\n<style>\n.example {\n  color: red;\n}\n</style>\n\n<custom1>\n  This could be e.g. documentation for the component.\n</custom1>\n"}]}]},{"type":"element","tag":"h2","props":{"id":"template"},"children":[{"type":"text","value":"template"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<template></template>"}]},{"type":"text","value":"语块包裹的内容将会被提取、传递给 @vue/compiler-dom，预编译为 JavaScript 渲染函数，并附在导出的组件上作为其 render 选项（vue渲染页面的一种方式）。\n我们来看一下示例中的简单的template视图层"}]},{"type":"element","tag":"pre","props":{"code":"<div class=\"example\">{{ msg }}</div>\n","language":"html","meta":"","className":["language-html"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<div class=\"example\">{{ msg }}</div>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先是一组"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<div>"}]},{"type":"text","value":"标签，表示包含的内容是一个独立的部分，标签里的内容作为一个整体，有福同享，有难同当。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"class"}]},{"type":"text","value":"是表示样式的类型，其在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<div>"}]},{"type":"text","value":"的尖括号表明"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<div>"}]},{"type":"text","value":"里包含的内容都会应用到该样式，那么它所说的样式类型是\"example\",这个样式来源里我们在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<style></style>"}]},{"type":"text","value":"所定义的样式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最后让我们看看这个独立部分里面的内容"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{{ msg }}"}]},{"type":"text","value":"，这里的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{{}}"}]},{"type":"text","value":"叫做文本插值，使用\"Mustache\"语法，它与"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"script"}]},{"type":"text","value":"标签里定义的msg的数据绑定，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{{msg}}"}]},{"type":"text","value":"会被替代为msg的值'Hello world!'，并且保持同步更新"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在这基础之上，我们还可以给这个"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<div>"}]},{"type":"text","value":"块加上一个身份标识id"}]},{"type":"element","tag":"pre","props":{"code":"<div id=\"app\" class=\"example\">{{ msg }}</div>\n","language":"html","meta":"","className":["language-html"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<div id=\"app\" class=\"example\">{{ msg }}</div>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当需要用到该部分的内容时，即可通过\"app\"这个id来引用"}]},{"type":"element","tag":"h2","props":{"id":"script"},"children":[{"type":"text","value":"script"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<script></script>"}]},{"type":"text","value":"包裹的是脚本代码，会作为es模块执行，进行业务逻辑的处理"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ECMAScript模块（简称ES模块）是2015年推出的 JavaScript 中代码重用的机制"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们来看一下示例中的简单的script逻辑层"}]},{"type":"element","tag":"pre","props":{"code":"\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n}\n\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n}\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"export主要用于对外输出本模块变量的接口，一个文件就可以被理解为一个模块,首先是定义数据对象，使用对象来存放数据。js中{}里的内容表示一个对象，在这里有两种写法，一种是直接定义一个对象，一种是通过一个函数返回一个data对象，基本都用后者，原因参考如下\n"},{"type":"element","tag":"a","props":{"href":"https://juejin.cn/post/7002584686232862734","rel":["nofollow"]},"children":[{"type":"text","value":"Vue中的data是什么"}]}]},{"type":"element","tag":"pre","props":{"code":"//直接定义\ndata:{}\n//函数返回值\ndata() { return {}}\n\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//直接定义\ndata:{}\n//函数返回值\ndata() { return {}}\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除data之外，script层里还可以写其他内容\n"},{"type":"element","tag":"a","props":{"href":"https://juejin.cn/post/6844903796481458183","rel":["nofollow"]},"children":[{"type":"text","value":"参考:vue script结构"}]}]},{"type":"element","tag":"pre","props":{"code":"<script>\nexport default {\nname: \"Home\",\ndata() {\n  return {};\n},\nmethods: {\n  // 组件的方法\n},\nwatch: {\n  // watch擅长处理的场景：一个数据影响多个数据\n},\ncomputed: {\n  // computed擅长处理的场景：一个数据受多个数据影响\n},\nbeforeCreate: function() {\n  // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。\n},\ncreated: function() {\n  // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。\n},\nbeforeMount: function() {\n  // 在挂载开始之前被调用：相关的 render 函数首次被调用。\n},\nmounted: function() {\n  // 编译好的HTML挂载到页面完成后执行的事件钩子\n  // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。\n  // 此钩子函数中一般会做一些ajax请求获取数据进行数据初始化\n  console.log(\"Home done\");\n},\nbeforeUpdate: function() {\n  // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n},\nupdated: function() {\n  // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n  // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\n  // 该钩子在服务器端渲染期间不被调用。\n},\nbeforeDestroy: function() {\n  // 实例销毁之前调用。在这一步，实例仍然完全可用。\n},\ndestroyed: function() {\n  // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。\n}\n};\n</script>\n\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<script>\nexport default {\nname: \"Home\",\ndata() {\n  return {};\n},\nmethods: {\n  // 组件的方法\n},\nwatch: {\n  // watch擅长处理的场景：一个数据影响多个数据\n},\ncomputed: {\n  // computed擅长处理的场景：一个数据受多个数据影响\n},\nbeforeCreate: function() {\n  // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。\n},\ncreated: function() {\n  // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。\n},\nbeforeMount: function() {\n  // 在挂载开始之前被调用：相关的 render 函数首次被调用。\n},\nmounted: function() {\n  // 编译好的HTML挂载到页面完成后执行的事件钩子\n  // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。\n  // 此钩子函数中一般会做一些ajax请求获取数据进行数据初始化\n  console.log(\"Home done\");\n},\nbeforeUpdate: function() {\n  // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n},\nupdated: function() {\n  // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n  // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\n  // 该钩子在服务器端渲染期间不被调用。\n},\nbeforeDestroy: function() {\n  // 实例销毁之前调用。在这一步，实例仍然完全可用。\n},\ndestroyed: function() {\n  // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。\n}\n};\n</script>\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在script中除了export（导出）外，还有import（导入），举个例子"}]},{"type":"element","tag":"pre","props":{"code":"//从某路径下的show.vue文件导入showMsg()方法,该方法会显示括号里参数的内容\nimport { showMsg } from \"@/api/show\";\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n  \n  created() {\n    //实例已经创建完成之后被调用,即当你打开这个页面时就会使用\n    //this.showHello()表示该组件方法method里的里的showHello()\n    this.showHello();\n  },\n  method:{\n    showHello() {\n      //调用import进来showMsg,参数this.Msg为该组件数据data里的Msg\n      showMsg(this.msg);\n      };\n    },\n  }\n\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//从某路径下的show.vue文件导入showMsg()方法,该方法会显示括号里参数的内容\nimport { showMsg } from \"@/api/show\";\nexport default {\n  data() {\n    return {\n      msg: 'Hello world!'\n    }\n  }\n  \n  created() {\n    //实例已经创建完成之后被调用,即当你打开这个页面时就会使用\n    //this.showHello()表示该组件方法method里的里的showHello()\n    this.showHello();\n  },\n  method:{\n    showHello() {\n      //调用import进来showMsg,参数this.Msg为该组件数据data里的Msg\n      showMsg(this.msg);\n      };\n    },\n  }\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当打开一个页面时会创建一个vue实例，调用created(),里面又调用了method里的showMsg方法，里面又调用了导入进来的showMsg方法，其参数来源于data里的Msg，而Msg又会与template里的内容绑定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了导入方法，还可以导入组件，官网原话"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue SFC 是一个框架指定的文件格式，因此必须交由 @vue/compiler-sfc 编译为标准的 JavaScript 和 CSS，一个编译后的 SFC 是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入 SFC："}]}]},{"type":"element","tag":"pre","props":{"code":"import MyComponent from './MyComponent.vue'\n\nexport default {\n  components: {\n    MyComponent\n  }\n}\n\n","language":"js","meta":"","className":["language-js"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import MyComponent from './MyComponent.vue'\n\nexport default {\n  components: {\n    MyComponent\n  }\n}\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假如说我们已经写好了一个MyComponent.vue文件（单文件组件），并且在其他vue文件中想要复用这个组件，import后在template层使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<MyComponent></MyComponent>"}]},{"type":"text","value":"即可"}]},{"type":"element","tag":"h2","props":{"id":"style"},"children":[{"type":"text","value":"style"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<style></style>"}]},{"type":"text","value":"包裹的是样式，可以使用 scoped 或 module attribute 来帮助封装当前组件的样式，在template层使用时class=\"\"即可使用样式\n同样看官网示例中"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<style>"}]},{"type":"text","value":"标签里的内容"}]},{"type":"element","tag":"pre","props":{"code":"\n.example {\n  color: red;\n}\n\n","language":"css","meta":"","className":["language-css"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n.example {\n  color: red;\n}\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"样式名为example，在template中使用该样式时加上class=\"example\"即可\n此外在标签中可以使用 scoped 等帮助封装当前组件的样式\n例如"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<style scoped></style>"}]},{"type":"text","value":"表明该CSS样式只能作用于当前的组件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://cn.vuejs.org/api/sfc-css-features.html","rel":["nofollow"]},"children":[{"type":"text","value":"单文件组件 CSS 功能"}]}]},{"type":"element","tag":"h1","props":{"id":"小结"},"children":[{"type":"text","value":"小结"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个vue文件基本上就由模板、逻辑与样式三部分组成，模板定义了一个个独立的模块与内容，样式决定了这些模块的外观，逻辑描述模板里的内容如何呈现。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n至此单个vue文件的逻辑基本已理清， 但要写好一个界面，一个好看的界面还有很多细节需要慢慢地去熟悉，对于vue还要搞清router路由，各个页面之间的逻辑关系，且听下回分解"}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[{"id":"template","depth":2,"text":"template"},{"id":"script","depth":2,"text":"script"},{"id":"style","depth":2,"text":"style"}]}},"_type":"markdown","_id":"content:essay:2.vue初学笔记-单文件组件.md","_source":"content","_file":"essay/2.vue初学笔记-单文件组件.md","_stem":"essay/2.vue初学笔记-单文件组件","_extension":"md"}