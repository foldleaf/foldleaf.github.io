{"_path":"/essay/16.go的多线程-实时采集机器数据","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"go的多线程-实时采集机器数据","description":"1.与目标设备进行tcp连接，接受目标设备发送的数据并存储。\n2.能随意建立复数连接并分别存储对应接收的数据数据。\n3.发送命令可以取消指定的连接。","subtitle":"Real-time data acquisition","index":16,"date":"2023-02-27","lunar_date":"二月初八","year":"2023","month":"02","month_en":"Feb","day":"27","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/016.jpg","categories":"golang","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"1.与目标设备进行tcp连接，接受目标设备发送的数据并存储。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n2.能随意建立复数连接并分别存储对应接收的数据数据。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n3.发送命令可以取消指定的连接。"}]},{"type":"element","tag":"h1","props":{"id":"准备"},"children":[{"type":"text","value":"准备"}]},{"type":"element","tag":"h2","props":{"id":"mongodb"},"children":[{"type":"text","value":"mongodb"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本人使用 docker 进行安装使用 mongodb，你也可以在"},{"type":"element","tag":"a","props":{"href":"https://www.mongodb.com/atlas/database","rel":["nofollow"]},"children":[{"type":"text","value":"mongodb官网"}]},{"type":"text","value":"下载安装。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先安装 docker，推荐可以使用docker管理工具 "},{"type":"element","tag":"a","props":{"href":"https://www.docker.com/products/docker-desktop/","rel":["nofollow"]},"children":[{"type":"text","value":"Docker Desktop"}]},{"type":"text","value":"，windows下的安装可参考"},{"type":"element","tag":"a","props":{"href":"https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP","rel":["nofollow"]},"children":[{"type":"text","value":"Docker 简介和安装"}]},{"type":"text","value":"。\nlinux下请选择对应发行版的方法，ArchLinux的安装可以参考:"}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":"yay -S docker\n# 可选：linux 下的 docker 管理工具\nyay -S lazydocker\n# 启动 docker 服务\nsudo systemctl start docker\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"yay -S docker\n# 可选：linux 下的 docker 管理工具\nyay -S lazydocker\n# 启动 docker 服务\nsudo systemctl start docker\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"安装完docker后，使用docker 拉取 mongo 镜像并在名为 mongodb 的容器中运行，指定运行端口为20717"}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":"docker pull mongo\ndocker run -d -p 20717:20717 --name mongodb -d mongo\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"docker pull mongo\ndocker run -d -p 20717:20717 --name mongodb -d mongo\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"访问localhost:20717，出现以下信息则表明服务启动成功"}]},{"type":"element","tag":"pre","props":{"className":["language-txt"],"code":"It looks like you are trying to access MongoDB over HTTP on the native driver port.\n","language":"txt","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"It looks like you are trying to access MongoDB over HTTP on the native driver port.\n"}]}]},{"type":"element","tag":"h2","props":{"id":"gin"},"children":[{"type":"text","value":"Gin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://gin-gonic.com/zh-cn/docs/quickstart/","rel":["nofollow"]},"children":[{"type":"text","value":"https://gin-gonic.com/zh-cn/docs/quickstart/"}]}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":"# 安装 gin ，这是一个 web 框架\ngo get -u github.com/gin-gonic/gin\n# 安装跨域中间件 cors，如果有需要的话\ngo get github.com/gin-contrib/cors\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 安装 gin ，这是一个 web 框架\ngo get -u github.com/gin-gonic/gin\n# 安装跨域中间件 cors，如果有需要的话\ngo get github.com/gin-contrib/cors\n"}]}]},{"type":"element","tag":"h2","props":{"id":"mongo-driver"},"children":[{"type":"text","value":"mongo-driver"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/mongodb/mongo-go-driver","rel":["nofollow"]},"children":[{"type":"text","value":"https://github.com/mongodb/mongo-go-driver"}]}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":"# 安装 mongo-driver，用于操作 mongodb\ngo get go.mongodb.org/mongo-driver/mongo\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 安装 mongo-driver，用于操作 mongodb\ngo get go.mongodb.org/mongo-driver/mongo\n"}]}]},{"type":"element","tag":"h1","props":{"id":"路由设置"},"children":[{"type":"text","value":"路由设置"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"/router"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 路由初始化\nfunc InitRouter() {\n    r := gin.Default()\n    // 允许跨域\n    r.Use(cors.Default())\n    // 路由\n    r.POST(\"connect/:ip\",api.NewConnect)\n    r.POST(\"disconnect/:ip\",api.Disconnect)\n\n    //在本地 20000 端口运行\n    r.Run(\":20000\")\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 路由初始化\nfunc InitRouter() {\n    r := gin.Default()\n    // 允许跨域\n    r.Use(cors.Default())\n    // 路由\n    r.POST(\"connect/:ip\",api.NewConnect)\n    r.POST(\"disconnect/:ip\",api.Disconnect)\n\n    //在本地 20000 端口运行\n    r.Run(\":20000\")\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"数据模型"},"children":[{"type":"text","value":"数据模型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"/model\n数据模型："}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 消息结构体\ntype Msg struct {\n    // 获取数据的时间，不是设备产生数据的时间\n    Time string \n    // 连接的设备 ip\n    Ip   string\n    // 设备发送的数据，原始数据未解析\n    Data string     \n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 消息结构体\ntype Msg struct {\n    // 获取数据的时间，不是设备产生数据的时间\n    Time string \n    // 连接的设备 ip\n    Ip   string\n    // 设备发送的数据，原始数据未解析\n    Data string     \n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"获取数据库连接对象："}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// 初始化数据库，返回 *mongo.Client 用于操作数据库\nfunc InitDB(ctx *gin.Context) *mongo.Client{\n    ip:=ctx.Param(\"ip\")\n    // 设置客户端连接配置\n    clientOption := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    // 连接 mongodb，获取连接对象\n    client, err := mongo.Connect(ctx, clientOption)\n    if err != nil {\n        fmt.Println(ip,\":连接mongo失败\",err)\n    }\n    fmt.Println(ip,\":连接mongo成功\")\n\n    return client\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 初始化数据库，返回 *mongo.Client 用于操作数据库\nfunc InitDB(ctx *gin.Context) *mongo.Client{\n    ip:=ctx.Param(\"ip\")\n    // 设置客户端连接配置\n    clientOption := options.Client().ApplyURI(\"mongodb://localhost:27017\")\n    // 连接 mongodb，获取连接对象\n    client, err := mongo.Connect(ctx, clientOption)\n    if err != nil {\n        fmt.Println(ip,\":连接mongo失败\",err)\n    }\n    fmt.Println(ip,\":连接mongo成功\")\n\n    return client\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"tcp连接"},"children":[{"type":"text","value":"tcp连接"}]},{"type":"element","tag":"h2","props":{"id":"思路"},"children":[{"type":"text","value":"思路"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用到可缓冲channel的阻塞机制，当channel为空时，读取channel会阻塞，当传入数据才能读取，解除阻塞。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"还有 context 控制 goroutine ，不过感觉有些多余。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用全局 map 保存 tcp 的连接状态，ip 对应一个控制该 ip 连接的 channel 。创建ip连接时会创建一个对应的 k/v 对"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"当传入一个请求时，程序调用连接函数运行一个 goroutine，该 goroutine 会根据请求的"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ip"}]},{"type":"text","value":"参数创建一个 tcp 连接，读取数据并写入数据库。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果继续向下执行就会取消 goroutine， 关闭连接，但我们使用读空channel的操作"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<-channel"}]},{"type":"text","value":"来阻塞，于是持续连接读取数据。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行取消函数时将向该ip对应的channel写入数据以解除阻塞，退出 goroutine。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"然后将该 ip/channel 对删除。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"能够准确控制 goroutine，也不会产生内存泄露，可喜可贺，可喜可贺。"}]}]},{"type":"element","tag":"h2","props":{"id":"核心代码"},"children":[{"type":"text","value":"核心代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义一个连接状态map"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"// key为ip地址，value为控制该 ip 连接阻塞的 channel\nvar MapIpChan=make(map[string]chan int)\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// key为ip地址，value为控制该 ip 连接阻塞的 channel\nvar MapIpChan=make(map[string]chan int)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"连接并读取数据"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"func NewConnect(ctx *gin.Context) {\n    // 根据请求的参数获取 ip\n    ip := ctx.Param(\"ip\")\n    // 创建一个数据库连接对象\n    dbclient:=model.InitDB(ctx)\n    // 需要操作的数据库的集合对象\n    collection:=dbclient.Database(\"msg\").Collection(ip)\n    // 有缓冲的 channel，阻塞该ip的cancel()，当 disconnect执行时，取消阻塞，使cancel()执行\n    cancelChan := make(chan int, 1)\n    model.MapIpChan[ip] = cancelChan\n    // 可取消的 context，使用cancel()取消，依赖于该context的 goroutine也会停止\n    ctxConn, cancel := context.WithCancel(ctx)\n    // 启动一个goroutine，建立tcp连接，获取传来的数据\n    go func(ip string) {\n        fmt.Println(\"准备连接ip:\",ip)\n        // GetConnect(ip1)\n        conn, err := net.Dial(\"tcp\", ip)\n        if err != nil {\n            fmt.Println(\"连接失败:\", err)\n            // 退出\n            return\n        }\n        buf := make([]byte, 1024)\n        for {\n            select {\n            case <-ctxConn.Done():\n                // cancel()执行时关闭设备连接，关闭数据库连接，退出该 goroutine\n                conn.Close()\n                fmt.Printf(\"-----关闭设备%v的tcp连接-----\\n\",ip)\n                dbclient.Disconnect(ctx)\n                fmt.Printf(\"+++++关闭操作数据库%v的连接+++++\\n\",ip)\n                fmt.Printf(\"*****退出连接%v的协程*****\\n\",ip)\n                return\n            default:\n                fmt.Println(\"连接后准备读取数据\")\n                n, err := conn.Read(buf)\n                if err != nil {\n                    fmt.Println(\"已连接，读取错误\")\n                }\n                // 编码转换,在utils包下创建转码函数，然后调用\n                data:=utils.Transcode(buf[:n])\n                fmt.Printf(\"%s: %s\\n\", ip, data)\n                // 数据对象             \n                msg:=model.Msg{\n                    Time: time.Now().String(),\n                    Ip: ip,\n                    Data: data,\n                }\n                // 插入数据\n                insertResult,err:=collection.InsertOne(ctx,msg)\n                if err != nil {\n                    fmt.Println(\"插入数据失败\")\n                }\n                fmt.Println(msg.Data,\"插入数据成功:\",insertResult.InsertedID)\n            }\n        }\n    }(ip)\n    // 从该ip对应的 channel接收数据，由于初始为空则阻塞，\n    // 当 disconnect函数执行时向 channel写入数据，解除阻塞，向下执行\n    <-cancelChan\n    // 删除该 ip/channel 对\n    delete(model.MapIpChan, ip)\n    fmt.Printf(\"准备取消任务:%v\\n\", ip)\n    cancel()\n    ctx.JSON(200, gin.H{\n        \"message\": \"已关闭连接\",\n    })\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"func NewConnect(ctx *gin.Context) {\n    // 根据请求的参数获取 ip\n    ip := ctx.Param(\"ip\")\n    // 创建一个数据库连接对象\n    dbclient:=model.InitDB(ctx)\n    // 需要操作的数据库的集合对象\n    collection:=dbclient.Database(\"msg\").Collection(ip)\n    // 有缓冲的 channel，阻塞该ip的cancel()，当 disconnect执行时，取消阻塞，使cancel()执行\n    cancelChan := make(chan int, 1)\n    model.MapIpChan[ip] = cancelChan\n    // 可取消的 context，使用cancel()取消，依赖于该context的 goroutine也会停止\n    ctxConn, cancel := context.WithCancel(ctx)\n    // 启动一个goroutine，建立tcp连接，获取传来的数据\n    go func(ip string) {\n        fmt.Println(\"准备连接ip:\",ip)\n        // GetConnect(ip1)\n        conn, err := net.Dial(\"tcp\", ip)\n        if err != nil {\n            fmt.Println(\"连接失败:\", err)\n            // 退出\n            return\n        }\n        buf := make([]byte, 1024)\n        for {\n            select {\n            case <-ctxConn.Done():\n                // cancel()执行时关闭设备连接，关闭数据库连接，退出该 goroutine\n                conn.Close()\n                fmt.Printf(\"-----关闭设备%v的tcp连接-----\\n\",ip)\n                dbclient.Disconnect(ctx)\n                fmt.Printf(\"+++++关闭操作数据库%v的连接+++++\\n\",ip)\n                fmt.Printf(\"*****退出连接%v的协程*****\\n\",ip)\n                return\n            default:\n                fmt.Println(\"连接后准备读取数据\")\n                n, err := conn.Read(buf)\n                if err != nil {\n                    fmt.Println(\"已连接，读取错误\")\n                }\n                // 编码转换,在utils包下创建转码函数，然后调用\n                data:=utils.Transcode(buf[:n])\n                fmt.Printf(\"%s: %s\\n\", ip, data)\n                // 数据对象             \n                msg:=model.Msg{\n                    Time: time.Now().String(),\n                    Ip: ip,\n                    Data: data,\n                }\n                // 插入数据\n                insertResult,err:=collection.InsertOne(ctx,msg)\n                if err != nil {\n                    fmt.Println(\"插入数据失败\")\n                }\n                fmt.Println(msg.Data,\"插入数据成功:\",insertResult.InsertedID)\n            }\n        }\n    }(ip)\n    // 从该ip对应的 channel接收数据，由于初始为空则阻塞，\n    // 当 disconnect函数执行时向 channel写入数据，解除阻塞，向下执行\n    <-cancelChan\n    // 删除该 ip/channel 对\n    delete(model.MapIpChan, ip)\n    fmt.Printf(\"准备取消任务:%v\\n\", ip)\n    cancel()\n    ctx.JSON(200, gin.H{\n        \"message\": \"已关闭连接\",\n    })\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"取消连接"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"func Disconnect(ctx *gin.Context) {\n    // 根据请求的参数获取 ip\n    ip := ctx.Param(\"ip\")\n    // 在执行 NewConnect() 时会根据 ip 创建键值对，启动 goroutine 建立连接后，NewConnect()被阻塞\n    // NewConnect() 等待 Disconnect() 取消阻塞后关闭其启动的 goroutine，退出\n    // 判断 ip 是否在 map 中，即是否处于连接状态\n    if _, isOk := model.MapIpChan[ip]; isOk {\n        // channel为空时接收会导致阻塞，向channel发送数据使其不为空则取消阻塞\n        model.MapIpChan[ip] <- 1\n    } else {\n        fmt.Println(\"ip未连接\")\n    }\n    fmt.Println(\"解除阻塞\")\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"func Disconnect(ctx *gin.Context) {\n    // 根据请求的参数获取 ip\n    ip := ctx.Param(\"ip\")\n    // 在执行 NewConnect() 时会根据 ip 创建键值对，启动 goroutine 建立连接后，NewConnect()被阻塞\n    // NewConnect() 等待 Disconnect() 取消阻塞后关闭其启动的 goroutine，退出\n    // 判断 ip 是否在 map 中，即是否处于连接状态\n    if _, isOk := model.MapIpChan[ip]; isOk {\n        // channel为空时接收会导致阻塞，向channel发送数据使其不为空则取消阻塞\n        model.MapIpChan[ip] <- 1\n    } else {\n        fmt.Println(\"ip未连接\")\n    }\n    fmt.Println(\"解除阻塞\")\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个for-select条件判断是关键，当channel为空时，无法读取，case条件不满足，所以运行default的functionB();"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"向channel发送数据后，channel可以读取，case条件满足，运行functionA()"}]},{"type":"element","tag":"pre","props":{"className":["language-go"],"code":"for{\n    select {\n        case:<-channel\n            functionA()\n        default:\n            functionB()\n    }\n}\n","language":"go","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"for{\n    select {\n        case:<-channel\n            functionA()\n        default:\n            functionB()\n    }\n}\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[{"id":"mongodb","depth":2,"text":"mongodb"},{"id":"gin","depth":2,"text":"Gin"},{"id":"mongo-driver","depth":2,"text":"mongo-driver"},{"id":"思路","depth":2,"text":"思路"},{"id":"核心代码","depth":2,"text":"核心代码"}]}},"_type":"markdown","_id":"content:essay:16.go的多线程-实时采集机器数据.md","_source":"content","_file":"essay/16.go的多线程-实时采集机器数据.md","_stem":"essay/16.go的多线程-实时采集机器数据","_extension":"md"}