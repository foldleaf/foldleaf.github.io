{"_path":"/essay/30.rust基本语法","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"rust基本语法","description":"不可变变量:在变量赋值或对象创建结束之后就不能再改变它的值或状态的变量\n可变变量:同理，在变量赋值或对象创建结束之后就可以再改变它的值或状态的变量","subtitle":"The basic grammar of Rust","index":30,"date":"2023-04-08","lunar_date":"闰二十八","year":"2023","month":"04","month_en":"Apr","day":"08","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/030.jpg","categories":"rust","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"变量绑定"},"children":[{"type":"text","value":"变量绑定"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不可变变量:在变量赋值或对象创建结束之后就不能再改变它的值或状态的变量\n可变变量:同理，在变量赋值或对象创建结束之后就可以再改变它的值或状态的变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在rust中使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"let"}]},{"type":"text","value":"关键字声明变量绑定\n在rust中默认的都是不可变的，即不可以使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"变量=值"}]},{"type":"text","value":"的方式修改绑定的值，如需修改则通过shadowing(掩盖/重影/隐藏)创建一个新的不可变变量绑定\n变量如果需要可变需要使用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"mut"}]},{"type":"text","value":"修饰，可以直接修改绑定的值"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 1;      // 创建一个不可变变量，将 1 与变量绑定\nx = 2;          // 错误，不能修改不可变变量绑定的值\nlet x = 2;      // 正确，通过shadowing创建一个新的不可变绑定\nlet mut y = 1;  // 创建一个可变变量，将 1 与变量绑定\ny = 2;          // 正确，可以修改可变变量\nlet z: i16 = 3  // 显式声明，指定类型，默认的隐式声明会自动推断类型\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 1;      // 创建一个不可变变量，将 1 与变量绑定\nx = 2;          // 错误，不能修改不可变变量绑定的值\nlet x = 2;      // 正确，通过shadowing创建一个新的不可变绑定\nlet mut y = 1;  // 创建一个可变变量，将 1 与变量绑定\ny = 2;          // 正确，可以修改可变变量\nlet z: i16 = 3  // 显式声明，指定类型，默认的隐式声明会自动推断类型\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"rust的报错信息"}]},{"type":"element","tag":"pre","props":{"className":["language-bash"],"code":" --> main.rs:3:5\n  |\n2 |     let x=1;\n  |         -\n  |         |\n  |         first assignment to `x`\n  |         help: consider making this binding mutable: `mut x`\n3 |     x=2;\n  |     ^^^ cannot assign twice to immutable variable\n","language":"bash","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" --> main.rs:3:5\n  |\n2 |     let x=1;\n  |         -\n  |         |\n  |         first assignment to `x`\n  |         help: consider making this binding mutable: `mut x`\n3 |     x=2;\n  |     ^^^ cannot assign twice to immutable variable\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"你会看到cannot assign twice to immutable variable（不能对不可变变量 x 二次赋值）"}]},{"type":"element","tag":"h1","props":{"id":"shadowing隐藏掩盖重影"},"children":[{"type":"text","value":"shadowing(隐藏/掩盖/重影)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面提到不可变变量不能二次赋值，但可以使用shadowing，将原变量“shadowing(隐藏)”\nshadowing是使用同名的新变量隐藏掉了原变量，直到新变量也被隐藏或者其作用域结束为止，使用该变量名的行为都视为使用这个新变量。\n可以多次隐藏。"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn main() {\n    let x = 5;// x=5\n\n    let x = x + 1;// x=6\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n        // x=12\n        // x=12的作用域结束\n    }\n\n    println!(\"The value of x is: {x}\");\n    // x=6\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn main() {\n    let x = 5;// x=5\n\n    let x = x + 1;// x=6\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n        // x=12\n        // x=12的作用域结束\n    }\n\n    println!(\"The value of x is: {x}\");\n    // x=6\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"常量"},"children":[{"type":"text","value":"常量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值\n可以出现在任何作用域（包括全局作用域）"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"const PI: f64 = 3.14159;\nconst MAGIC: i32 = 42;\nconst A: i32 =x*y;//错误， x*y是运行时才能确定\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"const PI: f64 = 3.14159;\nconst MAGIC: i32 = 42;\nconst A: i32 =x*y;//错误， x*y是运行时才能确定\n"}]}]},{"type":"element","tag":"h1","props":{"id":"数据类型"},"children":[{"type":"text","value":"数据类型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"数值类型：分为整型与浮点型"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"i8、i16、i32、i64、i128、isize"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"u8、u16、u32、u64、u128、usize"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"f32、f64"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其中 isize 和 usize 是指针大小的整数，因此它们的大小与机器架构相关。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"字面值 (literals) 写为 10i8、10u16、10.0f32、10usize 等。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"字面值如果不指定类型，则默认整数为 i32，浮点数为 f64。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"布尔类型(bool)：true/false\n字符类型：用单引号"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"''"}]},{"type":"text","value":"包裹，unicode编码\n复合类型：数组 (array)、切片 (slice)、字符串 (string)、元组 (tuple)\n函数：函数也是一种类型"}]},{"type":"element","tag":"h2","props":{"id":"数组"},"children":[{"type":"text","value":"数组"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"[T;N]"}]},{"type":"text","value":",T为元素类型，N为元素个数"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"N 是编译时常数 (compile-time constant)，也就是说数组的长度是固定的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"运行时 (runtime) 访问数组元素会检查是否越界。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let arr1 = [1, 2, 3]; // 3个元素的数组\nlet arr2 = [2; 3];  // 3个元素的数组，元素都是 2\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let arr1 = [1, 2, 3]; // 3个元素的数组\nlet arr2 = [2; 3];  // 3个元素的数组，元素都是 2\n"}]}]},{"type":"element","tag":"h2","props":{"id":"切片"},"children":[{"type":"text","value":"切片"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"切片类型的形式为 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&[T]"}]},{"type":"text","value":"，例如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&[i32]"}]},{"type":"text","value":"\n切片可以是可变的，也可以是不可变的。\n切片不能直接创建，需要从别的变量借用 (borrow),这里暂时直接用go的切片来理解"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let arr = [0, 1, 2, 3, 4, 5];\nlet total_slice = &arr; // 数组arr的切片\nlet total_slice = &arr[..]; // 与上面的效果一样\nlet partial_slice = &arr[2..5]; // 索引2到4的的元素：[2, 3, 4]\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let arr = [0, 1, 2, 3, 4, 5];\nlet total_slice = &arr; // 数组arr的切片\nlet total_slice = &arr[..]; // 与上面的效果一样\nlet partial_slice = &arr[2..5]; // 索引2到4的的元素：[2, 3, 4]\n"}]}]},{"type":"element","tag":"h2","props":{"id":"字符串"},"children":[{"type":"text","value":"字符串"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"String"}]},{"type":"text","value":" 是在堆上分配空间、可以增长的字符序列。\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&str"}]},{"type":"text","value":" 是 String 的切片类型\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"str"}]},{"type":"text","value":" 是没有大小的类型，编译时不知道大小，因此无法独立存在"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let s: &str = \"galaxy\";\nlet s2: String = \"galaxy\".to_string();\nlet s3: String = String::from(\"galaxy\");\nlet s4: &str = &s3;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let s: &str = \"galaxy\";\nlet s2: String = \"galaxy\".to_string();\nlet s3: String = String::from(\"galaxy\");\nlet s4: &str = &s3;\n"}]}]},{"type":"element","tag":"h2","props":{"id":"元组"},"children":[{"type":"text","value":"元组"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"元组是固定大小的、有序的、异构的列表类型。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可以通过下标来访问元组的分量，例如 foo.0。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"可以使用 let 绑定来解构。"}]}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let foo: (i32, char, f64) = (72, 'H', 5.1);\nlet (x, y, z) = (72, 'H', 5.1);\nlet (a, b, c) = foo; // a = 72, b = 'H', c = 5.1\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let foo: (i32, char, f64) = (72, 'H', 5.1);\nlet (x, y, z) = (72, 'H', 5.1);\nlet (a, b, c) = foo; // a = 72, b = 'H', c = 5.1\n"}]}]},{"type":"element","tag":"h2","props":{"id":"向量"},"children":[{"type":"text","value":"向量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vec"}]},{"type":"text","value":"是分配在堆上的、可增长的数组\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"<T>"}]},{"type":"text","value":" 表示泛型，使用时代入实际的类型\n使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Vec::new()"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vec!"}]},{"type":"text","value":" 宏来创建 Vec"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"// Explicit typing\nlet v0: Vec<i32> = Vec::new();\n// v1 and v2 are equal\nlet mut v1 = Vec::new();\nv1.push(1);\nv1.push(2);\nv1.push(3);\nlet v2 = vec![1, 2, 3];\n// v3 and v4 are equal\nlet v3 = vec![0; 4];\nlet v4 = vec![0, 0, 0, 0];\n\nlet v2 = vec![1, 2, 3];\nlet x = v2[2]; // 3\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Explicit typing\nlet v0: Vec<i32> = Vec::new();\n// v1 and v2 are equal\nlet mut v1 = Vec::new();\nv1.push(1);\nv1.push(2);\nv1.push(3);\nlet v2 = vec![1, 2, 3];\n// v3 and v4 are equal\nlet v3 = vec![0; 4];\nlet v4 = vec![0, 0, 0, 0];\n\nlet v2 = vec![1, 2, 3];\nlet x = v2[2]; // 3\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"向量可以像数组一样使用 "},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":" 来访问元素。\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 Rust 中不能用 i32/i64 等类型的值作为下标访问元素。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"必须使用 usize 类型的值，因为 usize 保证和指针是一样长度的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"其他类型要显式转换成 usize：\nlet i: i8 = 2;\nlet y = v2"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"i as usize"}]},{"type":"text","value":";"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"类型转换"},"children":[{"type":"text","value":"类型转换"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x: i32 = 100;\nlet y: u32 = x as u32;\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x: i32 = 100;\nlet y: u32 = x as u32;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一般来说，只能在可以安全转换的类型之间进行转换操作\n例如，"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"u8; 4"}]},{"type":"text","value":" 不能转换为 char 类型"}]},{"type":"element","tag":"h1","props":{"id":"引用"},"children":[{"type":"text","value":"引用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&"}]},{"type":"text","value":" 取引用\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 解引用\n与 c++ 一样，在 Rust 中，引用保证是合法的"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 12;\nlet ref_x = &x;\nprintln!(\"{}\", *ref_x); // 12\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 12;\nlet ref_x = &x;\nprintln!(\"{}\", *ref_x); // 12\n"}]}]},{"type":"element","tag":"h1","props":{"id":"语句"},"children":[{"type":"text","value":"语句"}]},{"type":"element","tag":"h2","props":{"id":"if-else-条件语句"},"children":[{"type":"text","value":"if-else 条件语句"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 1;\nif x > 0 {\n    println!(\"1\")\n} else {\n    println!(\"0\")\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 1;\nif x > 0 {\n    println!(\"1\")\n} else {\n    println!(\"0\")\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"while-循环"},"children":[{"type":"text","value":"while 循环"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let mut x = 0;\nwhile x < 100 {\n    x += 1;\n    println!(\"x: {}\", x);\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let mut x = 0;\nwhile x < 100 {\n    x += 1;\n    println!(\"x: {}\", x);\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"loop-循环"},"children":[{"type":"text","value":"loop 循环"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无限循环，相当于while true和for(;;),直到遇到break语句或程序终止\nloop 循环中的 break 语句可以返回一个值，作为整个循环的求值结果（另外两种循环没\n有这个功能）"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let mut x = 0;\n    let y = loop {\n        x += 1;\n        if x * x >= 100 {\n            break x;\n        }\n    };\n    print!(\"{},{}\",x,y)//10,10\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let mut x = 0;\n    let y = loop {\n        x += 1;\n        if x * x >= 100 {\n            break x;\n        }\n    };\n    print!(\"{},{}\",x,y)//10,10\n"}]}]},{"type":"element","tag":"h2","props":{"id":"for-循环"},"children":[{"type":"text","value":"for 循环"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"\nfor x in 0..10 {\n    println!(\"{}\", x);\n    //输出0到9\n}\n\nlet xs = [0, 1, 2, 3, 4];\nfor x in &xs {\n    println!(\"{}\", x);\n    // 循环输出数组的元素值\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nfor x in 0..10 {\n    println!(\"{}\", x);\n    //输出0到9\n}\n\nlet xs = [0, 1, 2, 3, 4];\nfor x in &xs {\n    println!(\"{}\", x);\n    // 循环输出数组的元素值\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"match-匹配语句"},"children":[{"type":"text","value":"match 匹配语句"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类似于switch语句"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 3;\n// 匹配 x 的值\nmatch x {   \n    // 匹配到 1\n    1 => println!(\"one fish\"), \n    // 匹配到 2\n    2 => {  \n        println!(\"two fish\");\n        println!(\"two fish\");\n    } \n    // 其他情况使用下划线 `_`\n    _ => println!(\"no fish for you\"), \n}\n//  no fish for you\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 3;\n// 匹配 x 的值\nmatch x {   \n    // 匹配到 1\n    1 => println!(\"one fish\"), \n    // 匹配到 2\n    2 => {  \n        println!(\"two fish\");\n        println!(\"two fish\");\n    } \n    // 其他情况使用下划线 `_`\n    _ => println!(\"no fish for you\"), \n}\n//  no fish for you\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以匹配任意表达式"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = 3;\nlet y = -3;\nmatch (x, y) {\n    (1, 1) => println!(\"one\"),\n    (2, j) => println!(\"two, {}\", j),\n    (_, 3) => println!(\"three\"),\n    (i, j) if i > 5 && j < 0 => println!(\"On guard!\"),\n    (_, _) => println!(\":<\"),\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = 3;\nlet y = -3;\nmatch (x, y) {\n    (1, 1) => println!(\"one\"),\n    (2, j) => println!(\"two, {}\", j),\n    (_, 3) => println!(\"three\"),\n    (i, j) if i > 5 && j < 0 => println!(\"On guard!\"),\n    (_, _) => println!(\":<\"),\n}\n"}]}]},{"type":"element","tag":"h1","props":{"id":"模式"},"children":[{"type":"text","value":"模式"}]},{"type":"element","tag":"h1","props":{"id":"函数"},"children":[{"type":"text","value":"函数"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn 函数名称(参数列表(参数名:参数类型,...))-> 返回值类型{\n    //函数体\n}\n\nfn foo(x: T, y: U, z: V) -> T {\n// ...\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn 函数名称(参数列表(参数名:参数类型,...))-> 返回值类型{\n    //函数体\n}\n\nfn foo(x: T, y: U, z: V) -> T {\n// ...\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Rust 必须显式定义函数的参数和返回值的类型。\n实际上编译器是可以推断函数的参数和返回值的类型的，但是 Rust 的设计者认为显式指定是\n一种更好的实践。"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"fn add(x: i32, y: i32) -> i32 {\n    x + y // 不带分号，返回x+y的值\n}\n\nfn sub(x: i32, y: i32) -> i32 {\n    x - y; // 带分号，没有返回值，编译错误\n}\n\nfn mul(x: i32, y: i32) -> i32 {\n    return x * y; // 使用return关键字，可以加分号\n}\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fn add(x: i32, y: i32) -> i32 {\n    x + y // 不带分号，返回x+y的值\n}\n\nfn sub(x: i32, y: i32) -> i32 {\n    x - y; // 带分号，没有返回值，编译错误\n}\n\nfn mul(x: i32, y: i32) -> i32 {\n    return x * y; // 使用return关键字，可以加分号\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为Rust的函数也是表达式，它们的返回值是由函数体最后一个表达式的值决定的。如果最后一个表达式后面加了分号，那么它就变成了一个语句，而语句没有值，所以函数就没有返回值了。"}]},{"type":"element","tag":"h1","props":{"id":"宏"},"children":[{"type":"text","value":"宏"}]},{"type":"element","tag":"h1","props":{"id":"print-和-println"},"children":[{"type":"text","value":"print! 和 println!"}]},{"type":"element","tag":"pre","props":{"className":["language-rust"],"code":"let x = \"foo\";\nprint!(\"{}, {}, {}\", x, 3, true);\n// => foo, 3, true\nprintln!(\"{:?}, {:?}\", x, [1, 2, 3]);\n// => \"foo\", [1, 2, 3]\nlet y = 1;\nprintln!(\"{0}, {y}, {0}\", x);\n// => foo, 1, foo\n","language":"rust","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"let x = \"foo\";\nprint!(\"{}, {}, {}\", x, 3, true);\n// => foo, 3, true\nprintln!(\"{:?}, {:?}\", x, [1, 2, 3]);\n// => \"foo\", [1, 2, 3]\nlet y = 1;\nprintln!(\"{0}, {y}, {0}\", x);\n// => foo, 1, foo\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":" 来做字符串插入，"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{:?}"}]},{"type":"text","value":" 做调试输出。\n有些类型，例如数组和向量，只能用调试输出的方式来打印\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":" 里可以加数字，表示第几个参数，新版本还可以把变量名写在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":" 里"}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[{"id":"数组","depth":2,"text":"数组"},{"id":"切片","depth":2,"text":"切片"},{"id":"字符串","depth":2,"text":"字符串"},{"id":"元组","depth":2,"text":"元组"},{"id":"向量","depth":2,"text":"向量"},{"id":"类型转换","depth":2,"text":"类型转换"},{"id":"if-else-条件语句","depth":2,"text":"if-else 条件语句"},{"id":"while-循环","depth":2,"text":"while 循环"},{"id":"loop-循环","depth":2,"text":"loop 循环"},{"id":"for-循环","depth":2,"text":"for 循环"},{"id":"match-匹配语句","depth":2,"text":"match 匹配语句"}]}},"_type":"markdown","_id":"content:essay:30.rust基本语法.md","_source":"content","_file":"essay/30.rust基本语法.md","_stem":"essay/30.rust基本语法","_extension":"md"}