{"_path":"/essay/27.pytorch神经网络训练","_dir":"essay","_draft":false,"_partial":false,"_locale":"","title":"pytorch神经网络训练","description":"学自李宏毅老师","subtitle":"pytorch neural network training","index":27,"date":"2023-03-28","lunar_date":"闰二初七","year":"2023","month":"03","month_en":"Mar","day":"28","tag":"技术","tag_en":"TECH","cover":"/img/rabbit/027.jpg","categories":"python","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"学自李宏毅老师"}]},{"type":"element","tag":"h1","props":{"id":"神经网络训练设置"},"children":[{"type":"text","value":"神经网络训练设置"}]},{"type":"element","tag":"pre","props":{"className":["language-py"],"code":"# 从数据集中读取数据\ndataset = MyDataset(file)\n# 将数据放到数据加载器，分批\ntr_set = DataLoader(dataset, 16, shuffle=True)\n# 构造模型并指定设备(cpu/cuda(gpu))\nmodel = MyModel().to(device)\n# 设置损失函数\ncriterion = nn.MSELoss()\n# 设置优化器\noptimizer = torch.optim.SGD(model.parameters(), 0.1)\n\n","language":"py","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 从数据集中读取数据\ndataset = MyDataset(file)\n# 将数据放到数据加载器，分批\ntr_set = DataLoader(dataset, 16, shuffle=True)\n# 构造模型并指定设备(cpu/cuda(gpu))\nmodel = MyModel().to(device)\n# 设置损失函数\ncriterion = nn.MSELoss()\n# 设置优化器\noptimizer = torch.optim.SGD(model.parameters(), 0.1)\n\n"}]}]},{"type":"element","tag":"h1","props":{"id":"神经网络训练回路"},"children":[{"type":"text","value":"神经网络训练回路"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"感觉这里用回路比循环好听一点"}]},{"type":"element","tag":"pre","props":{"className":["language-py"],"code":"# 迭代 n_epochs\nfor epoch in range(n_epochs):\n    # 将模型设置为训练模式\n    model.train()\n    # 通过数据加载器迭代\n    for x, y in tr_set:\n        # 梯度置为 0\n        optimizer.zero_grad()\n        # cpu/cuda\n        x, y = x.to(device), y.to(device)\n        # 正向传播（计算输出）\n        pred = model(x)\n        # 计算损失\n        loss = criterion(pred, y)\n        # 反向传播（计算梯度）\n        loss.backward()\n        # 使用优化器更新模型\n        optimizer.step()\n","language":"py","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 迭代 n_epochs\nfor epoch in range(n_epochs):\n    # 将模型设置为训练模式\n    model.train()\n    # 通过数据加载器迭代\n    for x, y in tr_set:\n        # 梯度置为 0\n        optimizer.zero_grad()\n        # cpu/cuda\n        x, y = x.to(device), y.to(device)\n        # 正向传播（计算输出）\n        pred = model(x)\n        # 计算损失\n        loss = criterion(pred, y)\n        # 反向传播（计算梯度）\n        loss.backward()\n        # 使用优化器更新模型\n        optimizer.step()\n"}]}]},{"type":"element","tag":"h1","props":{"id":"神经网络验证回路"},"children":[{"type":"text","value":"神经网络验证回路"}]},{"type":"element","tag":"pre","props":{"className":["language-py"],"code":"# 将模型设置为评估模式\nmodel.eval()\ntotal_loss = 0\n# 通过数据加载器迭代\nfor x, y in dv_set:\n    # cpu/cuda(gpu)\n    x, y = x.to(device), y.to(device)\n    # 禁用梯度计算\n    with torch.no_grad():\n        # 前向传播（计算输出）\n        pred = model(x)\n        # 计算损失\n        loss = criterion(pred, y)\n    # 累积损失\n    total_loss += loss.cpu().item() * len(x)\n    # 计算平均损失\n    avg_loss = total_loss / len(dv_set.dataset)\n","language":"py","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 将模型设置为评估模式\nmodel.eval()\ntotal_loss = 0\n# 通过数据加载器迭代\nfor x, y in dv_set:\n    # cpu/cuda(gpu)\n    x, y = x.to(device), y.to(device)\n    # 禁用梯度计算\n    with torch.no_grad():\n        # 前向传播（计算输出）\n        pred = model(x)\n        # 计算损失\n        loss = criterion(pred, y)\n    # 累积损失\n    total_loss += loss.cpu().item() * len(x)\n    # 计算平均损失\n    avg_loss = total_loss / len(dv_set.dataset)\n"}]}]},{"type":"element","tag":"h1","props":{"id":"神经网络测试回路"},"children":[{"type":"text","value":"神经网络测试回路"}]},{"type":"element","tag":"pre","props":{"className":["language-py"],"code":"# # 将模型设置为评估模式\nmodel.eval()\npreds = []\nfor x in tt_set:\n    x = x.to(device)\n    with torch.no_grad():\n        pred = model(x)\n        # 收集预测结果\n        preds.append(pred.cpu())\n","language":"py","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# # 将模型设置为评估模式\nmodel.eval()\npreds = []\nfor x in tt_set:\n    x = x.to(device)\n    with torch.no_grad():\n        pred = model(x)\n        # 收集预测结果\n        preds.append(pred.cpu())\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":3,"links":[]}},"_type":"markdown","_id":"content:essay:27.pytorch神经网络训练.md","_source":"content","_file":"essay/27.pytorch神经网络训练.md","_stem":"essay/27.pytorch神经网络训练","_extension":"md"}