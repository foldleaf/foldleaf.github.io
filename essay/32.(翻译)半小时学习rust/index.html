<!DOCTYPE html><html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="importmap">{"imports":{"#entry":"/_nuxt/CwmBq-Is.js"}}</script>
<title>（翻译）半小时学习rust</title>
<style>*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::-ms-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;-webkit-box-sizing:border-box;box-sizing:border-box}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;-webkit-font-feature-settings:normal;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}hr{border-top-width:.0625rem;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;-webkit-font-feature-settings:normal;font-feature-settings:normal;font-size:1em;font-variation-settings:normal}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;-webkit-font-feature-settings:inherit;font-feature-settings:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-.125rem}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#9ca3af;opacity:1}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#9ca3af;opacity:1}input::-ms-input-placeholder,textarea::-ms-input-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]:where(:not([hidden=until-found])){display:none}h1{text-decoration:none}.prose{color:var(--tw-prose-body);max-width:65ch}.prose :where(p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em;margin-top:1.25em}.prose :where([class~=lead]):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-lead);font-size:1.25em;line-height:1.6;margin-bottom:1.2em;margin-top:1.2em}.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-links);font-weight:500;text-decoration:underline}.prose :where(strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-bold);font-weight:600}.prose :where(a strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(ol):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal;margin-bottom:1.25em;margin-top:1.25em;-webkit-padding-start:1.625em;padding-inline-start:1.625em}.prose :where(ol[type=A]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=A s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=I]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type=I s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type="1"]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal}.prose :where(ul):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:disc;margin-bottom:1.25em;margin-top:1.25em;-webkit-padding-start:1.625em;padding-inline-start:1.625em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{color:var(--tw-prose-counters);font-weight:400}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{color:var(--tw-prose-bullets)}.prose :where(dt):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;margin-top:1.25em}.prose :where(hr):not(:where([class~=not-prose],[class~=not-prose] *)){border-color:var(--tw-prose-hr);border-top-width:.0625rem;margin-bottom:3em;margin-top:3em}.prose :where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *)){border-inline-start-color:var(--tw-prose-quote-borders);border-inline-start-width:.25rem;color:var(--tw-prose-quotes);font-style:italic;font-weight:500;margin-bottom:1.6em;margin-top:1.6em;quotes:"“""”""‘""’";-webkit-padding-start:1em;padding-inline-start:1em}.prose :where(blockquote p:last-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:close-quote}.prose :where(h1):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:2.25em;font-weight:800;line-height:1.1111111;margin-bottom:.8888889em;margin-top:0}.prose :where(h1 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:900}.prose :where(h2):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:1.5em;font-weight:700;line-height:1.3333333;margin-bottom:1em;margin-top:2em}.prose :where(h2 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:800}.prose :where(h3):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:1.25em;font-weight:600;line-height:1.6;margin-bottom:.6em;margin-top:1.6em}.prose :where(h3 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:700}.prose :where(h4):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;line-height:1.5;margin-bottom:.5em;margin-top:1.5em}.prose :where(h4 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:700}.prose :where(img):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:2em;margin-top:2em}.prose :where(picture):not(:where([class~=not-prose],[class~=not-prose] *)){display:block;margin-bottom:2em;margin-top:2em}.prose :where(video):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:2em;margin-top:2em}.prose :where(kbd):not(:where([class~=not-prose],[class~=not-prose] *)){border-radius:.3125rem;-webkit-box-shadow:0 0 0 .0625rem rgb(var(--tw-prose-kbd-shadows)/10%),0 .1875rem 0 rgb(var(--tw-prose-kbd-shadows)/10%);box-shadow:0 0 0 .0625rem rgb(var(--tw-prose-kbd-shadows)/10%),0 .1875rem rgb(var(--tw-prose-kbd-shadows)/10%);color:var(--tw-prose-kbd);font-family:inherit;font-size:.875em;font-weight:500;padding-top:.1875em;-webkit-padding-end:.375em;padding-inline-end:.375em;padding-bottom:.1875em;-webkit-padding-start:.375em;padding-inline-start:.375em}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-code);font-size:.875em;font-weight:600}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:"`"}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:"`"}.prose :where(a code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h1 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h2 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.875em}.prose :where(h3 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.9em}.prose :where(h4 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(pre):not(:where([class~=not-prose],[class~=not-prose] *)){background-color:var(--tw-prose-pre-bg);border-radius:.375rem;color:var(--tw-prose-pre-code);font-size:.875em;font-weight:400;line-height:1.7142857;margin-bottom:1.7142857em;margin-top:1.7142857em;overflow-x:auto;padding-top:.8571429em;-webkit-padding-end:1.1428571em;padding-inline-end:1.1428571em;padding-bottom:.8571429em;-webkit-padding-start:1.1428571em;padding-inline-start:1.1428571em}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)){background-color:transparent;border-radius:0;border-width:0;color:inherit;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;padding:0}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:none}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:none}.prose :where(table):not(:where([class~=not-prose],[class~=not-prose] *)){font-size:.875em;line-height:1.7142857;margin-bottom:2em;margin-top:2em;table-layout:auto;width:100%}.prose :where(thead):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-color:var(--tw-prose-th-borders);border-bottom-width:.0625rem}.prose :where(thead th):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;vertical-align:bottom;-webkit-padding-end:.5714286em;padding-inline-end:.5714286em;padding-bottom:.5714286em;-webkit-padding-start:.5714286em;padding-inline-start:.5714286em}.prose :where(tbody tr):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-color:var(--tw-prose-td-borders);border-bottom-width:.0625rem}.prose :where(tbody tr:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-width:0}.prose :where(tbody td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:baseline}.prose :where(tfoot):not(:where([class~=not-prose],[class~=not-prose] *)){border-top-color:var(--tw-prose-th-borders);border-top-width:.0625rem}.prose :where(tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:top}.prose :where(th,td):not(:where([class~=not-prose],[class~=not-prose] *)){text-align:start}.prose :where(figure>*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0;margin-top:0}.prose :where(figcaption):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-captions);font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.prose{--tw-prose-body:#180d02;--tw-prose-headings:#69413c;--tw-prose-lead:#4b5563;--tw-prose-links:#64311e;--tw-prose-bold:#111827;--tw-prose-counters:#6b7280;--tw-prose-bullets:#d1d5db;--tw-prose-hr:#e5e7eb;--tw-prose-quotes:#111827;--tw-prose-quote-borders:#ed9a8d;--tw-prose-captions:#6b7280;--tw-prose-kbd:#111827;--tw-prose-kbd-shadows:17 24 39;--tw-prose-code:#111827;--tw-prose-pre-code:#e5e7eb;--tw-prose-th-borders:#d1d5db;--tw-prose-td-borders:#e5e7eb;--tw-prose-invert-body:#d1d5db;--tw-prose-invert-headings:#fff;--tw-prose-invert-lead:#9ca3af;--tw-prose-invert-links:#fff;--tw-prose-invert-bold:#fff;--tw-prose-invert-counters:#9ca3af;--tw-prose-invert-bullets:#4b5563;--tw-prose-invert-hr:#374151;--tw-prose-invert-quotes:#f3f4f6;--tw-prose-invert-quote-borders:#374151;--tw-prose-invert-captions:#9ca3af;--tw-prose-invert-kbd:#fff;--tw-prose-invert-kbd-shadows:255 255 255;--tw-prose-invert-code:#fff;--tw-prose-invert-pre-code:#d1d5db;--tw-prose-invert-pre-bg:rgba(0,0,0,.5);--tw-prose-invert-th-borders:#4b5563;--tw-prose-invert-td-borders:#374151;font-size:1rem;line-height:1.75}.prose :where(picture>img):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0;margin-top:0}.prose :where(li):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.5em;margin-top:.5em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-start:.375em;padding-inline-start:.375em}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-start:.375em;padding-inline-start:.375em}.prose :where(.prose>ul>li p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.75em;margin-top:.75em}.prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(ul ul,ul ol,ol ul,ol ol):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.75em;margin-top:.75em}.prose :where(dl):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em;margin-top:1.25em}.prose :where(dd):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.5em;-webkit-padding-start:1.625em;padding-inline-start:1.625em}.prose :where(hr+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h2+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h3+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h4+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(thead th:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-start:0;padding-inline-start:0}.prose :where(thead th:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-end:0;padding-inline-end:0}.prose :where(tbody td,tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){padding-top:.5714286em;-webkit-padding-end:.5714286em;padding-inline-end:.5714286em;padding-bottom:.5714286em;-webkit-padding-start:.5714286em;padding-inline-start:.5714286em}.prose :where(tbody td:first-child,tfoot td:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-start:0;padding-inline-start:0}.prose :where(tbody td:last-child,tfoot td:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){-webkit-padding-end:0;padding-inline-end:0}.prose :where(figure):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:2em;margin-top:2em}.prose :where(.prose>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(.prose>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.bottom-\[10px\]{bottom:.625rem}.bottom-\[30px\]{bottom:1.875rem}.left-0{left:0}.left-\[1158px\]{left:72.375rem}.left-\[15px\]{left:.9375rem}.left-\[171px\]{left:10.6875rem}.left-\[176px\]{left:11rem}.left-\[19px\]{left:1.1875rem}.left-\[21px\]{left:1.3125rem}.left-\[24px\]{left:1.5rem}.left-\[25px\]{left:1.5625rem}.left-\[326px\]{left:20.375rem}.left-\[331px\]{left:20.6875rem}.left-\[40px\]{left:2.5rem}.left-\[45px\]{left:2.8125rem}.left-\[481px\]{left:30.0625rem}.left-\[484px\]{left:30.25rem}.left-\[50\%\]{left:50%}.left-\[644px\]{left:40.25rem}.left-\[980px\]{left:61.25rem}.right-\[15px\]{right:.9375rem}.right-\[21px\]{right:1.3125rem}.right-\[25px\]{right:1.5625rem}.right-\[644px\]{right:40.25rem}.right-\[980px\]{right:61.25rem}.top-0{top:0}.top-\[100px\]{top:6.25rem}.top-\[10px\]{top:.625rem}.top-\[177px\]{top:11.0625rem}.top-\[25px\]{top:1.5625rem}.top-\[3\.06px\]{top:.19125rem}.top-\[30px\]{top:1.875rem}.top-\[33\.65px\]{top:2.103125rem}.top-\[34\.67px\]{top:2.166875rem}.top-\[34px\]{top:2.125rem}.top-\[40px\]{top:2.5rem}.top-\[45px\]{top:2.8125rem}.top-\[62\.20px\]{top:3.8875rem}.top-\[64\.24px\]{top:4.015rem}.top-\[97\.86px\]{top:6.11625rem}.-z-10{z-index:-10}.z-0{z-index:0}.z-10{z-index:10}.z-20{z-index:20}.col-span-1{grid-column:span 1/span 1}.col-span-4{grid-column:span 4/span 4}.col-start-2{grid-column-start:2}.col-start-8{grid-column-start:8}.m-0{margin:0}.mx-auto{margin-left:auto;margin-right:auto}.my-20{margin-bottom:5rem;margin-top:5rem}.mb-1{margin-bottom:.25rem}.mb-12{margin-bottom:3rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.mb-\[140px\]{margin-bottom:8.75rem}.mb-\[20px\]{margin-bottom:1.25rem}.mb-\[60px\]{margin-bottom:3.75rem}.mb-\[70px\]{margin-bottom:4.375rem}.ml-4{margin-left:1rem}.ml-\[40px\]{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mr-4{margin-right:1rem}.mr-7{margin-right:1.75rem}.mr-\[40px\]{margin-right:2.5rem}.mt-12{margin-top:3rem}.mt-20{margin-top:5rem}.mt-\[110px\]{margin-top:6.875rem}.mt-\[20px\]{margin-top:1.25rem}.mt-\[45px\]{margin-top:2.8125rem}.mt-\[8px\]{margin-top:.5rem}.line-clamp-1{-webkit-line-clamp:1}.line-clamp-1,.line-clamp-2{display:-webkit-box;overflow:hidden;-webkit-box-orient:vertical}.line-clamp-2{-webkit-line-clamp:2}.block{display:block}.flex{display:-webkit-box;display:-ms-flexbox;display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.aspect-\[4\/3\]{aspect-ratio:4/3}.aspect-square{aspect-ratio:1/1}.h-24{height:6rem}.h-36{height:9rem}.h-\[0px\]{height:0}.h-\[100px\]{height:6.25rem}.h-\[110\.12px\]{height:6.8825rem}.h-\[110px\]{height:6.875rem}.h-\[115\.22px\]{height:7.20125rem}.h-\[148\.86px\]{height:9.30375rem}.h-\[1920px\]{height:120rem}.h-\[240px\]{height:15rem}.h-\[2px\]{height:.125rem}.h-\[300px\]{height:18.75rem}.h-\[3px\]{height:.1875rem}.h-\[500px\]{height:31.25rem}.h-\[50px\]{height:3.125rem}.h-\[53\.02px\]{height:3.31375rem}.h-\[5px\]{height:.3125rem}.h-\[80px\]{height:5rem}.h-\[97\.88px\]{height:6.1175rem}.h-auto{height:auto}.h-full{height:100%}.min-h-screen{min-height:100vh}.w-1\/2{width:50%}.w-1\/4{width:25%}.w-12{width:3rem}.w-16{width:4rem}.w-24{width:6rem}.w-3\/4{width:75%}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-\[100px\]{width:6.25rem}.w-\[1080px\]{width:67.5rem}.w-\[108px\]{width:6.75rem}.w-\[110px\]{width:6.875rem}.w-\[160px\]{width:10rem}.w-\[1920px\]{width:120rem}.w-\[240px\]{width:15rem}.w-\[400px\]{width:25rem}.w-\[545px\]{width:34.0625rem}.w-\[55px\]{width:3.4375rem}.w-\[58\.08px\]{width:3.63rem}.w-\[58px\]{width:3.625rem}.w-\[60px\]{width:3.75rem}.w-\[700px\]{width:43.75rem}.w-\[80px\]{width:5rem}.w-\[95px\]{width:5.9375rem}.w-\[97px\]{width:6.0625rem}.w-auto{width:auto}.w-full{width:100%}.max-w-4xl{max-width:56rem}.max-w-\[900px\]{max-width:56.25rem}.origin-top-left{-webkit-transform-origin:top left;-ms-transform-origin:top left;transform-origin:top left}.translate-x-\[-50\%\]{--tw-translate-x:-50%}.-rotate-45,.translate-x-\[-50\%\]{-webkit-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));-ms-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-rotate-45{--tw-rotate:-45deg}.-rotate-90{--tw-rotate:-90deg}.-rotate-90,.rotate-180{-webkit-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));-ms-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-180{--tw-rotate:180deg}.transform{-webkit-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));-ms-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.resize{resize:both}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-12{grid-template-columns:repeat(12,minmax(0,1fr))}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-cols-6{grid-template-columns:repeat(6,minmax(0,1fr))}.flex-row{-webkit-box-orient:horizontal;-ms-flex-direction:row;flex-direction:row}.flex-col,.flex-row{-webkit-box-direction:normal}.flex-col{-webkit-box-orient:vertical;-ms-flex-direction:column;flex-direction:column}.items-start{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.items-center{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.justify-start{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start}.justify-center{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.justify-between{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.justify-items-center{justify-items:center}.gap-\[40px\]{gap:2.5rem}.space-x-5>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(1.25rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(1.25rem*var(--tw-space-x-reverse))}.space-y-8>:not([hidden])~:not([hidden]){--tw-space-y-reverse:0;margin-bottom:calc(2rem*var(--tw-space-y-reverse));margin-top:calc(2rem*(1 - var(--tw-space-y-reverse)))}.self-start{-ms-flex-item-align:start;align-self:flex-start}.self-center{-ms-flex-item-align:center;align-self:center}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.text-nowrap{text-wrap:nowrap}.break-all{word-break:break-all}.rounded-\[54px\]{border-radius:3.375rem}.rounded-full{border-radius:624.9375rem}.rounded-lg{border-radius:.5rem}.border{border-width:.0625rem}.border-2{border-width:.125rem}.border-4{border-width:.25rem}.border-\[2px\]{border-width:.125rem}.border-x-0{border-left-width:0;border-right-width:0}.border-dashed{border-style:dashed}.border-black{--tw-border-opacity:1;border-color:rgb(0 0 0/var(--tw-border-opacity,1))}.border-cocoa-700{--tw-border-opacity:1;border-color:rgb(149 94 75/var(--tw-border-opacity,1))}.border-yellow-900{--tw-border-opacity:1;border-color:rgb(113 63 18/var(--tw-border-opacity,1))}.border-opacity-40{--tw-border-opacity:.4}.bg-\[\#64311E\]{--tw-bg-opacity:1;background-color:rgb(100 49 30/var(--tw-bg-opacity,1))}.bg-\[\#B26F55\]{--tw-bg-opacity:1;background-color:rgb(178 111 85/var(--tw-bg-opacity,1))}.bg-\[\#B89C92\]{--tw-bg-opacity:1;background-color:rgb(184 156 146/var(--tw-bg-opacity,1))}.bg-\[\#FEF0EB\]{--tw-bg-opacity:1;background-color:rgb(254 240 235/var(--tw-bg-opacity,1))}.bg-\[\#FFE9E1\]{--tw-bg-opacity:1;background-color:rgb(255 233 225/var(--tw-bg-opacity,1))}.bg-green-50{--tw-bg-opacity:1;background-color:rgb(240 253 244/var(--tw-bg-opacity,1))}.bg-stone-500{--tw-bg-opacity:1;background-color:rgb(120 113 108/var(--tw-bg-opacity,1))}.bg-opacity-60{--tw-bg-opacity:.6}.object-cover{-o-object-fit:cover;object-fit:cover}.p-4{padding:1rem}.py-4{padding-bottom:1rem;padding-top:1rem}.text-left{text-align:left}.text-justify{text-align:justify}.font-\[\'STKaiti\'\]{font-family:STKaiti}.font-\[\'STXingkai\'\]{font-family:STXingkai}.font-beau-rivage{font-family:BeauRivage-Regular}.font-lxgw-bold{font-family:LXGWWenKai-Bold}.font-lxgw-light{font-family:LXGWWenKai-Light}.text-2xl{font-size:1.5rem;line-height:2rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-\[14px\]{font-size:.875rem}.text-\[18px\]{font-size:1.125rem}.text-\[20px\]{font-size:1.25rem}.text-\[24px\]{font-size:1.5rem}.text-\[28px\]{font-size:1.75rem}.text-\[32px\]{font-size:2rem}.text-\[36px\]{font-size:2.25rem}.text-\[48px\]{font-size:3rem}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-normal{font-weight:400}.italic{font-style:italic}.leading-\[52px\]{line-height:3.25rem}.tracking-tight{letter-spacing:-.025em}.tracking-wider{letter-spacing:.05em}.text-\[\#64311E\]{--tw-text-opacity:1;color:rgb(100 49 30/var(--tw-text-opacity,1))}.text-\[\#FFE9E1\]{--tw-text-opacity:1;color:rgb(255 233 225/var(--tw-text-opacity,1))}.text-black{--tw-text-opacity:1;color:rgb(0 0 0/var(--tw-text-opacity,1))}.text-cocoa-600{--tw-text-opacity:1;color:rgb(191 156 142/var(--tw-text-opacity,1))}.text-cocoa-700{--tw-text-opacity:1;color:rgb(149 94 75/var(--tw-text-opacity,1))}.text-cocoa-800{--tw-text-opacity:1;color:rgb(100 49 30/var(--tw-text-opacity,1))}.text-cocoa-900{--tw-text-opacity:1;color:rgb(74 31 15/var(--tw-text-opacity,1))}.text-gray-700{--tw-text-opacity:1;color:rgb(55 65 81/var(--tw-text-opacity,1))}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68/var(--tw-text-opacity,1))}.text-yellow-900{--tw-text-opacity:1;color:rgb(113 63 18/var(--tw-text-opacity,1))}.opacity-90{opacity:.9}.opacity-\[27\%\]{opacity:27%}.opacity-\[31\%\]{opacity:31%}.shadow{--tw-shadow:0 .0625rem .1875rem 0 rgba(0,0,0,.1),0 .0625rem .125rem -.0625rem rgba(0,0,0,.1);--tw-shadow-colored:0 .0625rem .1875rem 0 var(--tw-shadow-color),0 .0625rem .125rem -.0625rem var(--tw-shadow-color);-webkit-box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.brightness-95{--tw-brightness:brightness(.95)}.brightness-95,.invert{-webkit-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.invert{--tw-invert:invert(100%)}.filter{-webkit-filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{-webkit-transition-duration:.15s;transition-duration:.15s;-webkit-transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,backdrop-filter,-webkit-box-shadow,-webkit-transform,-webkit-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,backdrop-filter,-webkit-box-shadow,-webkit-transform,-webkit-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-box-shadow,-webkit-transform,-webkit-filter;-webkit-transition-timing-function:cubic-bezier(.4,0,.2,1);transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-all{-webkit-transition-duration:.15s;transition-duration:.15s;-webkit-transition-property:all;transition-property:all;-webkit-transition-timing-function:cubic-bezier(.4,0,.2,1);transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-500{-webkit-transition-duration:.5s;transition-duration:.5s}.ease-in-out{-webkit-transition-timing-function:cubic-bezier(.4,0,.2,1);transition-timing-function:cubic-bezier(.4,0,.2,1)}.\[border-bottom-width\:0\]{border-bottom-width:0}.\[white-space\:pre-wrap\]{white-space:pre-wrap}.\[writing-mode\:vertical-rl\]{-webkit-writing-mode:vertical-rl;-ms-writing-mode:tb-rl;writing-mode:vertical-rl}@font-face{font-family:LXGWWenKai-Bold;src:url(/fonts/LXGWWenKai-Bold.ttf) format("truetype")}@font-face{font-family:LXGWWenKai-Light;src:url(/fonts/LXGWWenKai-Light.ttf) format("truetype")}@font-face{font-family:LXGWWenKai-Regular;src:url(/fonts/LXGWWenKai-Regular.ttf) format("truetype")}@font-face{font-family:BeauRivage-Regular;src:url(/fonts/BeauRivage-Regular.ttf) format("truetype")}.hover\:-translate-x-3:hover{--tw-translate-x:-.75rem}.hover\:-translate-x-3:hover,.hover\:scale-\[1\.1\]:hover{-webkit-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));-ms-transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\:scale-\[1\.1\]:hover{--tw-scale-x:1.1;--tw-scale-y:1.1}.hover\:border-yellow-900:hover{--tw-border-opacity:1;border-color:rgb(113 63 18/var(--tw-border-opacity,1))}.hover\:bg-cocoa-700:hover{--tw-bg-opacity:1;background-color:rgb(149 94 75/var(--tw-bg-opacity,1))}.hover\:bg-cocoa-800:hover{--tw-bg-opacity:1;background-color:rgb(100 49 30/var(--tw-bg-opacity,1))}.hover\:bg-opacity-50:hover{--tw-bg-opacity:.5}.hover\:bg-opacity-60:hover{--tw-bg-opacity:.6}.hover\:text-cocoa-400:hover{--tw-text-opacity:1;color:rgb(237 154 141/var(--tw-text-opacity,1))}.hover\:text-yellow-900:hover{--tw-text-opacity:1;color:rgb(113 63 18/var(--tw-text-opacity,1))}.group:hover .group-hover\:text-cocoa-200{--tw-text-opacity:1;color:rgb(243 230 200/var(--tw-text-opacity,1))}.group:hover .group-hover\:text-cocoa-300{--tw-text-opacity:1;color:rgb(254 225 193/var(--tw-text-opacity,1))}.group:hover .group-hover\:text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity,1))}.prose-h2\:font-\[STKaiti\] :is(:where(h2):not(:where([class~=not-prose],[class~=not-prose] *))){font-family:STKaiti}.prose-h2\:text-\[36px\] :is(:where(h2):not(:where([class~=not-prose],[class~=not-prose] *))){font-size:2.25rem}.prose-h2\:no-underline :is(:where(h2):not(:where([class~=not-prose],[class~=not-prose] *))){text-decoration-line:none}.hover\:prose-h2\:no-underline :is(:where(h2):not(:where([class~=not-prose],[class~=not-prose] *))):hover{text-decoration-line:none}.prose-p\:text-justify :is(:where(p):not(:where([class~=not-prose],[class~=not-prose] *))){text-align:justify}.prose-p\:text-\[24px\] :is(:where(p):not(:where([class~=not-prose],[class~=not-prose] *))){font-size:1.5rem}.prose-a\:text-cocoa-600 :is(:where(a):not(:where([class~=not-prose],[class~=not-prose] *))){--tw-text-opacity:1;color:rgb(191 156 142/var(--tw-text-opacity,1))}.prose-a\:text-cocoa-700 :is(:where(a):not(:where([class~=not-prose],[class~=not-prose] *))){--tw-text-opacity:1;color:rgb(149 94 75/var(--tw-text-opacity,1))}.prose-a\:no-underline :is(:where(a):not(:where([class~=not-prose],[class~=not-prose] *))){text-decoration-line:none}.hover\:prose-a\:text-cocoa-950 :is(:where(a):not(:where([class~=not-prose],[class~=not-prose] *))):hover{--tw-text-opacity:1;color:rgb(181 0 31/var(--tw-text-opacity,1))}.hover\:prose-a\:underline :is(:where(a):not(:where([class~=not-prose],[class~=not-prose] *))):hover{text-decoration-line:underline}.prose-blockquote\:text-\[20px\] :is(:where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *))){font-size:1.25rem}.prose-code\:text-\[22px\] :is(:where(code):not(:where([class~=not-prose],[class~=not-prose] *))){font-size:1.375rem}.prose-code\:text-cocoa-700 :is(:where(code):not(:where([class~=not-prose],[class~=not-prose] *))){--tw-text-opacity:1;color:rgb(149 94 75/var(--tw-text-opacity,1))}.prose-code\:text-lime-600 :is(:where(code):not(:where([class~=not-prose],[class~=not-prose] *))){--tw-text-opacity:1;color:rgb(101 163 13/var(--tw-text-opacity,1))}.prose-code\:before\:content-none :is(:where(code):not(:where([class~=not-prose],[class~=not-prose] *))):before{--tw-content:none;content:var(--tw-content)}.prose-code\:after\:content-none :is(:where(code):not(:where([class~=not-prose],[class~=not-prose] *))):after{--tw-content:none;content:var(--tw-content)}</style>
<style>/*!
  Theme: OneDark
  Author: Lalit Magant (http://github.com/tilal6991)
  License: ~ MIT (or more permissive) [via base16-schemes-source]
  Maintainer: @highlightjs/core-team
  Version: 2021.09.0
*/pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:.1875rem .3125rem}.hljs{background:#282c34;color:#abb2bf}.hljs ::-moz-selection,.hljs::-moz-selection{background-color:#3e4451;color:#abb2bf}.hljs ::selection,.hljs::selection{background-color:#3e4451;color:#abb2bf}.hljs-comment{color:#545862}.hljs-tag{color:#565c64}.hljs-operator,.hljs-punctuation,.hljs-subst{color:#abb2bf}.hljs-operator{opacity:.7}.hljs-bullet,.hljs-deletion,.hljs-name,.hljs-selector-tag,.hljs-template-variable,.hljs-variable{color:#e06c75}.hljs-attr,.hljs-link,.hljs-literal,.hljs-number,.hljs-symbol,.hljs-variable.constant_{color:#d19a66}.hljs-class .hljs-title,.hljs-strong,.hljs-title,.hljs-title.class_{color:#e5c07b}.hljs-strong{font-weight:700}.hljs-addition,.hljs-code,.hljs-string,.hljs-title.class_.inherited__{color:#98c379}.hljs-built_in,.hljs-doctag,.hljs-keyword.hljs-atrule,.hljs-quote,.hljs-regexp{color:#56b6c2}.hljs-attribute,.hljs-function .hljs-title,.hljs-section,.hljs-title.function_,.ruby .hljs-property{color:#61afef}.diff .hljs-meta,.hljs-keyword,.hljs-template-tag,.hljs-type{color:#c678dd}.hljs-emphasis{color:#c678dd;font-style:italic}.hljs-meta,.hljs-meta .hljs-keyword,.hljs-meta .hljs-string{color:#be5046}.hljs-meta .hljs-keyword,.hljs-meta-keyword{font-weight:700}</style>
<style>.active{--tw-text-opacity:1;color:rgb(100 49 30/var(--tw-text-opacity,1))}.active_line{height:.1875rem;width:3.75rem;--tw-bg-opacity:1;background-color:rgb(100 49 30/var(--tw-bg-opacity,1))}</style>
<style>pre code .line{display:block;min-height:1rem}</style>
<link rel="stylesheet" href="/_nuxt/entry.D5BvXD_m.css" crossorigin>
<link rel="stylesheet" href="/_nuxt/default.6dp6s_dK.css" crossorigin>
<link rel="stylesheet" href="/_nuxt/ProsePre.B_fgAJq0.css" crossorigin>
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CwmBq-Is.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DoxGNRsG.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BH3As0M7.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CTfBuEtP.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/D85uACeh.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CqDhY2X1.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BSZFgSs5.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/B8IaAclc.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CB0qacqr.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BYv057UK.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/XNMtpn-M.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Cgu337ZW.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BC9i6gLq.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DQJXvQWr.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DGkyW-TE.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Cxo-2gY5.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BOAS5C5K.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CZybFE4y.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CkgQk2oE.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DLZObSHu.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CP9MGa0r.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Ddgf_0Bl.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DaEPolKA.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Cx9YVUn4.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CFDVDYID.js">
<link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/_nuxt/builds/meta/9dcb8f7a-67a6-4558-a09e-619b477e7690.json">
<meta property="og:title" content="（翻译）半小时学习rust">
<meta name="description" content="https://fasterthanli.me/articles/a-half-hour-to-learn-rust
本文为粗略的翻译
为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？">
<meta property="og:description" content="https://fasterthanli.me/articles/a-half-hour-to-learn-rust
本文为粗略的翻译
为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？">
<script type="module" src="/_nuxt/CwmBq-Is.js" crossorigin></script></head><body><div id="__nuxt"><div class="bg-[#FEF0EB] min-h-screen"><div class="flex flex-col justify-center"><div class="sticky m-0 top-0 mb-[70px] z-20"><div class="w-full h-[100px] left-0 top-0 absolute bg-[#B89C92] opacity-90 -z-10"></div><div class="w-full h-[50px] left-0 top-[100px] absolute bg-[#FEF0EB] opacity-90 -z-10"></div><img src="/img/chiya1.png" class="w-[110px] h-[110px] left-[45px] top-[45px] absolute z-20"><div class="grid grid-cols-12 mt-[45px] z-20"><div class="col-start-8 col-span-1"><a href="/" class=""><div class="grid grid-cols-1 justify-items-center group"><p class="text-[32px] leading-[52px] font-[&#39;STXingkai&#39;]">首页</p><div class="active_line" style="display:none;"></div><p class="text-[24px] leading-[52px] font-beau-rivage">Home</p></div></a></div><div class=""><a href="/essay" class=""><div class="grid grid-cols-1 justify-items-center"><p class="text-[32px] leading-[52px] font-[&#39;STXingkai&#39;]">文稿</p><div class="active_line" style="display:none;"></div><p class="text-[24px] leading-[52px] font-beau-rivage">Essay</p></div></a></div><div class=""><a href="/friend" class=""><div class="grid grid-cols-1 justify-items-center"><p class="text-[32px] leading-[52px] font-[&#39;STXingkai&#39;]">友邻</p><div class="active_line" style="display:none;"></div><p class="text-[24px] leading-[52px] font-beau-rivage">Friend</p></div></a></div><a href="/interest" class=""><div class="grid grid-cols-1 justify-items-center"><p class="text-[32px] leading-[52px] font-[&#39;STXingkai&#39;]">兴趣</p><div class="active_line" style="display:none;"></div><p class="text-[24px] leading-[52px] font-beau-rivage">Interest</p></div></a></div></div><!--[--><main><!--[--><article class="flex flex-col items-center"><h1 class="mb-6 text-[48px] font-[&#39;STKaiti&#39;]">（翻译）半小时学习rust</h1><div class="text-left"><div class="mb-12 flex justify-start"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5"></path></svg><p class="font-lxgw-light text-[18px]">2023-04-10</p><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 ml-4 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 0 0 3 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 0 0 5.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 0 0 9.568 3Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6Z"></path></svg><p class="font-lxgw-light text-[18px]">技术</p></div></div><div class="prose max-w-[900px] prose-code:before:content-none prose-code:after:content-none prose-code:text-[22px] prose-code:text-lime-600 prose-a:no-underline hover:prose-a:underline prose-a:text-cocoa-600 hover:prose-a:text-cocoa-950 prose-h2:font-[STKaiti] prose-h2:text-[36px] font-lxgw-light prose-p:text-[24px] prose-p:text-justify prose-blockquote:text-[20px]"><p><!--[--><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust" rel="nofollow"><!--[-->https://fasterthanli.me/articles/a-half-hour-to-learn-rust<!--]--></a><br>
本文为粗略的翻译<br>
为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？<!--]--></p><p><!--[-->在本文中，我将不会关注于一两个概念，而是试着通过尽可能多的Rust 代码段，解释其中的关键字和符号的含义。<!--]--></p><p><!--[-->准备好了吗？让我们开始吧！<!--]--></p><hr><p><!--[--><code class=""><!--[-->let<!--]--></code>引入了变量绑定(variable binding)<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x;  // 声明 &quot;x&quot;
x = 42; // 将 42 分配给 &quot;x&quot;
</code><!--]--></pre><!--]--><p><!--[-->也可以写成一行<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = 42;
</code><!--]--></pre><!--]--><p><!--[-->您可以显式地指定变量的类型，用冒号表示类型注释:<code class=""><!--[-->:<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x: i32; // i32是一个有符号的32位整数
x = 42;
// 有符号整数有: i8, i16, i32, i64, i128
// 无符号整数有: u8, u16, u32, u64, u128 
</code><!--]--></pre><!--]--><p><!--[-->也可以写成一行<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x: i32 = 42;
</code><!--]--></pre><!--]--><p><!--[-->如果您声明一个变量,之后再初始化，编译器将会阻止你初始化之前使用这个变量<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x`
// 借用可能未初始化的变量: `x`
x = 42;
</code><!--]--></pre><!--]--><p><!--[-->正确的写法是这样:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x;
x = 42;
foobar(x); //  `x` 的类型将会在这被推断出来
</code><!--]--></pre><!--]--><p><!--[-->下划线是一个特殊的变量名,更确切地说是 “空缺名”,意思就是扔掉一些东西:<code class=""><!--[-->_<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// 42是常数，所以无事发生
let _ = 42;

// 调用 `get_thing` 函数但是舍弃了扔掉了的结果
let _ = get_thing();
</code><!--]--></pre><!--]--><p><!--[-->以下划线开头的变量名是普通名称，只是编译器不会警告它们不被使用:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// 变量声明但不使用会被编译器警告
// 在变量名前面加下划线可以去掉警告
let _x = 42;
</code><!--]--></pre><!--]--><p><!--[-->可以对同一个变量名多次绑定-你可以掩盖(shadow)变量绑定<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = 13;
let x = x + 3;
// 在这之后使用 `x` 指代的都是第二个 `x`
// 第一个  `x` 已不存在.（关于这点本人有补充，见下）
</code><!--]--></pre><!--]--><blockquote><!--[--><p><!--[-->译者注: 掩盖(shadowing)是在作用域之内掩盖掉原有的变量名，在作用域结束之后掩盖失效，因为此处两个 <code class=""><!--[-->x<!--]--></code> 作用域相同，所以第二个<code class=""><!--[-->x<!--]--></code>会一直掩盖第一个 <code class=""><!--[-->x<!--]--></code><!--]--></p><!--]--></blockquote><p><!--[-->Rust 有元组(tuples)，您可以将其视为“不同类型的值的固定长度集合”。<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let pair = (&#39;a&#39;, 17);
pair.0; // 这是 &#39;a&#39;
pair.1; // 这是 17
</code><!--]--></pre><!--]--><p><!--[-->如果想添加类型注释:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let pair: (char, i32) = (&#39;a&#39;, 17);
</code><!--]--></pre><!--]--><p><!--[-->元组在执行任务时可以被解构(destructured)，这意味着它们被分解为独立的字段:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let (some_char, some_int) = (&#39;a&#39;, 17);
// 现在 some_char是 &#39;a&#39;，some_int是 17
</code><!--]--></pre><!--]--><p><!--[-->这点在函数返回元组时特别有用:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let (left, right) = slice.split_at(middle);
</code><!--]--></pre><!--]--><p><!--[-->当然，在解构元组时，可以用<code class=""><!--[-->_<!--]--></code>来丢弃它的一部分<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let (_, right) = slice.split_at(middle);
</code><!--]--></pre><!--]--><p><!--[-->分号表示语句的结尾:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = 3;
let y = 5;
let z = y + x;
</code><!--]--></pre><!--]--><p><!--[-->这意味着语句可以跨越多行<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
</code><!--]--></pre><!--]--><p><!--[-->(我们待会儿再讨论它们的意思)
<code class=""><!--[-->fn<!--]--></code>声明一个没有返回值的函数<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn greet() {
    println!(&quot;Hi there!&quot;);
}
</code><!--]--></pre><!--]--><p><!--[-->下面的函数返回32位有符号整数，箭头<code class=""><!--[-->-&gt;<!--]--></code>表示它的返回类型:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn fair_dice_roll() -&gt; i32 {
    4
}
</code><!--]--></pre><!--]--><p><!--[-->一对花括号<code class=""><!--[-->{}<!--]--></code>声明一个代码块(block)，它有自己的作用域<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// This prints &quot;in&quot;, then &quot;out&quot;
fn main() {
    let x = &quot;out&quot;;
    {
        // this is a different `x`
        let x = &quot;in&quot;;
        println!(&quot;{}&quot;, x);
    }
    println!(&quot;{}&quot;, x);
}
</code><!--]--></pre><!--]--><p><!--[-->代码块也是表达式，可以计算为(evaluate)一个值<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = 42;
// 两者等价
let x = { 42 };
</code><!--]--></pre><!--]--><p><!--[-->在一个代码块中，可以有多个语句<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = {
    let y = 1; // first statement
    let z = 2; // second statement
    y + z // 这是代码块的结尾 - 整个代码块返回的值
};
</code><!--]--></pre><!--]--><p><!--[-->所以省略函数末尾语句的分号等价于return语句<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn fair_dice_roll() -&gt; i32 {
    return 4;
}

fn fair_dice_roll() -&gt; i32 {
    4
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->if<!--]--></code> 条件语句也是表达式<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn fair_dice_roll() -&gt; i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->match<!--]--></code>语句也是表达式<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn fair_dice_roll() -&gt; i32 {
    match feeling_lucky {
        true =&gt; 6,
        false =&gt; 4,
    }
}
</code><!--]--></pre><!--]--><p><!--[-->符号点<code class=""><!--[-->.<!--]--></code>通常用于访问值的字段:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let a = (10, 20);
a.0; // this is 10

let amos = get_some_struct();
amos.nickname; // this is &quot;fasterthanlime&quot;
</code><!--]--></pre><!--]--><p><!--[-->或者调用值的某个方法:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let nick = &quot;fasterthanlime&quot;;
nick.len(); // this is 14
</code><!--]--></pre><!--]--><p><!--[-->双冒号<code class=""><!--[-->::<!--]--></code>类似，但是它用于命名空间<!--]--></p><p><!--[-->在这个例子中，<code class=""><!--[-->std<!--]--></code>是一个crate,<code class=""><!--[-->cmd<!--]--></code>是一个模块(module),<code class=""><!--[-->min<!--]--></code>是一个函数<!--]--></p><blockquote><!--[--><p><!--[-->译者注:package、crate、module概念不要以其他语言的概念先入为主，这里简要提一下，不作展开<!--]--></p><ol><!--[--><li><!--[-->package为项目，就是cargo new创建的项目就称为package<!--]--></li><li><!--[-->crate是一个独立的编译单元，又分为binary(二进制) crate和library crate，硬要翻译这个名词的话叫做分隔箱比较恰当。
binary crate的充要条件是有src/main.rs
library crate的充要条件是有src/lib.rs<!--]--></li><li><!--[-->module是模块，用于内部代码的组织，可以控制作用域及私有性<!--]--></li><!--]--></ol><!--]--></blockquote><!--[--><pre class="language-rust" style=""><!--[--><code>let least = std::cmp::min(3, 8); // this is 3
</code><!--]--></pre><!--]--><p><!--[-->use directives can be used to &quot;bring in scope&quot; names from other namespace:
<code class=""><!--[-->use<!--]--></code>关键字用来引入其他命名空间的作用域里的内容，例如函数<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>use std::cmp::min;
let least = min(7, 1); // this is 1
</code><!--]--></pre><!--]--><p><!--[-->在 use 关键字中，花括号还有另一个意思: 它们来源相同
如果我们想同时导入 min 和 max，我们可以执行以下任何操作:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// this works:
use std::cmp::min;
use std::cmp::max;

// this also works:
use std::cmp::{min, max};

// this also works!
use std::{cmp::min, cmp::max};
</code><!--]--></pre><!--]--><blockquote><!--[--><p><!--[-->类似于javascript的<code class=""><!--[-->import {min,max} from &#39;xxx&#39;<!--]--></code><!--]--></p><!--]--></blockquote><p><!--[-->A wildcard () lets you import every symbol from a namespace:*
通配符<code class=""><!--[-->*<!--]--></code>允许你从命名空间导入所有内容<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// this brings `min` and `max` in scope, and many other things
use std::cmp::*;
</code><!--]--></pre><!--]--><p><!--[-->类型也命名空间，类型的方法可以作为常规函数调用:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let x = &quot;amos&quot;.len(); // this is 4
let x = str::len(&quot;amos&quot;); // this is also 4
</code><!--]--></pre><!--]--><p><!--[-->str is a primitive type, but many non-primitive types are also in scope by default.
<code class=""><!--[-->str<!--]--></code>是原始类型，但也有许多非原始类型<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// `Vec` is a regular struct, not a primitive type
let v = Vec::new();

// this is exactly the same code, but with the *full* path to `Vec`
let v = std::vec::Vec::new();
</code><!--]--></pre><!--]--><p><!--[-->这会正常编译，因为Rust会在每个模块的开头插入:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>use std::prelude::v1::*;
</code><!--]--></pre><!--]--><p><!--[-->(这引入了很多东西，<code class=""><!--[-->Vec<!--]--></code>, <code class=""><!--[-->String<!--]--></code>, <code class=""><!--[-->Option<!--]--></code> ,<code class=""><!--[-->Result<!--]--></code> 等等)<!--]--></p><p><!--[--><code class=""><!--[-->struct<!--]--></code>关键字用于声明结构体<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Vec2 {
    x: f64, // 64-bit floating point, aka &quot;double precision&quot;
    y: f64,
}
</code><!--]--></pre><!--]--><p><!--[-->使用结构体字面量初始化<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>Rust code
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// the order does not matter, only the names do
</code><!--]--></pre><!--]--><p><!--[-->用另一个结构体初始化剩余字段的快捷方式:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let v3 = Vec2 {
    x: 14.0,
    ..v2
    // 只能在最后使用，后面不能有逗号
};
</code><!--]--></pre><!--]--><p><!--[-->注意，剩余字段前面不加任何东西时可以表示所有字段:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let v4 = Vec2 { ..v3 };
</code><!--]--></pre><!--]--><p><!--[-->结构体可以像元组一样被解构<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let (left, right) = slice.split_at(middle);
</code><!--]--></pre><!--]--><p><!--[-->像这样<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// `x` 为 3.0, `y` 为 `6.0`
</code><!--]--></pre><!--]--><p><!--[-->还有这样<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let Vec2 { x, .. } = v;
// 舍弃了 `v.y`
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->let<!--]--></code>模式匹配可以作为<code class=""><!--[-->if<!--]--></code>的判断条件<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    if let Number { odd: true, value } = n {
        println!(&quot;Odd number: {}&quot;, value);
    } else if let Number { odd: false, value } = n {
        println!(&quot;Even number: {}&quot;, value);
    }
}

// this prints:
// Odd number: 1
// Even number: 2
</code><!--]--></pre><!--]--><p><!--[-->match选择支也是模式匹配，类似与 if let<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_number(n: Number) {
    match n {
        Number { odd: true, value } =&gt; println!(&quot;Odd number: {}&quot;, value),
        Number { odd: false, value } =&gt; println!(&quot;Even number: {}&quot;, value),
    }
}

// this prints the same as before
</code><!--]--></pre><!--]--><p><!--[-->match必须是详尽的，即必须至少有一个选择支能够匹配上<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } =&gt; println!(&quot;One&quot;),
        Number { value: 2, .. } =&gt; println!(&quot;Two&quot;),
        Number { value, .. } =&gt; println!(&quot;{}&quot;, value),
        // if that last arm didn&#39;t exist, we would get a compile-time error
    }
}
</code><!--]--></pre><!--]--><p><!--[-->如果很难穷尽所有情形, 可以使用下划线<code class=""><!--[-->_<!--]--></code>匹配剩下的所有情形<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_number(n: Number) {
    match n.value {
        1 =&gt; println!(&quot;One&quot;),
        2 =&gt; println!(&quot;Two&quot;),
        _ =&gt; println!(&quot;{}&quot;, n.value),
    }
}
</code><!--]--></pre><!--]--><p><!--[-->你可以声明你自己的类型的方法<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -&gt; bool {
        self.value &gt; 0
    }
}
</code><!--]--></pre><!--]--><p><!--[-->然后普通地使用<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!(&quot;positive? {}&quot;, minus_two.is_strictly_positive());
    // this prints &quot;positive? false&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->Variable bindings are immutable by default, which means their interior can&#39;t be mutated:
变量绑定在默认情况下是不可变的，这意味着它们的内部不能变化<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n.odd = false; // error: cannot assign to `n.odd`,
                   // as `n` is not declared to be mutable
}
</code><!--]--></pre><!--]--><p><!--[-->这也意味着该变量不能被再次分配<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->mut<!--]--></code> 可以使变量绑定为可变的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // all good
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->Traits<!--]--></code>(特型) 是多种类型共有的东西(类似于其他编程语言的接口)<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>trait Signed {
    fn is_strictly_negative(self) -&gt; bool;
}
</code><!--]--></pre><!--]--><p><!--[-->“孤儿规则”(orphan rules):
如果要实现某个trait，那么该trait和要实现该trait的类型至少有一个要在当前crate中定义<!--]--></p><p><!--[-->在上面已经定义了
<code class=""><!--[-->trait<!--]--></code>:Signed
<code class=""><!--[-->struct<!--]--></code>:Number<!--]--></p><p><!--[-->在自定义的的类型中实现自定义的trait<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl Signed for Number {
    fn is_strictly_negative(self) -&gt; bool {
        self.value &lt; 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!(&quot;{}&quot;, n.is_strictly_negative()); // prints &quot;true&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->在其他类型中实现自定义trait(i32是一个原始类型):<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl Signed for i32 {
    fn is_strictly_negative(self) -&gt; bool {
        self &lt; 0
    }
}

fn main() {
    let n: i32 = -44;
    println!(&quot;{}&quot;, n.is_strictly_negative()); // prints &quot;true&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->在自定义类型中实现其他trait<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>//  `Neg` trait 用于一元运算符 `-`的重载

impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -&gt; Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }        
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // this is only possible because we implemented `Neg`
    println!(&quot;{}&quot;, m.value); // prints &quot;-987&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->An block is always for a type, so, inside that block, means that type:implSelf
一个代码块用于一个类型，所以在这个代码块的内部意味着这个类型的自我实现<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -&gt; Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }        
    }
}
</code><!--]--></pre><!--]--><p><!--[-->Some traits are markers - they don&#39;t say that a type implements some methods, they say that certain things can be done with a type.
有些trait是marker(标记)——它们不是说类型实现了某些方法，而是说某些事情可以用类型来完成。<!--]--></p><p><!--[-->举个例子，<code class=""><!--[-->i32<!--]--></code> 实现了trait <code class=""><!--[-->Copy<!--]--></code>(i32可以认为是Copy类型)，所以<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let a: i32 = 15;
    let b = a; // `a` 被拷贝
    let c = a; // `a` 再次被拷贝
}
</code><!--]--></pre><!--]--><p><!--[-->这同样也可以<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_i32(x: i32) {
    println!(&quot;x = {}&quot;, x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}
</code><!--]--></pre><!--]--><p><!--[-->但结构体<code class=""><!--[-->Number<!--]--></code>不是<code class=""><!--[-->Copy<!--]--></code>,所以这样不行:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `n` is moved into `m`
    let o = n; // error: use of moved value: `n`
}
</code><!--]--></pre><!--]--><p><!--[-->这同样不行:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_number(n: Number) {
    println!(&quot;{} number {}&quot;, if n.odd { &quot;odd&quot; } else { &quot;even&quot; }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // `n` is moved
    print_number(n); // error: use of moved value: `n`
}
</code><!--]--></pre><!--]--><p><!--[-->但<code class=""><!--[-->print_number<!--]--></code>使用不可变引用(immutable reference)后则可以<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print_number(n: &amp;Number) {
    println!(&quot;{} number {}&quot;, if n.odd { &quot;odd&quot; } else { &quot;even&quot; }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&amp;n); // `n` is borrowed for the time of the call
    print_number(&amp;n); // `n` is borrowed again
}
</code><!--]--></pre><!--]--><p><!--[-->如果一个函数接受一个可变的引用，那么它也可以工作——但是只有当我们的变量绑定也是 mut 的时候<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn invert(n: &amp;mut Number) {
    n.value = -n.value;
}

fn print_number(n: &amp;Number) {
    println!(&quot;{} number {}&quot;, if n.odd { &quot;odd&quot; } else { &quot;even&quot; }, n.value);
}

fn main() {
    // this time, `n` is mutable
    let mut n = Number { odd: true, value: 51 };
    print_number(&amp;n);
    invert(&amp;mut n); // `n is borrowed mutably - everything is explicit
    print_number(&amp;n);
}
</code><!--]--></pre><!--]--><p><!--[-->Trait methods can also take by reference or mutable reference:self
Trait 方法可以通过引用或可变引用接收<code class=""><!--[-->self<!--]--></code>:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl std::clone::Clone for Number {
    fn clone(&amp;self) -&gt; Self {
        Self { ..*self }
    }
}
</code><!--]--></pre><!--]--><p><!--[-->当调用 trait 方法时，接收方是隐式借用的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone();
    m.value += 100;
    
    print_number(&amp;n);
    print_number(&amp;m);
}
</code><!--]--></pre><!--]--><p><!--[-->注意:这两种写法是等价的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>let m = n.clone();
let m = std::clone::Clone::clone(&amp;n);
</code><!--]--></pre><!--]--><p><!--[-->Marker traits like have no methods:Copy
像 Copy 这样的 Marker trait没有方法:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// note: `Copy` requires that `Clone` is implemented too
impl std::clone::Clone for Number {
    fn clone(&amp;self) -&gt; Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
</code><!--]--></pre><!--]--><p><!--[-->现在Clone仍然可用<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
</code><!--]--></pre><!--]--><p><!--[-->但是 Number的值不再移动(move)<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `m` is a copy of `n`
    let o = n; // same. `n` is neither moved nor borrowed.
}
</code><!--]--></pre><!--]--><p><!--[-->有些trait非常常见，它们可以使用<code class=""><!--[-->derive<!--]--></code>属性自动实现:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}
// 扩展了 `impl Clone for Number` 以及 `impl Copy for Number` 的代码块.
</code><!--]--></pre><!--]--><p><!--[-->函数可以是泛型的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;T&gt;(arg: T) {
    // do something with `arg`
}
</code><!--]--></pre><!--]--><p><!--[-->它们可以有多个类型参数，然后可以在函数的声明和函数体中使用这些参数，而不是具体的类型:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;L, R&gt;(left: L, right: R) {
    // do something with `left` and `right`
}
</code><!--]--></pre><!--]--><p><!--[-->类型参数通常也有约束，因此您可以对它们进行一些实际操作。
最简单的是通过 <code class=""><!--[-->trait<!--]--></code> 来约束<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print&lt;T: Display&gt;(value: T) {
    println!(&quot;value = {}&quot;, value);
}

fn print&lt;T: Debug&gt;(value: T) {
    println!(&quot;value = {:?}&quot;, value);
}
</code><!--]--></pre><!--]--><blockquote><!--[--><p><!--[-->Display 和 Debug都是一种trait，用于格式化输出<!--]--></p><!--]--></blockquote><p><!--[-->类型参数约束有更长的语法:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print&lt;T&gt;(value: T)
where
    T: Display,
{
    println!(&quot;value = {}&quot;, value);
}
</code><!--]--></pre><!--]--><p><!--[-->约束可能更复杂: 可能需要一个类型参数来实现多个 trait:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>use std::fmt::Debug;

fn compare&lt;T&gt;(left: T, right: T)
where
    T: Debug + PartialEq,
{
    println!(&quot;{:?} {} {:?}&quot;, left, if left == right { &quot;==&quot; } else { &quot;!=&quot; }, right);
}

fn main() {
    compare(&quot;tea&quot;, &quot;coffee&quot;);
    // prints: &quot;tea&quot; != &quot;coffee&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.
泛型函数可以被看作是命名空间，包含无数具有不同具体类型的函数<!--]--></p><p><!--[-->Same as with crates, and modules, and types, generic functions can be &quot;explored&quot; (navigated?) using ::
与crate、module和type一样，泛型函数也可以使用双冒号<code class=""><!--[-->::<!--]--></code>进行访问<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    use std::any::type_name;
    println!(&quot;{}&quot;, type_name::&lt;i32&gt;()); // prints &quot;i32&quot;
    println!(&quot;{}&quot;, type_name::&lt;(f64, char)&gt;()); // prints &quot;(f64, char)&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->This is lovingly called turbofish syntax, because looks like a fish.::&lt;&gt;
这被亲切地称为 turbofish(涡轮鱼?) 语法，因为<code class=""><!--[-->::&lt;&gt;<!--]--></code> 看起来像一条鱼。<!--]--></p><p><!--[-->结构体也可以是泛型的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Pair&lt;T&gt; {
    a: T,
    b: T,
}

fn print_type_name&lt;T&gt;(_val: &amp;T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&amp;p1); // prints &quot;Pair&lt;i32&gt;&quot;
    print_type_name(&amp;p2); // prints &quot;Pair&lt;bool&gt;&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->标准库类型 Vec (分配在堆上的数组)是泛型的的
The standard library type (~ a heap-allocated array), is generic:Vec<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let mut v1 = Vec::new();
    v1.push(1);
    let mut v2 = Vec::new();
    v2.push(false);
    print_type_name(&amp;v1); // prints &quot;Vec&lt;i32&gt;&quot;
    print_type_name(&amp;v2); // prints &quot;Vec&lt;bool&gt;&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->Speaking of , it comes with a macro that gives more or less &quot;vec literals&quot;:Vec
说到 Vec，它或多或少都会用到宏来提供“ vec 字面值”:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![true, false, true];
    print_type_name(&amp;v1); // prints &quot;Vec&lt;i32&gt;&quot;
    print_type_name(&amp;v2); // prints &quot;Vec&lt;bool&gt;&quot;
}
</code><!--]--></pre><!--]--><p><!--[-->All of , or invoke a macro. Macros just expand to regular code.name!()name![]name!{}
<code class=""><!--[-->name!()<!--]--></code> ，<code class=""><!--[-->name![]<!--]--></code>或<code class=""><!--[-->name!{}<!--]--></code>都调用了宏。宏只是扩展为常规代码<!--]--></p><p><!--[-->其实<code class=""><!--[-->println<!--]--></code> 就是一个宏<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    println!(&quot;{}&quot;, &quot;Hello there!&quot;);
}
</code><!--]--></pre><!--]--><p><!--[-->这段代码会扩展为以下等效的代码:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    use std::io::{self, Write};
    io::stdout().lock().write_all(b&quot;Hello there!\n&quot;).unwrap();
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->panic<!--]--></code>(恐慌/异常) 也是一个宏。它通过一条错误消息和错误的文件名/行号(如果启用的话)强制停止执行:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    panic!(&quot;This panics&quot;);
}
// output: thread &#39;main&#39; panicked at &#39;This panics&#39;, src/main.rs:3:5
</code><!--]--></pre><!--]--><p><!--[-->Some methods also panic. For example, the type can contain something, or it can contain nothing. If is called on it, and it contains nothing, it panics:Option.unwrap()
有些方法也会引起<code class=""><!--[-->panic<!--]--></code>。例如，Option 类型可以包含某些内容，也可以不包含。如果。在它上面调用 <code class=""><!--[-->.unpack()<!--]--></code>但不包含任何东西的话，就会发生<code class=""><!--[-->panic<!--]--></code>:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let o1: Option&lt;i32&gt; = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option&lt;i32&gt; = None;
    o2.unwrap(); // this panics!
}
// output: thread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, src/libcore/option.rs:378:21
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->Option<!--]--></code> 不是一个结构体 - 而是一个enum(枚举类)，它有两种变体(variant)<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        // enums variants 可以用于模式匹配:
        match self {
            Self::Some(t) =&gt; t,
            Self::None =&gt; panic!(&quot;.unwrap() called on a None option&quot;),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option&lt;i32&gt; = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option&lt;i32&gt; = None;
    o2.unwrap(); // this panics!
}
// output: thread &#39;main&#39; panicked at &#39;.unwrap() called on a None option&#39;, src/main.rs:11:27
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->Result<!--]--></code> 也是一个 enum, 包含一个内容和一个错误<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code><!--]--></pre><!--]--><p><!--[-->It also panics when unwrapped and containing an error.
当被解析出一个错误(error)时，它也会panic<!--]--></p><p><!--[-->变量绑定具有生命周期 (lifetime):<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    // `x` doesn&#39;t exist yet
    {
        let x = 42; // `x` starts existing
        println!(&quot;x = {}&quot;, x);
        // `x` stops existing
    }
    // `x` no longer exists
}
</code><!--]--></pre><!--]--><p><!--[-->引用同样也有生命周期<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    // `x` doesn&#39;t exist yet
    {
        let x = 42; // `x` starts existing
        let x_ref = &amp;x; // `x_ref` starts existing - it borrows `x`
        println!(&quot;x_ref = {}&quot;, x_ref);
        // `x_ref` stops existing
        // `x` stops existing
    }
    // `x` no longer exists
}
</code><!--]--></pre><!--]--><p><!--[-->引用的生命周期不能超过其借用的变量绑定的生命周期期:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let x_ref = {
        let x = 42;
        &amp;x
    };
    println!(&quot;x_ref = {}&quot;, x_ref);
    // error: `x` does not live long enough
}
</code><!--]--></pre><!--]--><p><!--[-->A variable binding can be immutably borrowed multiple times:
可以多次不可变地借用变量绑定:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let x = 42;
    let x_ref1 = &amp;x;
    let x_ref2 = &amp;x;
    let x_ref3 = &amp;x;
    println!(&quot;{} {} {}&quot;, x_ref1, x_ref2, x_ref3);
}
</code><!--]--></pre><!--]--><p><!--[-->借用时，变量绑定不能发生变化<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let mut x = 42;
    let x_ref = &amp;x;
    x = 13;
    println!(&quot;x_ref = {}&quot;, x_ref);
    // error: cannot assign to `x` because it is borrowed
}
</code><!--]--></pre><!--]--><p><!--[-->不可变借用时，变量不能再被可变借用<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let mut x = 42;
    let x_ref1 = &amp;x;
    let x_ref2 = &amp;mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    println!(&quot;x_ref1 = {}&quot;, x_ref1);
}
</code><!--]--></pre><!--]--><ul><!--[--><li><!--[-->在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。<!--]--></li><li><!--[-->引用必须总是有效的。<!--]--></li><!--]--></ul><p><!--[-->函数参数中的引用也有生命周期:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn print(x: &amp;i32) {
    // `x` is borrowed (from the outside) for the
    // entire time this function is called.
}
</code><!--]--></pre><!--]--><p><!--[-->具有引用参数的函数可以通过具有不同生命周期的借用来调用，因此:<!--]--></p><ul><!--[--><li><!--[-->所有接受引用参数的函数都是泛型的<!--]--></li><li><!--[-->生命周期是一个泛型的参数<!--]--></li><!--]--></ul><p><!--[-->生命周期的名称以单引号<code class=""><!--[-->&#39;<!--]--></code>开头<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>// elided (non-named) lifetimes:
fn print(x: &amp;i32) {}

// named lifetimes:
fn print&lt;&#39;a&gt;(x: &amp;&#39;a i32) {}
</code><!--]--></pre><!--]--><p><!--[-->This allows returning references whose lifetime depend on the lifetime of the arguments:
谁的生命周期依赖于参数的生命周期，就返回谁的引用<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Number {
    value: i32,
}

fn number_value&lt;&#39;a&gt;(num: &amp;&#39;a Number) -&gt; &amp;&#39;a i32 {
    &amp;num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&amp;n);
    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.
    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.
}
</code><!--]--></pre><!--]--><p><!--[-->当输入只有一个生命周期时，不需要命名，并且所有东西都有相同的生命周期，因此下面的两个函数是等价的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn number_value&lt;&#39;a&gt;(num: &amp;&#39;a Number) -&gt; &amp;&#39;a i32 {
    &amp;num.value
}

fn number_value(num: &amp;Number) -&gt; &amp;i32 {
    &amp;num.value
}
</code><!--]--></pre><!--]--><p><!--[-->Structs can also be generic over lifetimes, which allows them to hold references:
结构体可以在生命周期里都是泛型的，这使其可以接受引用<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct NumRef&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &amp;x };
    // `x_ref` cannot outlive `x`, etc.
}
</code><!--]--></pre><!--]--><p><!--[-->同样的代码，额外添加了函数<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct NumRef&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn as_num_ref&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; NumRef&lt;&#39;a&gt; {
    NumRef { x: &amp;x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&amp;x);
    // `x_ref` cannot outlive `x`, etc.
}
</code><!--]--></pre><!--]--><p><!--[-->The same code, but with &quot;elided&quot; lifetimes:
同样的代码，省略了声明周期<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct NumRef&lt;&#39;a&gt; {
    x: &amp;&#39;a i32,
}

fn as_num_ref(x: &amp;i32) -&gt; NumRef&lt;&#39;_&gt; {
    NumRef { x: &amp;x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&amp;x);
    // `x_ref` cannot outlive `x`, etc.
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->impl<!--]--></code> 代码块在生命周期里也是泛型的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl&lt;&#39;a&gt; NumRef&lt;&#39;a&gt; {
    fn as_i32_ref(&amp;&#39;a self) -&gt; &amp;&#39;a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &amp;x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // neither ref can outlive `x`
}
</code><!--]--></pre><!--]--><p><!--[-->但你也可以省略<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl&lt;&#39;a&gt; NumRef&lt;&#39;a&gt; {
    fn as_i32_ref(&amp;self) -&gt; &amp;i32 {
        self.x
    }
}
</code><!--]--></pre><!--]--><p><!--[-->如果不需要这个生命周期的名字，你可以狠狠地省略:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>impl NumRef&lt;&#39;_&gt; {
    fn as_i32_ref(&amp;self) -&gt; &amp;i32 {
        self.x
    }
}
</code><!--]--></pre><!--]--><p><!--[-->有一个特殊的生命周期:<code class=""><!--[-->static<!--]--></code>，它对整个程序的生命周期都有效。(类比其他语言里的静态全局变量)<!--]--></p><p><!--[-->String 是<code class=""><!--[-->&#39;static<!--]--></code>(静态全局)的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Person {
    name: &amp;&#39;static str,
}

fn main() {
    let p = Person {
        name: &quot;fasterthanlime&quot;,
    };
}
</code><!--]--></pre><!--]--><p><!--[-->但是 string的所有者不是<code class=""><!--[-->static<!--]--></code>的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Person {
    name: &amp;&#39;static str,
}

fn main() {
    let name = format!(&quot;fasterthan{}&quot;, &quot;lime&quot;);
    let p = Person { name: &amp;name };
    // error: `name` does not live long enough
}
</code><!--]--></pre><!--]--><p><!--[-->在最后一个示例中，变量<code class=""><!--[-->name<!--]--></code>不是 <code class=""><!--[-->&amp;&#39;static str<!--]--></code>，而是 <code class=""><!--[-->String<!--]--></code>。它是动态分配的，会被释放。它的生命周期小于整个程序(即使它在 main 中)。<!--]--></p><p><!--[-->To store a non- string in , it needs to either:&#39;staticPerson
要想在结构体<code class=""><!--[-->Person<!--]--></code>中存储非<code class=""><!--[-->&#39;static<!--]--></code>的string，需要满足
A) 在生命周期里是泛型:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Person&lt;&#39;a&gt; {
    name: &amp;&#39;a str,
}

fn main() {
    let name = format!(&quot;fasterthan{}&quot;, &quot;lime&quot;);
    let p = Person { name: &amp;name };
    // `p` cannot outlive `name`
}
</code><!--]--></pre><!--]--><p><!--[-->或者
B) 获得string的所有权<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Person {
    name: String,
}

fn main() {
    let name = format!(&quot;fasterthan{}&quot;, &quot;lime&quot;);
    let p = Person { name: name };
    // `name` was moved into `p`, their lifetimes are no longer tied.
}
</code><!--]--></pre><!--]--><p><!--[-->在结构体中，当字段与变量绑定同名时<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>    let p = Person { name: name };
</code><!--]--></pre><!--]--><p><!--[-->可以简写成:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>    let p = Person { name };
</code><!--]--></pre><!--]--><p><!--[-->Rust 中的许多类型，有<code class=""><!--[-->所有者<!--]--></code>(owned)的和<code class=""><!--[-->非所有者<!--]--></code>(nom-owned)的变体:<!--]--></p><blockquote><!--[--><p><!--[-->引用可以在没有所有权的情况下使用被绑定的变量<!--]--></p><!--]--></blockquote><ul><!--[--><li><!--[-->Strings: String 是所有者, &amp;str 是引用(reference)<!--]--></li><li><!--[-->Paths: PathBuf 是所有者, &amp;Path 是引用<!--]--></li><li><!--[-->Collections: <code class=""><!--[-->Vec&lt;T&gt;<!--]--></code> 所有者, <code class=""><!--[-->&amp;[T]<!--]--></code>是引用<!--]--></li><!--]--></ul><p><!--[-->Rust 有切片(slice)-切片是对多个连续元素的引用
可以借用 vector 的切片，例如<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let v2 = &amp;v[2..4];
    println!(&quot;v2 = {:?}&quot;, v2);
}

// output:
// v2 = [3, 4]
</code><!--]--></pre><!--]--><p><!--[-->这不足为奇。利用<code class=""><!--[-->Index<!--]--></code>和<code class=""><!--[-->IndexMut<!--]--></code>的<code class=""><!--[-->trait<!--]--></code>就可以重载索引运算(<code class=""><!--[-->foo[index]<!--]--></code>)。<!--]--></p><p><!--[-->(两个点)<code class=""><!--[-->..<!--]--></code>语法只是表示范围(range),range只是在标准库里定义的少数结构体<!--]--></p><p><!--[-->范围是开放式的，一般是左闭右开区间，如果最右端使用等号<code class=""><!--[-->=<!--]--></code>，右端就是闭区间<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    // 0 or greater
    println!(&quot;{:?}&quot;, (0..).contains(&amp;100)); // true
    // strictly less than 20
    println!(&quot;{:?}&quot;, (..20).contains(&amp;20)); // false
    // 20 or less than 20
    println!(&quot;{:?}&quot;, (..=20).contains(&amp;20)); // true
    // only 3, 4, 5
    println!(&quot;{:?}&quot;, (3..6).contains(&amp;4)); // true
}
</code><!--]--></pre><!--]--><p><!--[-->借用规则也适用于切片<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn tail(s: &amp;[u8]) -&gt; &amp;[u8] {
  &amp;s[1..] 
}

fn main() {
    let x = &amp;[1, 2, 3, 4, 5];
    let y = tail(x);
    println!(&quot;y = {:?}&quot;, y);
}
</code><!--]--></pre><!--]--><p><!--[-->等价于<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn tail&lt;&#39;a&gt;(s: &amp;&#39;a [u8]) -&gt; &amp;&#39;a [u8] {
  &amp;s[1..] 
}
</code><!--]--></pre><!--]--><p><!--[-->这是合法的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let y = {
        let x = &amp;[1, 2, 3, 4, 5];
        tail(x)
    };
    println!(&quot;y = {:?}&quot;, y);
}
</code><!--]--></pre><!--]--><p><!--[-->但这因为<code class=""><!--[-->[1,2,3,4,5]<!--]--></code>是一个静态数组<!--]--></p><p><!--[-->而这是不合法的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let y = {
        let v = vec![1, 2, 3, 4, 5];
        tail(&amp;v)
        // error: `v` does not live long enough
    };
    println!(&quot;y = {:?}&quot;, y);
}
</code><!--]--></pre><!--]--><p><!--[-->因为vector是分配在堆上的，没有<code class=""><!--[-->&#39;static<!--]--></code>的生命周期<!--]--></p><p><!--[-->&amp;str实际上是切片:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn file_ext(name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    // this does not create a new string - it returns
    // a slice of the argument.
    name.split(&quot;.&quot;).last()
}

fn main() {
    let name = &quot;Read me. Or don&#39;t.txt&quot;;
    if let Some(ext) = file_ext(name) {
        println!(&quot;file extension: {}&quot;, ext);
    } else {
        println!(&quot;no file extension&quot;);
    }
}
</code><!--]--></pre><!--]--><p><!--[-->所以借用规则也适用于此:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let ext = {
        let name = String::from(&quot;Read me. Or don&#39;t.txt&quot;);
        file_ext(&amp;name).unwrap_or(&quot;&quot;)
        // error: `name` does not live long enough
    };
    println!(&quot;extension: {:?}&quot;, ext);
}
</code><!--]--></pre><!--]--><p><!--[-->函数可以失败并特别地返回一个<code class=""><!--[-->Result<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let s = std::str::from_utf8(&amp;[240, 159, 141, 137]);
    println!(&quot;{:?}&quot;, s);
    // prints: Ok(&quot;🍉&quot;)

    let s = std::str::from_utf8(&amp;[195, 40]);
    println!(&quot;{:?}&quot;, s);
    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })
}
</code><!--]--></pre><!--]--><p><!--[-->如果你想在失败的情况下<code class=""><!--[-->panic<!--]--></code>,可以使用<code class=""><!--[-->.unwrap()<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let s = std::str::from_utf8(&amp;[240, 159, 141, 137]).unwrap();
    println!(&quot;{:?}&quot;, s);
    // prints: &quot;🍉&quot;

    let s = std::str::from_utf8(&amp;[195, 40]).unwrap();
    // prints: thread &#39;main&#39; panicked at &#39;called `Result::unwrap()`
    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }&#39;,
    // src/libcore/result.rs:1165:5
}
</code><!--]--></pre><!--]--><p><!--[-->或者用 .expect(), 可以自定义信息<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let s = std::str::from_utf8(&amp;[195, 40]).expect(&quot;valid utf-8&quot;);
    // prints: thread &#39;main&#39; panicked at &#39;valid utf-8: Utf8Error
    // { valid_up_to: 0, error_len: Some(1) }&#39;, src/libcore/result.rs:1165:5
}
</code><!--]--></pre><!--]--><p><!--[-->或者使用模式匹配<code class=""><!--[-->match<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    match std::str::from_utf8(&amp;[240, 159, 141, 137]) {
        Ok(s) =&gt; println!(&quot;{}&quot;, s),
        Err(e) =&gt; panic!(e),
    }
    // prints 🍉
}
</code><!--]--></pre><!--]--><p><!--[-->或者使用:<code class=""><!--[-->if let<!--]--></code><!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    if let Ok(s) = std::str::from_utf8(&amp;[240, 159, 141, 137]) {
        println!(&quot;{}&quot;, s);
    }
    // prints 🍉
}
</code><!--]--></pre><!--]--><p><!--[-->或者将错误上报:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() -&gt; Result&lt;(), std::str::Utf8Error&gt; {
    match std::str::from_utf8(&amp;[240, 159, 141, 137]) {
        Ok(s) =&gt; println!(&quot;{}&quot;, s),
        Err(e) =&gt; return Err(e),
    }
    Ok(())
}
</code><!--]--></pre><!--]--><p><!--[-->或者使用 <code class=""><!--[-->?<!--]--></code> 简单处理<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() -&gt; Result&lt;(), std::str::Utf8Error&gt; {
    let s = std::str::from_utf8(&amp;[240, 159, 141, 137])?;
    println!(&quot;{}&quot;, s);
    Ok(())
}
</code><!--]--></pre><!--]--><p><!--[-->操作符 <code class=""><!--[-->*<!--]--></code> 可以用于解引用，但是您不需要这样来访问字段或调用方法:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &amp;p;
    println!(&quot;({}, {})&quot;, p_ref.x, p_ref.y);
}

// prints `(1, 3)`
</code><!--]--></pre><!--]--><p><!--[-->如果类型为Copy时只需要这样:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &amp;p;
    negate(*p_ref);
    // error: cannot move out of `*p_ref` which is behind a shared reference
}
</code><!--]--></pre><!--]--><!--[--><pre class="language-rust" style=""><!--[--><code>// now `Point` is `Copy`
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &amp;p;
    negate(*p_ref); // ...and now this works
}
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->Closure<!--]--></code>(闭包)只是 <code class=""><!--[-->Fn<!--]--></code>、 <code class=""><!--[-->FnMut<!--]--></code> 或 <code class=""><!--[-->FnOnce<!--]--></code> 类型的函数，具有一定的<code class=""><!--[-->context<!--]--></code>(语境/运行环境/上下文)<!--]--></p><p><!--[-->Their parameters are a comma-separated list of names within a pair of pipes (). They don&#39;t need curly braces, unless you want to have multiple statements.|
Closure的参数是一对管道(|)中以逗号分隔的名称列表。不需要花括号，除非您想要有多个语句。<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn for_each_planet&lt;F&gt;(f: F)
    where F: Fn(&amp;&#39;static str)
{
    f(&quot;Earth&quot;);
    f(&quot;Mars&quot;);
    f(&quot;Jupiter&quot;);
}
 
fn main() {
    for_each_planet(|planet| println!(&quot;Hello, {}&quot;, planet));
}

// prints:
// Hello, Earth
// Hello, Mars
// Hello, Jupiter
</code><!--]--></pre><!--]--><p><!--[-->借用规则也适用与此<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn for_each_planet&lt;F&gt;(f: F)
    where F: Fn(&amp;&#39;static str)
{
    f(&quot;Earth&quot;);
    f(&quot;Mars&quot;);
    f(&quot;Jupiter&quot;);
}
 
fn main() {
    let greeting = String::from(&quot;Good to see you&quot;);
    for_each_planet(|planet| println!(&quot;{}, {}&quot;, greeting, planet));
    // our closure borrows `greeting`, so it cannot outlive it
}
</code><!--]--></pre><!--]--><p><!--[-->这个例子不能运行:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn for_each_planet&lt;F&gt;(f: F)
    where F: Fn(&amp;&#39;static str) + &#39;static // `F` must now have &quot;&#39;static&quot; lifetime
{
    f(&quot;Earth&quot;);
    f(&quot;Mars&quot;);
    f(&quot;Jupiter&quot;);
}

fn main() {
    let greeting = String::from(&quot;Good to see you&quot;);
    for_each_planet(|planet| println!(&quot;{}, {}&quot;, greeting, planet));
    // error: closure may outlive the current function, but it borrows
    // `greeting`, which is owned by the current function
}
</code><!--]--></pre><!--]--><p><!--[-->但这个可以:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let greeting = String::from(&quot;You&#39;re doing great&quot;);
    for_each_planet(move |planet| println!(&quot;{}, {}&quot;, greeting, planet));
    // `greeting` is no longer borrowed, it is *moved* into
    // the closure.
}
</code><!--]--></pre><!--]--><p><!--[-->An needs to be mutably borrowed to be called, so it can only be called once at a time.FnMut
<code class=""><!--[-->FnMut<!--]--></code> 需要可变地借用才能被调用，因此一次只能调用一次<!--]--></p><p><!--[-->这是合法的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(f: F)
    where F: Fn(i32) -&gt; i32
{
    println!(&quot;{}&quot;, f(f(2))); 
}
 
fn main() {
    foobar(|x| x * 2);
}

// output: 8
</code><!--]--></pre><!--]--><p><!--[-->而这不合法:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(mut f: F)
    where F: FnMut(i32) -&gt; i32
{
    println!(&quot;{}&quot;, f(f(2))); 
    // error: cannot borrow `f` as mutable more than once at a time
}
 
fn main() {
    foobar(|x| x * 2);
}
</code><!--]--></pre><!--]--><p><!--[-->这也是合法的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(mut f: F)
    where F: FnMut(i32) -&gt; i32
{
    let tmp = f(2);
    println!(&quot;{}&quot;, f(tmp)); 
}
 
fn main() {
    foobar(|x| x * 2);
}

// output: 8
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->FnMut<!--]--></code> 之所以存在，是因为一些闭包可变地借用本地变量<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(mut f: F)
    where F: FnMut(i32) -&gt; i32
{
    let tmp = f(2);
    println!(&quot;{}&quot;, f(tmp)); 
}
 
fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        x * acc
    });
}

// output: 24
</code><!--]--></pre><!--]--><p><!--[-->这些闭包不能被传递给期望的 Fn 函数:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(f: F)
    where F: Fn(i32) -&gt; i32
{
    println!(&quot;{}&quot;, f(f(2))); 
}
 
fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        // error: cannot assign to `acc`, as it is a
        // captured variable in a `Fn` closure.
        // the compiler suggests &quot;changing foobar
        // to accept closures that implement `FnMut`&quot;
        x * acc
    });
}
</code><!--]--></pre><!--]--><p><!--[-->FnOnce 闭包只能调用一次。它们之所以存在，是因为某些闭包移出了在捕获时被移动的变量<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(f: F)
    where F: FnOnce() -&gt; String
{
    println!(&quot;{}&quot;, f()); 
}
 
fn main() {
    let s = String::from(&quot;alright&quot;);
    foobar(move || s);
    // `s` was moved into our closure, and our
    // closures moves it to the caller by returning
    // it. Remember that `String` is not `Copy`.
}
</code><!--]--></pre><!--]--><p><!--[-->这是自然执行的，因为需要移动 FnOnce 闭包才能被调用。<!--]--></p><p><!--[-->所以这个例子是不合法的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(f: F)
    where F: FnOnce() -&gt; String
{
    println!(&quot;{}&quot;, f()); 
    println!(&quot;{}&quot;, f()); 
    // error: use of moved value: `f`
}
</code><!--]--></pre><!--]--><p><!--[-->而且，如果你需要说服我们的关闭确实移动 s，这也是非法的<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let s = String::from(&quot;alright&quot;);
    foobar(move || s);
    foobar(move || s);
    // use of moved value: `s`
}
</code><!--]--></pre><!--]--><p><!--[-->但这个是对的:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    let s = String::from(&quot;alright&quot;);
    foobar(|| s.clone());
    foobar(|| s.clone());
}
</code><!--]--></pre><!--]--><p><!--[-->带有两个参数的闭包:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn foobar&lt;F&gt;(x: i32, y: i32, is_greater: F)
    where F: Fn(i32, i32) -&gt; bool
{
    let (greater, smaller) = if is_greater(x, y) {
        (x, y)
    } else {
        (y, x)
    };
    println!(&quot;{} is greater than {}&quot;, greater, smaller);
}
 
fn main() {
    foobar(32, 64, |x, y| x &gt; y);
}
</code><!--]--></pre><!--]--><p><!--[-->省略所有参数的闭包:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    foobar(32, 64, |_, _| panic!(&quot;Comparing is futile!&quot;));
}
</code><!--]--></pre><!--]--><p><!--[-->Here&#39;s a slightly worrying closure:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn countdown&lt;F&gt;(count: usize, tick: F)
    where F: Fn(usize)
{
    for i in (1..=count).rev() {
        tick(i);
    }
}
 
fn main() {
    countdown(3, |i| println!(&quot;tick {}...&quot;, i));
}

// output:
// tick 3...
// tick 2...
// tick 1...
</code><!--]--></pre><!--]--><p><!--[-->And here&#39;s a toilet closure:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    countdown(3, |_| ());
}
</code><!--]--></pre><!--]--><p><!--[-->这样叫是因为<code class=""><!--[-->|_| ()<!--]--></code>看起来像厕所<!--]--></p><p><!--[-->任何可迭代的内容都可以在 <code class=""><!--[-->for in<!--]--></code> 循环中使用。<!--]--></p><p><!--[-->We&#39;ve just seen a range being used, but it also works with a <Vec></Vec>
我们之前看了range的使用，也可以用于Vec<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    for i in vec![52, 49, 21] {
        println!(&quot;I like the number {}&quot;, i);
    }
}
</code><!--]--></pre><!--]--><p><!--[-->或用于切片:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    for i in &amp;[52, 49, 21] {
        println!(&quot;I like the number {}&quot;, i);
    }
}

// output:
// I like the number 52
// I like the number 49
// I like the number 21
</code><!--]--></pre><!--]--><p><!--[-->或一个实际的迭代器(actual iterator)<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    // note: `&amp;str` also has a `.bytes()` iterator.
    // Rust&#39;s `char` type is a &quot;Unicode scalar value&quot;
    for c in &quot;rust&quot;.chars() {
        println!(&quot;Give me a {}&quot;, c);
    }
}

// output:
// Give me a r
// Give me a u
// Give me a s
// Give me a t
</code><!--]--></pre><!--]--><p><!--[-->即使迭代项被过滤、映射和扁平化<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn main() {
    for c in &quot;SuRPRISE INbOUND&quot;
        .chars()
        .filter(|c| c.is_lowercase())
        .flat_map(|c| c.to_uppercase())
    {
        print!(&quot;{}&quot;, c);
    }
    println!();
}

// output: UB
</code><!--]--></pre><!--]--><p><!--[-->你可以从函数返回一个闭包<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn make_tester(answer: String) -&gt; impl Fn(&amp;str) -&gt; bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    // you can use `.into()` to perform conversions
    // between various types, here `&amp;&#39;static str` and `String`
    let test = make_tester(&quot;hunter2&quot;.into());
    println!(&quot;{}&quot;, test(&quot;******&quot;));
    println!(&quot;{}&quot;, test(&quot;hunter2&quot;));
}
</code><!--]--></pre><!--]--><p><!--[-->你甚至可以将一个对函数参数的引用移动到它返回的闭包中:<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn make_tester&lt;&#39;a&gt;(answer: &amp;&#39;a str) -&gt; impl Fn(&amp;str) -&gt; bool + &#39;a {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    let test = make_tester(&quot;hunter2&quot;);
    println!(&quot;{}&quot;, test(&quot;*******&quot;));
    println!(&quot;{}&quot;, test(&quot;hunter2&quot;));
}

// output:
// false
// true
</code><!--]--></pre><!--]--><p><!--[-->或者略掉生命周期<!--]--></p><!--[--><pre class="language-rust" style=""><!--[--><code>fn make_tester(answer: &amp;str) -&gt; impl Fn(&amp;str) -&gt; bool + &#39;_ {
    move |challenge| {
        challenge == answer
    }
}
</code><!--]--></pre><!--]--></div><hr><!----></article><!--]--></main><!--]--></div></div></div><div id="teleports"></div><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__">[["ShallowReactive",1],{"prerenderedAt":2,"data":3,"state":2996,"once":2998,"_errors":2999,"serverRendered":3002,"path":3003},1758123898551,["ShallowReactive",4],{"content-query-OLutn989hy":5},{"_path":6,"_dir":7,"_draft":8,"_partial":8,"_locale":9,"title":10,"description":11,"subtitle":12,"index":13,"date":14,"lunar_date":15,"year":16,"month":17,"month_en":18,"day":19,"tag":20,"tag_en":21,"cover":22,"categories":23,"body":24,"_type":2990,"_id":2991,"_source":2992,"_file":2993,"_stem":2994,"_extension":2995},"/essay/32.(翻译)半小时学习rust","essay",false,"","（翻译）半小时学习rust","https://fasterthanli.me/articles/a-half-hour-to-learn-rust\n本文为粗略的翻译\n为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？","A half-hour to learn Rust",32,"2023-04-10","闰二二十","2023","04","Apr","10","技术","TECH","/img/rabbit/032.jpg","rust",{"type":25,"children":26,"toc":2986},"root",[27,52,57,62,66,78,89,94,103,114,123,127,136,141,150,155,164,175,184,189,198,203,212,241,246,255,260,269,274,283,288,297,309,318,323,332,337,346,359,368,381,390,403,412,417,426,431,440,445,454,465,474,485,494,507,516,521,530,543,572,600,609,622,631,636,645,659,672,681,686,695,708,717,722,731,767,778,787,792,801,806,815,820,829,834,842,847,856,861,870,887,896,901,910,915,924,936,945,950,959,964,973,978,987,992,1001,1012,1021,1032,1041,1046,1066,1071,1080,1085,1094,1099,1108,1113,1122,1127,1148,1157,1162,1171,1191,1200,1205,1214,1227,1236,1241,1250,1262,1271,1276,1285,1290,1299,1304,1313,1318,1327,1332,1341,1354,1363,1368,1377,1382,1391,1403,1412,1420,1425,1434,1439,1448,1453,1465,1474,1487,1492,1501,1506,1515,1520,1529,1558,1571,1580,1585,1594,1605,1614,1640,1649,1659,1668,1678,1687,1692,1697,1706,1711,1720,1725,1734,1739,1748,1753,1762,1767,1776,1790,1795,1804,1809,1822,1835,1844,1849,1858,1863,1872,1877,1886,1891,1900,1905,1914,1925,1934,1939,1948,1953,1962,1975,1988,1997,2009,2018,2046,2066,2075,2080,2089,2094,2103,2108,2117,2138,2146,2180,2185,2194,2230,2243,2256,2265,2270,2279,2284,2293,2298,2307,2320,2325,2334,2346,2351,2360,2365,2374,2384,2393,2411,2420,2425,2434,2444,2453,2464,2473,2478,2487,2500,2509,2521,2530,2535,2544,2553,2596,2601,2610,2615,2624,2629,2638,2643,2652,2664,2669,2678,2683,2692,2697,2706,2716,2725,2730,2739,2744,2753,2758,2763,2772,2777,2786,2791,2800,2805,2814,2819,2828,2833,2842,2847,2856,2869,2882,2893,2902,2907,2916,2921,2930,2935,2944,2949,2958,2963,2972,2977],{"type":28,"tag":29,"props":30,"children":31},"element","p",{},[32,41,45,47,50],{"type":28,"tag":33,"props":34,"children":38},"a",{"href":35,"rel":36},"https://fasterthanli.me/articles/a-half-hour-to-learn-rust",[37],"nofollow",[39],{"type":40,"value":35},"text",{"type":28,"tag":42,"props":43,"children":44},"br",{},[],{"type":40,"value":46},"\n本文为粗略的翻译",{"type":28,"tag":42,"props":48,"children":49},{},[],{"type":40,"value":51},"\n为了提高编程语言的熟练度，就必须要大量阅读有关资料。但是，如果你不知道它的意思，你怎么能大量阅读呢？",{"type":28,"tag":29,"props":53,"children":54},{},[55],{"type":40,"value":56},"在本文中，我将不会关注于一两个概念，而是试着通过尽可能多的Rust 代码段，解释其中的关键字和符号的含义。",{"type":28,"tag":29,"props":58,"children":59},{},[60],{"type":40,"value":61},"准备好了吗？让我们开始吧！",{"type":28,"tag":63,"props":64,"children":65},"hr",{},[],{"type":28,"tag":29,"props":67,"children":68},{},[69,76],{"type":28,"tag":70,"props":71,"children":73},"code",{"className":72},[],[74],{"type":40,"value":75},"let",{"type":40,"value":77},"引入了变量绑定(variable binding)",{"type":28,"tag":79,"props":80,"children":84},"pre",{"className":81,"code":83,"language":23,"meta":9},[82],"language-rust","let x;  // 声明 \"x\"\nx = 42; // 将 42 分配给 \"x\"\n",[85],{"type":28,"tag":70,"props":86,"children":87},{"__ignoreMap":9},[88],{"type":40,"value":83},{"type":28,"tag":29,"props":90,"children":91},{},[92],{"type":40,"value":93},"也可以写成一行",{"type":28,"tag":79,"props":95,"children":98},{"className":96,"code":97,"language":23,"meta":9},[82],"let x = 42;\n",[99],{"type":28,"tag":70,"props":100,"children":101},{"__ignoreMap":9},[102],{"type":40,"value":97},{"type":28,"tag":29,"props":104,"children":105},{},[106,108],{"type":40,"value":107},"您可以显式地指定变量的类型，用冒号表示类型注释:",{"type":28,"tag":70,"props":109,"children":111},{"className":110},[],[112],{"type":40,"value":113},":",{"type":28,"tag":79,"props":115,"children":118},{"className":116,"code":117,"language":23,"meta":9},[82],"let x: i32; // i32是一个有符号的32位整数\nx = 42;\n// 有符号整数有: i8, i16, i32, i64, i128\n// 无符号整数有: u8, u16, u32, u64, u128 \n",[119],{"type":28,"tag":70,"props":120,"children":121},{"__ignoreMap":9},[122],{"type":40,"value":117},{"type":28,"tag":29,"props":124,"children":125},{},[126],{"type":40,"value":93},{"type":28,"tag":79,"props":128,"children":131},{"className":129,"code":130,"language":23,"meta":9},[82],"let x: i32 = 42;\n",[132],{"type":28,"tag":70,"props":133,"children":134},{"__ignoreMap":9},[135],{"type":40,"value":130},{"type":28,"tag":29,"props":137,"children":138},{},[139],{"type":40,"value":140},"如果您声明一个变量,之后再初始化，编译器将会阻止你初始化之前使用这个变量",{"type":28,"tag":79,"props":142,"children":145},{"className":143,"code":144,"language":23,"meta":9},[82],"let x;\nfoobar(x); // error: borrow of possibly-uninitialized variable: `x`\n// 借用可能未初始化的变量: `x`\nx = 42;\n",[146],{"type":28,"tag":70,"props":147,"children":148},{"__ignoreMap":9},[149],{"type":40,"value":144},{"type":28,"tag":29,"props":151,"children":152},{},[153],{"type":40,"value":154},"正确的写法是这样:",{"type":28,"tag":79,"props":156,"children":159},{"className":157,"code":158,"language":23,"meta":9},[82],"let x;\nx = 42;\nfoobar(x); //  `x` 的类型将会在这被推断出来\n",[160],{"type":28,"tag":70,"props":161,"children":162},{"__ignoreMap":9},[163],{"type":40,"value":158},{"type":28,"tag":29,"props":165,"children":166},{},[167,169],{"type":40,"value":168},"下划线是一个特殊的变量名,更确切地说是 “空缺名”,意思就是扔掉一些东西:",{"type":28,"tag":70,"props":170,"children":172},{"className":171},[],[173],{"type":40,"value":174},"_",{"type":28,"tag":79,"props":176,"children":179},{"className":177,"code":178,"language":23,"meta":9},[82],"// 42是常数，所以无事发生\nlet _ = 42;\n\n// 调用 `get_thing` 函数但是舍弃了扔掉了的结果\nlet _ = get_thing();\n",[180],{"type":28,"tag":70,"props":181,"children":182},{"__ignoreMap":9},[183],{"type":40,"value":178},{"type":28,"tag":29,"props":185,"children":186},{},[187],{"type":40,"value":188},"以下划线开头的变量名是普通名称，只是编译器不会警告它们不被使用:",{"type":28,"tag":79,"props":190,"children":193},{"className":191,"code":192,"language":23,"meta":9},[82],"// 变量声明但不使用会被编译器警告\n// 在变量名前面加下划线可以去掉警告\nlet _x = 42;\n",[194],{"type":28,"tag":70,"props":195,"children":196},{"__ignoreMap":9},[197],{"type":40,"value":192},{"type":28,"tag":29,"props":199,"children":200},{},[201],{"type":40,"value":202},"可以对同一个变量名多次绑定-你可以掩盖(shadow)变量绑定",{"type":28,"tag":79,"props":204,"children":207},{"className":205,"code":206,"language":23,"meta":9},[82],"let x = 13;\nlet x = x + 3;\n// 在这之后使用 `x` 指代的都是第二个 `x`\n// 第一个  `x` 已不存在.（关于这点本人有补充，见下）\n",[208],{"type":28,"tag":70,"props":209,"children":210},{"__ignoreMap":9},[211],{"type":40,"value":206},{"type":28,"tag":213,"props":214,"children":215},"blockquote",{},[216],{"type":28,"tag":29,"props":217,"children":218},{},[219,221,227,229,234,236],{"type":40,"value":220},"译者注: 掩盖(shadowing)是在作用域之内掩盖掉原有的变量名，在作用域结束之后掩盖失效，因为此处两个 ",{"type":28,"tag":70,"props":222,"children":224},{"className":223},[],[225],{"type":40,"value":226},"x",{"type":40,"value":228}," 作用域相同，所以第二个",{"type":28,"tag":70,"props":230,"children":232},{"className":231},[],[233],{"type":40,"value":226},{"type":40,"value":235},"会一直掩盖第一个 ",{"type":28,"tag":70,"props":237,"children":239},{"className":238},[],[240],{"type":40,"value":226},{"type":28,"tag":29,"props":242,"children":243},{},[244],{"type":40,"value":245},"Rust 有元组(tuples)，您可以将其视为“不同类型的值的固定长度集合”。",{"type":28,"tag":79,"props":247,"children":250},{"className":248,"code":249,"language":23,"meta":9},[82],"let pair = ('a', 17);\npair.0; // 这是 'a'\npair.1; // 这是 17\n",[251],{"type":28,"tag":70,"props":252,"children":253},{"__ignoreMap":9},[254],{"type":40,"value":249},{"type":28,"tag":29,"props":256,"children":257},{},[258],{"type":40,"value":259},"如果想添加类型注释:",{"type":28,"tag":79,"props":261,"children":264},{"className":262,"code":263,"language":23,"meta":9},[82],"let pair: (char, i32) = ('a', 17);\n",[265],{"type":28,"tag":70,"props":266,"children":267},{"__ignoreMap":9},[268],{"type":40,"value":263},{"type":28,"tag":29,"props":270,"children":271},{},[272],{"type":40,"value":273},"元组在执行任务时可以被解构(destructured)，这意味着它们被分解为独立的字段:",{"type":28,"tag":79,"props":275,"children":278},{"className":276,"code":277,"language":23,"meta":9},[82],"let (some_char, some_int) = ('a', 17);\n// 现在 some_char是 'a'，some_int是 17\n",[279],{"type":28,"tag":70,"props":280,"children":281},{"__ignoreMap":9},[282],{"type":40,"value":277},{"type":28,"tag":29,"props":284,"children":285},{},[286],{"type":40,"value":287},"这点在函数返回元组时特别有用:",{"type":28,"tag":79,"props":289,"children":292},{"className":290,"code":291,"language":23,"meta":9},[82],"let (left, right) = slice.split_at(middle);\n",[293],{"type":28,"tag":70,"props":294,"children":295},{"__ignoreMap":9},[296],{"type":40,"value":291},{"type":28,"tag":29,"props":298,"children":299},{},[300,302,307],{"type":40,"value":301},"当然，在解构元组时，可以用",{"type":28,"tag":70,"props":303,"children":305},{"className":304},[],[306],{"type":40,"value":174},{"type":40,"value":308},"来丢弃它的一部分",{"type":28,"tag":79,"props":310,"children":313},{"className":311,"code":312,"language":23,"meta":9},[82],"let (_, right) = slice.split_at(middle);\n",[314],{"type":28,"tag":70,"props":315,"children":316},{"__ignoreMap":9},[317],{"type":40,"value":312},{"type":28,"tag":29,"props":319,"children":320},{},[321],{"type":40,"value":322},"分号表示语句的结尾:",{"type":28,"tag":79,"props":324,"children":327},{"className":325,"code":326,"language":23,"meta":9},[82],"let x = 3;\nlet y = 5;\nlet z = y + x;\n",[328],{"type":28,"tag":70,"props":329,"children":330},{"__ignoreMap":9},[331],{"type":40,"value":326},{"type":28,"tag":29,"props":333,"children":334},{},[335],{"type":40,"value":336},"这意味着语句可以跨越多行",{"type":28,"tag":79,"props":338,"children":341},{"className":339,"code":340,"language":23,"meta":9},[82],"let x = vec![1, 2, 3, 4, 5, 6, 7, 8]\n    .iter()\n    .map(|x| x + 3)\n    .fold(0, |x, y| x + y);\n",[342],{"type":28,"tag":70,"props":343,"children":344},{"__ignoreMap":9},[345],{"type":40,"value":340},{"type":28,"tag":29,"props":347,"children":348},{},[349,351,357],{"type":40,"value":350},"(我们待会儿再讨论它们的意思)\n",{"type":28,"tag":70,"props":352,"children":354},{"className":353},[],[355],{"type":40,"value":356},"fn",{"type":40,"value":358},"声明一个没有返回值的函数",{"type":28,"tag":79,"props":360,"children":363},{"className":361,"code":362,"language":23,"meta":9},[82],"fn greet() {\n    println!(\"Hi there!\");\n}\n",[364],{"type":28,"tag":70,"props":365,"children":366},{"__ignoreMap":9},[367],{"type":40,"value":362},{"type":28,"tag":29,"props":369,"children":370},{},[371,373,379],{"type":40,"value":372},"下面的函数返回32位有符号整数，箭头",{"type":28,"tag":70,"props":374,"children":376},{"className":375},[],[377],{"type":40,"value":378},"->",{"type":40,"value":380},"表示它的返回类型:",{"type":28,"tag":79,"props":382,"children":385},{"className":383,"code":384,"language":23,"meta":9},[82],"fn fair_dice_roll() -> i32 {\n    4\n}\n",[386],{"type":28,"tag":70,"props":387,"children":388},{"__ignoreMap":9},[389],{"type":40,"value":384},{"type":28,"tag":29,"props":391,"children":392},{},[393,395,401],{"type":40,"value":394},"一对花括号",{"type":28,"tag":70,"props":396,"children":398},{"className":397},[],[399],{"type":40,"value":400},"{}",{"type":40,"value":402},"声明一个代码块(block)，它有自己的作用域",{"type":28,"tag":79,"props":404,"children":407},{"className":405,"code":406,"language":23,"meta":9},[82],"// This prints \"in\", then \"out\"\nfn main() {\n    let x = \"out\";\n    {\n        // this is a different `x`\n        let x = \"in\";\n        println!(\"{}\", x);\n    }\n    println!(\"{}\", x);\n}\n",[408],{"type":28,"tag":70,"props":409,"children":410},{"__ignoreMap":9},[411],{"type":40,"value":406},{"type":28,"tag":29,"props":413,"children":414},{},[415],{"type":40,"value":416},"代码块也是表达式，可以计算为(evaluate)一个值",{"type":28,"tag":79,"props":418,"children":421},{"className":419,"code":420,"language":23,"meta":9},[82],"let x = 42;\n// 两者等价\nlet x = { 42 };\n",[422],{"type":28,"tag":70,"props":423,"children":424},{"__ignoreMap":9},[425],{"type":40,"value":420},{"type":28,"tag":29,"props":427,"children":428},{},[429],{"type":40,"value":430},"在一个代码块中，可以有多个语句",{"type":28,"tag":79,"props":432,"children":435},{"className":433,"code":434,"language":23,"meta":9},[82],"let x = {\n    let y = 1; // first statement\n    let z = 2; // second statement\n    y + z // 这是代码块的结尾 - 整个代码块返回的值\n};\n",[436],{"type":28,"tag":70,"props":437,"children":438},{"__ignoreMap":9},[439],{"type":40,"value":434},{"type":28,"tag":29,"props":441,"children":442},{},[443],{"type":40,"value":444},"所以省略函数末尾语句的分号等价于return语句",{"type":28,"tag":79,"props":446,"children":449},{"className":447,"code":448,"language":23,"meta":9},[82],"fn fair_dice_roll() -> i32 {\n    return 4;\n}\n\nfn fair_dice_roll() -> i32 {\n    4\n}\n",[450],{"type":28,"tag":70,"props":451,"children":452},{"__ignoreMap":9},[453],{"type":40,"value":448},{"type":28,"tag":29,"props":455,"children":456},{},[457,463],{"type":28,"tag":70,"props":458,"children":460},{"className":459},[],[461],{"type":40,"value":462},"if",{"type":40,"value":464}," 条件语句也是表达式",{"type":28,"tag":79,"props":466,"children":469},{"className":467,"code":468,"language":23,"meta":9},[82],"fn fair_dice_roll() -> i32 {\n    if feeling_lucky {\n        6\n    } else {\n        4\n    }\n}\n",[470],{"type":28,"tag":70,"props":471,"children":472},{"__ignoreMap":9},[473],{"type":40,"value":468},{"type":28,"tag":29,"props":475,"children":476},{},[477,483],{"type":28,"tag":70,"props":478,"children":480},{"className":479},[],[481],{"type":40,"value":482},"match",{"type":40,"value":484},"语句也是表达式",{"type":28,"tag":79,"props":486,"children":489},{"className":487,"code":488,"language":23,"meta":9},[82],"fn fair_dice_roll() -> i32 {\n    match feeling_lucky {\n        true => 6,\n        false => 4,\n    }\n}\n",[490],{"type":28,"tag":70,"props":491,"children":492},{"__ignoreMap":9},[493],{"type":40,"value":488},{"type":28,"tag":29,"props":495,"children":496},{},[497,499,505],{"type":40,"value":498},"符号点",{"type":28,"tag":70,"props":500,"children":502},{"className":501},[],[503],{"type":40,"value":504},".",{"type":40,"value":506},"通常用于访问值的字段:",{"type":28,"tag":79,"props":508,"children":511},{"className":509,"code":510,"language":23,"meta":9},[82],"let a = (10, 20);\na.0; // this is 10\n\nlet amos = get_some_struct();\namos.nickname; // this is \"fasterthanlime\"\n",[512],{"type":28,"tag":70,"props":513,"children":514},{"__ignoreMap":9},[515],{"type":40,"value":510},{"type":28,"tag":29,"props":517,"children":518},{},[519],{"type":40,"value":520},"或者调用值的某个方法:",{"type":28,"tag":79,"props":522,"children":525},{"className":523,"code":524,"language":23,"meta":9},[82],"let nick = \"fasterthanlime\";\nnick.len(); // this is 14\n",[526],{"type":28,"tag":70,"props":527,"children":528},{"__ignoreMap":9},[529],{"type":40,"value":524},{"type":28,"tag":29,"props":531,"children":532},{},[533,535,541],{"type":40,"value":534},"双冒号",{"type":28,"tag":70,"props":536,"children":538},{"className":537},[],[539],{"type":40,"value":540},"::",{"type":40,"value":542},"类似，但是它用于命名空间",{"type":28,"tag":29,"props":544,"children":545},{},[546,548,554,556,562,564,570],{"type":40,"value":547},"在这个例子中，",{"type":28,"tag":70,"props":549,"children":551},{"className":550},[],[552],{"type":40,"value":553},"std",{"type":40,"value":555},"是一个crate,",{"type":28,"tag":70,"props":557,"children":559},{"className":558},[],[560],{"type":40,"value":561},"cmd",{"type":40,"value":563},"是一个模块(module),",{"type":28,"tag":70,"props":565,"children":567},{"className":566},[],[568],{"type":40,"value":569},"min",{"type":40,"value":571},"是一个函数",{"type":28,"tag":213,"props":573,"children":574},{},[575,580],{"type":28,"tag":29,"props":576,"children":577},{},[578],{"type":40,"value":579},"译者注:package、crate、module概念不要以其他语言的概念先入为主，这里简要提一下，不作展开",{"type":28,"tag":581,"props":582,"children":583},"ol",{},[584,590,595],{"type":28,"tag":585,"props":586,"children":587},"li",{},[588],{"type":40,"value":589},"package为项目，就是cargo new创建的项目就称为package",{"type":28,"tag":585,"props":591,"children":592},{},[593],{"type":40,"value":594},"crate是一个独立的编译单元，又分为binary(二进制) crate和library crate，硬要翻译这个名词的话叫做分隔箱比较恰当。\nbinary crate的充要条件是有src/main.rs\nlibrary crate的充要条件是有src/lib.rs",{"type":28,"tag":585,"props":596,"children":597},{},[598],{"type":40,"value":599},"module是模块，用于内部代码的组织，可以控制作用域及私有性",{"type":28,"tag":79,"props":601,"children":604},{"className":602,"code":603,"language":23,"meta":9},[82],"let least = std::cmp::min(3, 8); // this is 3\n",[605],{"type":28,"tag":70,"props":606,"children":607},{"__ignoreMap":9},[608],{"type":40,"value":603},{"type":28,"tag":29,"props":610,"children":611},{},[612,614,620],{"type":40,"value":613},"use directives can be used to \"bring in scope\" names from other namespace:\n",{"type":28,"tag":70,"props":615,"children":617},{"className":616},[],[618],{"type":40,"value":619},"use",{"type":40,"value":621},"关键字用来引入其他命名空间的作用域里的内容，例如函数",{"type":28,"tag":79,"props":623,"children":626},{"className":624,"code":625,"language":23,"meta":9},[82],"use std::cmp::min;\nlet least = min(7, 1); // this is 1\n",[627],{"type":28,"tag":70,"props":628,"children":629},{"__ignoreMap":9},[630],{"type":40,"value":625},{"type":28,"tag":29,"props":632,"children":633},{},[634],{"type":40,"value":635},"在 use 关键字中，花括号还有另一个意思: 它们来源相同\n如果我们想同时导入 min 和 max，我们可以执行以下任何操作:",{"type":28,"tag":79,"props":637,"children":640},{"className":638,"code":639,"language":23,"meta":9},[82],"// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n",[641],{"type":28,"tag":70,"props":642,"children":643},{"__ignoreMap":9},[644],{"type":40,"value":639},{"type":28,"tag":213,"props":646,"children":647},{},[648],{"type":28,"tag":29,"props":649,"children":650},{},[651,653],{"type":40,"value":652},"类似于javascript的",{"type":28,"tag":70,"props":654,"children":656},{"className":655},[],[657],{"type":40,"value":658},"import {min,max} from 'xxx'",{"type":28,"tag":29,"props":660,"children":661},{},[662,664,670],{"type":40,"value":663},"A wildcard () lets you import every symbol from a namespace:*\n通配符",{"type":28,"tag":70,"props":665,"children":667},{"className":666},[],[668],{"type":40,"value":669},"*",{"type":40,"value":671},"允许你从命名空间导入所有内容",{"type":28,"tag":79,"props":673,"children":676},{"className":674,"code":675,"language":23,"meta":9},[82],"// this brings `min` and `max` in scope, and many other things\nuse std::cmp::*;\n",[677],{"type":28,"tag":70,"props":678,"children":679},{"__ignoreMap":9},[680],{"type":40,"value":675},{"type":28,"tag":29,"props":682,"children":683},{},[684],{"type":40,"value":685},"类型也命名空间，类型的方法可以作为常规函数调用:",{"type":28,"tag":79,"props":687,"children":690},{"className":688,"code":689,"language":23,"meta":9},[82],"let x = \"amos\".len(); // this is 4\nlet x = str::len(\"amos\"); // this is also 4\n",[691],{"type":28,"tag":70,"props":692,"children":693},{"__ignoreMap":9},[694],{"type":40,"value":689},{"type":28,"tag":29,"props":696,"children":697},{},[698,700,706],{"type":40,"value":699},"str is a primitive type, but many non-primitive types are also in scope by default.\n",{"type":28,"tag":70,"props":701,"children":703},{"className":702},[],[704],{"type":40,"value":705},"str",{"type":40,"value":707},"是原始类型，但也有许多非原始类型",{"type":28,"tag":79,"props":709,"children":712},{"className":710,"code":711,"language":23,"meta":9},[82],"// `Vec` is a regular struct, not a primitive type\nlet v = Vec::new();\n\n// this is exactly the same code, but with the *full* path to `Vec`\nlet v = std::vec::Vec::new();\n",[713],{"type":28,"tag":70,"props":714,"children":715},{"__ignoreMap":9},[716],{"type":40,"value":711},{"type":28,"tag":29,"props":718,"children":719},{},[720],{"type":40,"value":721},"这会正常编译，因为Rust会在每个模块的开头插入:",{"type":28,"tag":79,"props":723,"children":726},{"className":724,"code":725,"language":23,"meta":9},[82],"use std::prelude::v1::*;\n",[727],{"type":28,"tag":70,"props":728,"children":729},{"__ignoreMap":9},[730],{"type":40,"value":725},{"type":28,"tag":29,"props":732,"children":733},{},[734,736,742,744,750,751,757,759,765],{"type":40,"value":735},"(这引入了很多东西，",{"type":28,"tag":70,"props":737,"children":739},{"className":738},[],[740],{"type":40,"value":741},"Vec",{"type":40,"value":743},", ",{"type":28,"tag":70,"props":745,"children":747},{"className":746},[],[748],{"type":40,"value":749},"String",{"type":40,"value":743},{"type":28,"tag":70,"props":752,"children":754},{"className":753},[],[755],{"type":40,"value":756},"Option",{"type":40,"value":758}," ,",{"type":28,"tag":70,"props":760,"children":762},{"className":761},[],[763],{"type":40,"value":764},"Result",{"type":40,"value":766}," 等等)",{"type":28,"tag":29,"props":768,"children":769},{},[770,776],{"type":28,"tag":70,"props":771,"children":773},{"className":772},[],[774],{"type":40,"value":775},"struct",{"type":40,"value":777},"关键字用于声明结构体",{"type":28,"tag":79,"props":779,"children":782},{"className":780,"code":781,"language":23,"meta":9},[82],"struct Vec2 {\n    x: f64, // 64-bit floating point, aka \"double precision\"\n    y: f64,\n}\n",[783],{"type":28,"tag":70,"props":784,"children":785},{"__ignoreMap":9},[786],{"type":40,"value":781},{"type":28,"tag":29,"props":788,"children":789},{},[790],{"type":40,"value":791},"使用结构体字面量初始化",{"type":28,"tag":79,"props":793,"children":796},{"className":794,"code":795,"language":23,"meta":9},[82],"Rust code\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n// the order does not matter, only the names do\n",[797],{"type":28,"tag":70,"props":798,"children":799},{"__ignoreMap":9},[800],{"type":40,"value":795},{"type":28,"tag":29,"props":802,"children":803},{},[804],{"type":40,"value":805},"用另一个结构体初始化剩余字段的快捷方式:",{"type":28,"tag":79,"props":807,"children":810},{"className":808,"code":809,"language":23,"meta":9},[82],"let v3 = Vec2 {\n    x: 14.0,\n    ..v2\n    // 只能在最后使用，后面不能有逗号\n};\n",[811],{"type":28,"tag":70,"props":812,"children":813},{"__ignoreMap":9},[814],{"type":40,"value":809},{"type":28,"tag":29,"props":816,"children":817},{},[818],{"type":40,"value":819},"注意，剩余字段前面不加任何东西时可以表示所有字段:",{"type":28,"tag":79,"props":821,"children":824},{"className":822,"code":823,"language":23,"meta":9},[82],"let v4 = Vec2 { ..v3 };\n",[825],{"type":28,"tag":70,"props":826,"children":827},{"__ignoreMap":9},[828],{"type":40,"value":823},{"type":28,"tag":29,"props":830,"children":831},{},[832],{"type":40,"value":833},"结构体可以像元组一样被解构",{"type":28,"tag":79,"props":835,"children":837},{"className":836,"code":291,"language":23,"meta":9},[82],[838],{"type":28,"tag":70,"props":839,"children":840},{"__ignoreMap":9},[841],{"type":40,"value":291},{"type":28,"tag":29,"props":843,"children":844},{},[845],{"type":40,"value":846},"像这样",{"type":28,"tag":79,"props":848,"children":851},{"className":849,"code":850,"language":23,"meta":9},[82],"let v = Vec2 { x: 3.0, y: 6.0 };\nlet Vec2 { x, y } = v;\n// `x` 为 3.0, `y` 为 `6.0`\n",[852],{"type":28,"tag":70,"props":853,"children":854},{"__ignoreMap":9},[855],{"type":40,"value":850},{"type":28,"tag":29,"props":857,"children":858},{},[859],{"type":40,"value":860},"还有这样",{"type":28,"tag":79,"props":862,"children":865},{"className":863,"code":864,"language":23,"meta":9},[82],"let Vec2 { x, .. } = v;\n// 舍弃了 `v.y`\n",[866],{"type":28,"tag":70,"props":867,"children":868},{"__ignoreMap":9},[869],{"type":40,"value":864},{"type":28,"tag":29,"props":871,"children":872},{},[873,878,880,885],{"type":28,"tag":70,"props":874,"children":876},{"className":875},[],[877],{"type":40,"value":75},{"type":40,"value":879},"模式匹配可以作为",{"type":28,"tag":70,"props":881,"children":883},{"className":882},[],[884],{"type":40,"value":462},{"type":40,"value":886},"的判断条件",{"type":28,"tag":79,"props":888,"children":891},{"className":889,"code":890,"language":23,"meta":9},[82],"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    if let Number { odd: true, value } = n {\n        println!(\"Odd number: {}\", value);\n    } else if let Number { odd: false, value } = n {\n        println!(\"Even number: {}\", value);\n    }\n}\n\n// this prints:\n// Odd number: 1\n// Even number: 2\n",[892],{"type":28,"tag":70,"props":893,"children":894},{"__ignoreMap":9},[895],{"type":40,"value":890},{"type":28,"tag":29,"props":897,"children":898},{},[899],{"type":40,"value":900},"match选择支也是模式匹配，类似与 if let",{"type":28,"tag":79,"props":902,"children":905},{"className":903,"code":904,"language":23,"meta":9},[82],"fn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } => println!(\"Odd number: {}\", value),\n        Number { odd: false, value } => println!(\"Even number: {}\", value),\n    }\n}\n\n// this prints the same as before\n",[906],{"type":28,"tag":70,"props":907,"children":908},{"__ignoreMap":9},[909],{"type":40,"value":904},{"type":28,"tag":29,"props":911,"children":912},{},[913],{"type":40,"value":914},"match必须是详尽的，即必须至少有一个选择支能够匹配上",{"type":28,"tag":79,"props":916,"children":919},{"className":917,"code":918,"language":23,"meta":9},[82],"fn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } => println!(\"One\"),\n        Number { value: 2, .. } => println!(\"Two\"),\n        Number { value, .. } => println!(\"{}\", value),\n        // if that last arm didn't exist, we would get a compile-time error\n    }\n}\n",[920],{"type":28,"tag":70,"props":921,"children":922},{"__ignoreMap":9},[923],{"type":40,"value":918},{"type":28,"tag":29,"props":925,"children":926},{},[927,929,934],{"type":40,"value":928},"如果很难穷尽所有情形, 可以使用下划线",{"type":28,"tag":70,"props":930,"children":932},{"className":931},[],[933],{"type":40,"value":174},{"type":40,"value":935},"匹配剩下的所有情形",{"type":28,"tag":79,"props":937,"children":940},{"className":938,"code":939,"language":23,"meta":9},[82],"fn print_number(n: Number) {\n    match n.value {\n        1 => println!(\"One\"),\n        2 => println!(\"Two\"),\n        _ => println!(\"{}\", n.value),\n    }\n}\n",[941],{"type":28,"tag":70,"props":942,"children":943},{"__ignoreMap":9},[944],{"type":40,"value":939},{"type":28,"tag":29,"props":946,"children":947},{},[948],{"type":40,"value":949},"你可以声明你自己的类型的方法",{"type":28,"tag":79,"props":951,"children":954},{"className":952,"code":953,"language":23,"meta":9},[82],"struct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -> bool {\n        self.value > 0\n    }\n}\n",[955],{"type":28,"tag":70,"props":956,"children":957},{"__ignoreMap":9},[958],{"type":40,"value":953},{"type":28,"tag":29,"props":960,"children":961},{},[962],{"type":40,"value":963},"然后普通地使用",{"type":28,"tag":79,"props":965,"children":968},{"className":966,"code":967,"language":23,"meta":9},[82],"fn main() {\n    let minus_two = Number {\n        odd: false,\n        value: -2,\n    };\n    println!(\"positive? {}\", minus_two.is_strictly_positive());\n    // this prints \"positive? false\"\n}\n",[969],{"type":28,"tag":70,"props":970,"children":971},{"__ignoreMap":9},[972],{"type":40,"value":967},{"type":28,"tag":29,"props":974,"children":975},{},[976],{"type":40,"value":977},"Variable bindings are immutable by default, which means their interior can't be mutated:\n变量绑定在默认情况下是不可变的，这意味着它们的内部不能变化",{"type":28,"tag":79,"props":979,"children":982},{"className":980,"code":981,"language":23,"meta":9},[82],"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n.odd = false; // error: cannot assign to `n.odd`,\n                   // as `n` is not declared to be mutable\n}\n",[983],{"type":28,"tag":70,"props":984,"children":985},{"__ignoreMap":9},[986],{"type":40,"value":981},{"type":28,"tag":29,"props":988,"children":989},{},[990],{"type":40,"value":991},"这也意味着该变量不能被再次分配",{"type":28,"tag":79,"props":993,"children":996},{"className":994,"code":995,"language":23,"meta":9},[82],"fn main() {\n    let n = Number {\n        odd: true,\n        value: 17,\n    };\n    n = Number {\n        odd: false,\n        value: 22,\n    }; // error: cannot assign twice to immutable variable `n`\n}\n",[997],{"type":28,"tag":70,"props":998,"children":999},{"__ignoreMap":9},[1000],{"type":40,"value":995},{"type":28,"tag":29,"props":1002,"children":1003},{},[1004,1010],{"type":28,"tag":70,"props":1005,"children":1007},{"className":1006},[],[1008],{"type":40,"value":1009},"mut",{"type":40,"value":1011}," 可以使变量绑定为可变的",{"type":28,"tag":79,"props":1013,"children":1016},{"className":1014,"code":1015,"language":23,"meta":9},[82],"fn main() {\n    let mut n = Number {\n        odd: true,\n        value: 17,\n    }\n    n.value = 19; // all good\n}\n",[1017],{"type":28,"tag":70,"props":1018,"children":1019},{"__ignoreMap":9},[1020],{"type":40,"value":1015},{"type":28,"tag":29,"props":1022,"children":1023},{},[1024,1030],{"type":28,"tag":70,"props":1025,"children":1027},{"className":1026},[],[1028],{"type":40,"value":1029},"Traits",{"type":40,"value":1031},"(特型) 是多种类型共有的东西(类似于其他编程语言的接口)",{"type":28,"tag":79,"props":1033,"children":1036},{"className":1034,"code":1035,"language":23,"meta":9},[82],"trait Signed {\n    fn is_strictly_negative(self) -> bool;\n}\n",[1037],{"type":28,"tag":70,"props":1038,"children":1039},{"__ignoreMap":9},[1040],{"type":40,"value":1035},{"type":28,"tag":29,"props":1042,"children":1043},{},[1044],{"type":40,"value":1045},"“孤儿规则”(orphan rules):\n如果要实现某个trait，那么该trait和要实现该trait的类型至少有一个要在当前crate中定义",{"type":28,"tag":29,"props":1047,"children":1048},{},[1049,1051,1057,1059,1064],{"type":40,"value":1050},"在上面已经定义了\n",{"type":28,"tag":70,"props":1052,"children":1054},{"className":1053},[],[1055],{"type":40,"value":1056},"trait",{"type":40,"value":1058},":Signed\n",{"type":28,"tag":70,"props":1060,"children":1062},{"className":1061},[],[1063],{"type":40,"value":775},{"type":40,"value":1065},":Number",{"type":28,"tag":29,"props":1067,"children":1068},{},[1069],{"type":40,"value":1070},"在自定义的的类型中实现自定义的trait",{"type":28,"tag":79,"props":1072,"children":1075},{"className":1073,"code":1074,"language":23,"meta":9},[82],"impl Signed for Number {\n    fn is_strictly_negative(self) -> bool {\n        self.value \u003C 0\n    }\n}\n\nfn main() {\n    let n = Number { odd: false, value: -44 };\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n",[1076],{"type":28,"tag":70,"props":1077,"children":1078},{"__ignoreMap":9},[1079],{"type":40,"value":1074},{"type":28,"tag":29,"props":1081,"children":1082},{},[1083],{"type":40,"value":1084},"在其他类型中实现自定义trait(i32是一个原始类型):",{"type":28,"tag":79,"props":1086,"children":1089},{"className":1087,"code":1088,"language":23,"meta":9},[82],"impl Signed for i32 {\n    fn is_strictly_negative(self) -> bool {\n        self \u003C 0\n    }\n}\n\nfn main() {\n    let n: i32 = -44;\n    println!(\"{}\", n.is_strictly_negative()); // prints \"true\"\n}\n",[1090],{"type":28,"tag":70,"props":1091,"children":1092},{"__ignoreMap":9},[1093],{"type":40,"value":1088},{"type":28,"tag":29,"props":1095,"children":1096},{},[1097],{"type":40,"value":1098},"在自定义类型中实现其他trait",{"type":28,"tag":79,"props":1100,"children":1103},{"className":1101,"code":1102,"language":23,"meta":9},[82],"//  `Neg` trait 用于一元运算符 `-`的重载\n\nimpl std::ops::Neg for Number {\n    type Output = Number;\n\n    fn neg(self) -> Number {\n        Number {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n\nfn main() {\n    let n = Number { odd: true, value: 987 };\n    let m = -n; // this is only possible because we implemented `Neg`\n    println!(\"{}\", m.value); // prints \"-987\"\n}\n",[1104],{"type":28,"tag":70,"props":1105,"children":1106},{"__ignoreMap":9},[1107],{"type":40,"value":1102},{"type":28,"tag":29,"props":1109,"children":1110},{},[1111],{"type":40,"value":1112},"An block is always for a type, so, inside that block, means that type:implSelf\n一个代码块用于一个类型，所以在这个代码块的内部意味着这个类型的自我实现",{"type":28,"tag":79,"props":1114,"children":1117},{"className":1115,"code":1116,"language":23,"meta":9},[82],"impl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }        \n    }\n}\n",[1118],{"type":28,"tag":70,"props":1119,"children":1120},{"__ignoreMap":9},[1121],{"type":40,"value":1116},{"type":28,"tag":29,"props":1123,"children":1124},{},[1125],{"type":40,"value":1126},"Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type.\n有些trait是marker(标记)——它们不是说类型实现了某些方法，而是说某些事情可以用类型来完成。",{"type":28,"tag":29,"props":1128,"children":1129},{},[1130,1132,1138,1140,1146],{"type":40,"value":1131},"举个例子，",{"type":28,"tag":70,"props":1133,"children":1135},{"className":1134},[],[1136],{"type":40,"value":1137},"i32",{"type":40,"value":1139}," 实现了trait ",{"type":28,"tag":70,"props":1141,"children":1143},{"className":1142},[],[1144],{"type":40,"value":1145},"Copy",{"type":40,"value":1147},"(i32可以认为是Copy类型)，所以",{"type":28,"tag":79,"props":1149,"children":1152},{"className":1150,"code":1151,"language":23,"meta":9},[82],"fn main() {\n    let a: i32 = 15;\n    let b = a; // `a` 被拷贝\n    let c = a; // `a` 再次被拷贝\n}\n",[1153],{"type":28,"tag":70,"props":1154,"children":1155},{"__ignoreMap":9},[1156],{"type":40,"value":1151},{"type":28,"tag":29,"props":1158,"children":1159},{},[1160],{"type":40,"value":1161},"这同样也可以",{"type":28,"tag":79,"props":1163,"children":1166},{"className":1164,"code":1165,"language":23,"meta":9},[82],"fn print_i32(x: i32) {\n    println!(\"x = {}\", x);\n}\n\nfn main() {\n    let a: i32 = 15;\n    print_i32(a); // `a` is copied\n    print_i32(a); // `a` is copied again\n}\n",[1167],{"type":28,"tag":70,"props":1168,"children":1169},{"__ignoreMap":9},[1170],{"type":40,"value":1165},{"type":28,"tag":29,"props":1172,"children":1173},{},[1174,1176,1182,1184,1189],{"type":40,"value":1175},"但结构体",{"type":28,"tag":70,"props":1177,"children":1179},{"className":1178},[],[1180],{"type":40,"value":1181},"Number",{"type":40,"value":1183},"不是",{"type":28,"tag":70,"props":1185,"children":1187},{"className":1186},[],[1188],{"type":40,"value":1145},{"type":40,"value":1190},",所以这样不行:",{"type":28,"tag":79,"props":1192,"children":1195},{"className":1193,"code":1194,"language":23,"meta":9},[82],"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n}\n",[1196],{"type":28,"tag":70,"props":1197,"children":1198},{"__ignoreMap":9},[1199],{"type":40,"value":1194},{"type":28,"tag":29,"props":1201,"children":1202},{},[1203],{"type":40,"value":1204},"这同样不行:",{"type":28,"tag":79,"props":1206,"children":1209},{"className":1207,"code":1208,"language":23,"meta":9},[82],"fn print_number(n: Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(n); // `n` is moved\n    print_number(n); // error: use of moved value: `n`\n}\n",[1210],{"type":28,"tag":70,"props":1211,"children":1212},{"__ignoreMap":9},[1213],{"type":40,"value":1208},{"type":28,"tag":29,"props":1215,"children":1216},{},[1217,1219,1225],{"type":40,"value":1218},"但",{"type":28,"tag":70,"props":1220,"children":1222},{"className":1221},[],[1223],{"type":40,"value":1224},"print_number",{"type":40,"value":1226},"使用不可变引用(immutable reference)后则可以",{"type":28,"tag":79,"props":1228,"children":1231},{"className":1229,"code":1230,"language":23,"meta":9},[82],"fn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    let n = Number { odd: true, value: 51 };\n    print_number(&n); // `n` is borrowed for the time of the call\n    print_number(&n); // `n` is borrowed again\n}\n",[1232],{"type":28,"tag":70,"props":1233,"children":1234},{"__ignoreMap":9},[1235],{"type":40,"value":1230},{"type":28,"tag":29,"props":1237,"children":1238},{},[1239],{"type":40,"value":1240},"如果一个函数接受一个可变的引用，那么它也可以工作——但是只有当我们的变量绑定也是 mut 的时候",{"type":28,"tag":79,"props":1242,"children":1245},{"className":1243,"code":1244,"language":23,"meta":9},[82],"fn invert(n: &mut Number) {\n    n.value = -n.value;\n}\n\nfn print_number(n: &Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn main() {\n    // this time, `n` is mutable\n    let mut n = Number { odd: true, value: 51 };\n    print_number(&n);\n    invert(&mut n); // `n is borrowed mutably - everything is explicit\n    print_number(&n);\n}\n",[1246],{"type":28,"tag":70,"props":1247,"children":1248},{"__ignoreMap":9},[1249],{"type":40,"value":1244},{"type":28,"tag":29,"props":1251,"children":1252},{},[1253,1255,1261],{"type":40,"value":1254},"Trait methods can also take by reference or mutable reference:self\nTrait 方法可以通过引用或可变引用接收",{"type":28,"tag":70,"props":1256,"children":1258},{"className":1257},[],[1259],{"type":40,"value":1260},"self",{"type":40,"value":113},{"type":28,"tag":79,"props":1263,"children":1266},{"className":1264,"code":1265,"language":23,"meta":9},[82],"impl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n",[1267],{"type":28,"tag":70,"props":1268,"children":1269},{"__ignoreMap":9},[1270],{"type":40,"value":1265},{"type":28,"tag":29,"props":1272,"children":1273},{},[1274],{"type":40,"value":1275},"当调用 trait 方法时，接收方是隐式借用的:",{"type":28,"tag":79,"props":1277,"children":1280},{"className":1278,"code":1279,"language":23,"meta":9},[82],"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n    \n    print_number(&n);\n    print_number(&m);\n}\n",[1281],{"type":28,"tag":70,"props":1282,"children":1283},{"__ignoreMap":9},[1284],{"type":40,"value":1279},{"type":28,"tag":29,"props":1286,"children":1287},{},[1288],{"type":40,"value":1289},"注意:这两种写法是等价的",{"type":28,"tag":79,"props":1291,"children":1294},{"className":1292,"code":1293,"language":23,"meta":9},[82],"let m = n.clone();\nlet m = std::clone::Clone::clone(&n);\n",[1295],{"type":28,"tag":70,"props":1296,"children":1297},{"__ignoreMap":9},[1298],{"type":40,"value":1293},{"type":28,"tag":29,"props":1300,"children":1301},{},[1302],{"type":40,"value":1303},"Marker traits like have no methods:Copy\n像 Copy 这样的 Marker trait没有方法:",{"type":28,"tag":79,"props":1305,"children":1308},{"className":1306,"code":1307,"language":23,"meta":9},[82],"// note: `Copy` requires that `Clone` is implemented too\nimpl std::clone::Clone for Number {\n    fn clone(&self) -> Self {\n        Self { ..*self }\n    }\n}\n\nimpl std::marker::Copy for Number {}\n",[1309],{"type":28,"tag":70,"props":1310,"children":1311},{"__ignoreMap":9},[1312],{"type":40,"value":1307},{"type":28,"tag":29,"props":1314,"children":1315},{},[1316],{"type":40,"value":1317},"现在Clone仍然可用",{"type":28,"tag":79,"props":1319,"children":1322},{"className":1320,"code":1321,"language":23,"meta":9},[82],"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n.clone();\n    let o = n.clone();\n}\n",[1323],{"type":28,"tag":70,"props":1324,"children":1325},{"__ignoreMap":9},[1326],{"type":40,"value":1321},{"type":28,"tag":29,"props":1328,"children":1329},{},[1330],{"type":40,"value":1331},"但是 Number的值不再移动(move)",{"type":28,"tag":79,"props":1333,"children":1336},{"className":1334,"code":1335,"language":23,"meta":9},[82],"fn main() {\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `m` is a copy of `n`\n    let o = n; // same. `n` is neither moved nor borrowed.\n}\n",[1337],{"type":28,"tag":70,"props":1338,"children":1339},{"__ignoreMap":9},[1340],{"type":40,"value":1335},{"type":28,"tag":29,"props":1342,"children":1343},{},[1344,1346,1352],{"type":40,"value":1345},"有些trait非常常见，它们可以使用",{"type":28,"tag":70,"props":1347,"children":1349},{"className":1348},[],[1350],{"type":40,"value":1351},"derive",{"type":40,"value":1353},"属性自动实现:",{"type":28,"tag":79,"props":1355,"children":1358},{"className":1356,"code":1357,"language":23,"meta":9},[82],"#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n// 扩展了 `impl Clone for Number` 以及 `impl Copy for Number` 的代码块.\n",[1359],{"type":28,"tag":70,"props":1360,"children":1361},{"__ignoreMap":9},[1362],{"type":40,"value":1357},{"type":28,"tag":29,"props":1364,"children":1365},{},[1366],{"type":40,"value":1367},"函数可以是泛型的:",{"type":28,"tag":79,"props":1369,"children":1372},{"className":1370,"code":1371,"language":23,"meta":9},[82],"fn foobar\u003CT>(arg: T) {\n    // do something with `arg`\n}\n",[1373],{"type":28,"tag":70,"props":1374,"children":1375},{"__ignoreMap":9},[1376],{"type":40,"value":1371},{"type":28,"tag":29,"props":1378,"children":1379},{},[1380],{"type":40,"value":1381},"它们可以有多个类型参数，然后可以在函数的声明和函数体中使用这些参数，而不是具体的类型:",{"type":28,"tag":79,"props":1383,"children":1386},{"className":1384,"code":1385,"language":23,"meta":9},[82],"fn foobar\u003CL, R>(left: L, right: R) {\n    // do something with `left` and `right`\n}\n",[1387],{"type":28,"tag":70,"props":1388,"children":1389},{"__ignoreMap":9},[1390],{"type":40,"value":1385},{"type":28,"tag":29,"props":1392,"children":1393},{},[1394,1396,1401],{"type":40,"value":1395},"类型参数通常也有约束，因此您可以对它们进行一些实际操作。\n最简单的是通过 ",{"type":28,"tag":70,"props":1397,"children":1399},{"className":1398},[],[1400],{"type":40,"value":1056},{"type":40,"value":1402}," 来约束",{"type":28,"tag":79,"props":1404,"children":1407},{"className":1405,"code":1406,"language":23,"meta":9},[82],"fn print\u003CT: Display>(value: T) {\n    println!(\"value = {}\", value);\n}\n\nfn print\u003CT: Debug>(value: T) {\n    println!(\"value = {:?}\", value);\n}\n",[1408],{"type":28,"tag":70,"props":1409,"children":1410},{"__ignoreMap":9},[1411],{"type":40,"value":1406},{"type":28,"tag":213,"props":1413,"children":1414},{},[1415],{"type":28,"tag":29,"props":1416,"children":1417},{},[1418],{"type":40,"value":1419},"Display 和 Debug都是一种trait，用于格式化输出",{"type":28,"tag":29,"props":1421,"children":1422},{},[1423],{"type":40,"value":1424},"类型参数约束有更长的语法:",{"type":28,"tag":79,"props":1426,"children":1429},{"className":1427,"code":1428,"language":23,"meta":9},[82],"fn print\u003CT>(value: T)\nwhere\n    T: Display,\n{\n    println!(\"value = {}\", value);\n}\n",[1430],{"type":28,"tag":70,"props":1431,"children":1432},{"__ignoreMap":9},[1433],{"type":40,"value":1428},{"type":28,"tag":29,"props":1435,"children":1436},{},[1437],{"type":40,"value":1438},"约束可能更复杂: 可能需要一个类型参数来实现多个 trait:",{"type":28,"tag":79,"props":1440,"children":1443},{"className":1441,"code":1442,"language":23,"meta":9},[82],"use std::fmt::Debug;\n\nfn compare\u003CT>(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!(\"{:?} {} {:?}\", left, if left == right { \"==\" } else { \"!=\" }, right);\n}\n\nfn main() {\n    compare(\"tea\", \"coffee\");\n    // prints: \"tea\" != \"coffee\"\n}\n",[1444],{"type":28,"tag":70,"props":1445,"children":1446},{"__ignoreMap":9},[1447],{"type":40,"value":1442},{"type":28,"tag":29,"props":1449,"children":1450},{},[1451],{"type":40,"value":1452},"Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.\n泛型函数可以被看作是命名空间，包含无数具有不同具体类型的函数",{"type":28,"tag":29,"props":1454,"children":1455},{},[1456,1458,1463],{"type":40,"value":1457},"Same as with crates, and modules, and types, generic functions can be \"explored\" (navigated?) using ::\n与crate、module和type一样，泛型函数也可以使用双冒号",{"type":28,"tag":70,"props":1459,"children":1461},{"className":1460},[],[1462],{"type":40,"value":540},{"type":40,"value":1464},"进行访问",{"type":28,"tag":79,"props":1466,"children":1469},{"className":1467,"code":1468,"language":23,"meta":9},[82],"fn main() {\n    use std::any::type_name;\n    println!(\"{}\", type_name::\u003Ci32>()); // prints \"i32\"\n    println!(\"{}\", type_name::\u003C(f64, char)>()); // prints \"(f64, char)\"\n}\n",[1470],{"type":28,"tag":70,"props":1471,"children":1472},{"__ignoreMap":9},[1473],{"type":40,"value":1468},{"type":28,"tag":29,"props":1475,"children":1476},{},[1477,1479,1485],{"type":40,"value":1478},"This is lovingly called turbofish syntax, because looks like a fish.::\u003C>\n这被亲切地称为 turbofish(涡轮鱼?) 语法，因为",{"type":28,"tag":70,"props":1480,"children":1482},{"className":1481},[],[1483],{"type":40,"value":1484},"::\u003C>",{"type":40,"value":1486}," 看起来像一条鱼。",{"type":28,"tag":29,"props":1488,"children":1489},{},[1490],{"type":40,"value":1491},"结构体也可以是泛型的:",{"type":28,"tag":79,"props":1493,"children":1496},{"className":1494,"code":1495,"language":23,"meta":9},[82],"struct Pair\u003CT> {\n    a: T,\n    b: T,\n}\n\nfn print_type_name\u003CT>(_val: &T) {\n    println!(\"{}\", std::any::type_name::\u003CT>());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&p1); // prints \"Pair\u003Ci32>\"\n    print_type_name(&p2); // prints \"Pair\u003Cbool>\"\n}\n",[1497],{"type":28,"tag":70,"props":1498,"children":1499},{"__ignoreMap":9},[1500],{"type":40,"value":1495},{"type":28,"tag":29,"props":1502,"children":1503},{},[1504],{"type":40,"value":1505},"标准库类型 Vec (分配在堆上的数组)是泛型的的\nThe standard library type (~ a heap-allocated array), is generic:Vec",{"type":28,"tag":79,"props":1507,"children":1510},{"className":1508,"code":1509,"language":23,"meta":9},[82],"fn main() {\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n    print_type_name(&v1); // prints \"Vec\u003Ci32>\"\n    print_type_name(&v2); // prints \"Vec\u003Cbool>\"\n}\n",[1511],{"type":28,"tag":70,"props":1512,"children":1513},{"__ignoreMap":9},[1514],{"type":40,"value":1509},{"type":28,"tag":29,"props":1516,"children":1517},{},[1518],{"type":40,"value":1519},"Speaking of , it comes with a macro that gives more or less \"vec literals\":Vec\n说到 Vec，它或多或少都会用到宏来提供“ vec 字面值”:",{"type":28,"tag":79,"props":1521,"children":1524},{"className":1522,"code":1523,"language":23,"meta":9},[82],"fn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n    print_type_name(&v1); // prints \"Vec\u003Ci32>\"\n    print_type_name(&v2); // prints \"Vec\u003Cbool>\"\n}\n",[1525],{"type":28,"tag":70,"props":1526,"children":1527},{"__ignoreMap":9},[1528],{"type":40,"value":1523},{"type":28,"tag":29,"props":1530,"children":1531},{},[1532,1534,1540,1542,1548,1550,1556],{"type":40,"value":1533},"All of , or invoke a macro. Macros just expand to regular code.name!()name![]name!{}\n",{"type":28,"tag":70,"props":1535,"children":1537},{"className":1536},[],[1538],{"type":40,"value":1539},"name!()",{"type":40,"value":1541}," ，",{"type":28,"tag":70,"props":1543,"children":1545},{"className":1544},[],[1546],{"type":40,"value":1547},"name![]",{"type":40,"value":1549},"或",{"type":28,"tag":70,"props":1551,"children":1553},{"className":1552},[],[1554],{"type":40,"value":1555},"name!{}",{"type":40,"value":1557},"都调用了宏。宏只是扩展为常规代码",{"type":28,"tag":29,"props":1559,"children":1560},{},[1561,1563,1569],{"type":40,"value":1562},"其实",{"type":28,"tag":70,"props":1564,"children":1566},{"className":1565},[],[1567],{"type":40,"value":1568},"println",{"type":40,"value":1570}," 就是一个宏",{"type":28,"tag":79,"props":1572,"children":1575},{"className":1573,"code":1574,"language":23,"meta":9},[82],"fn main() {\n    println!(\"{}\", \"Hello there!\");\n}\n",[1576],{"type":28,"tag":70,"props":1577,"children":1578},{"__ignoreMap":9},[1579],{"type":40,"value":1574},{"type":28,"tag":29,"props":1581,"children":1582},{},[1583],{"type":40,"value":1584},"这段代码会扩展为以下等效的代码:",{"type":28,"tag":79,"props":1586,"children":1589},{"className":1587,"code":1588,"language":23,"meta":9},[82],"fn main() {\n    use std::io::{self, Write};\n    io::stdout().lock().write_all(b\"Hello there!\\n\").unwrap();\n}\n",[1590],{"type":28,"tag":70,"props":1591,"children":1592},{"__ignoreMap":9},[1593],{"type":40,"value":1588},{"type":28,"tag":29,"props":1595,"children":1596},{},[1597,1603],{"type":28,"tag":70,"props":1598,"children":1600},{"className":1599},[],[1601],{"type":40,"value":1602},"panic",{"type":40,"value":1604},"(恐慌/异常) 也是一个宏。它通过一条错误消息和错误的文件名/行号(如果启用的话)强制停止执行:",{"type":28,"tag":79,"props":1606,"children":1609},{"className":1607,"code":1608,"language":23,"meta":9},[82],"fn main() {\n    panic!(\"This panics\");\n}\n// output: thread 'main' panicked at 'This panics', src/main.rs:3:5\n",[1610],{"type":28,"tag":70,"props":1611,"children":1612},{"__ignoreMap":9},[1613],{"type":40,"value":1608},{"type":28,"tag":29,"props":1615,"children":1616},{},[1617,1619,1624,1626,1632,1634,1639],{"type":40,"value":1618},"Some methods also panic. For example, the type can contain something, or it can contain nothing. If is called on it, and it contains nothing, it panics:Option.unwrap()\n有些方法也会引起",{"type":28,"tag":70,"props":1620,"children":1622},{"className":1621},[],[1623],{"type":40,"value":1602},{"type":40,"value":1625},"。例如，Option 类型可以包含某些内容，也可以不包含。如果。在它上面调用 ",{"type":28,"tag":70,"props":1627,"children":1629},{"className":1628},[],[1630],{"type":40,"value":1631},".unpack()",{"type":40,"value":1633},"但不包含任何东西的话，就会发生",{"type":28,"tag":70,"props":1635,"children":1637},{"className":1636},[],[1638],{"type":40,"value":1602},{"type":40,"value":113},{"type":28,"tag":79,"props":1641,"children":1644},{"className":1642,"code":1643,"language":23,"meta":9},[82],"fn main() {\n    let o1: Option\u003Ci32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option\u003Ci32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21\n",[1645],{"type":28,"tag":70,"props":1646,"children":1647},{"__ignoreMap":9},[1648],{"type":40,"value":1643},{"type":28,"tag":29,"props":1650,"children":1651},{},[1652,1657],{"type":28,"tag":70,"props":1653,"children":1655},{"className":1654},[],[1656],{"type":40,"value":756},{"type":40,"value":1658}," 不是一个结构体 - 而是一个enum(枚举类)，它有两种变体(variant)",{"type":28,"tag":79,"props":1660,"children":1663},{"className":1661,"code":1662,"language":23,"meta":9},[82],"enum Option\u003CT> {\n    None,\n    Some(T),\n}\n\nimpl\u003CT> Option\u003CT> {\n    fn unwrap(self) -> T {\n        // enums variants 可以用于模式匹配:\n        match self {\n            Self::Some(t) => t,\n            Self::None => panic!(\".unwrap() called on a None option\"),\n        }\n    }\n}\n\nuse self::Option::{None, Some};\n\nfn main() {\n    let o1: Option\u003Ci32> = Some(128);\n    o1.unwrap(); // this is fine\n\n    let o2: Option\u003Ci32> = None;\n    o2.unwrap(); // this panics!\n}\n// output: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27\n",[1664],{"type":28,"tag":70,"props":1665,"children":1666},{"__ignoreMap":9},[1667],{"type":40,"value":1662},{"type":28,"tag":29,"props":1669,"children":1670},{},[1671,1676],{"type":28,"tag":70,"props":1672,"children":1674},{"className":1673},[],[1675],{"type":40,"value":764},{"type":40,"value":1677}," 也是一个 enum, 包含一个内容和一个错误",{"type":28,"tag":79,"props":1679,"children":1682},{"className":1680,"code":1681,"language":23,"meta":9},[82],"enum Result\u003CT, E> {\n    Ok(T),\n    Err(E),\n}\n",[1683],{"type":28,"tag":70,"props":1684,"children":1685},{"__ignoreMap":9},[1686],{"type":40,"value":1681},{"type":28,"tag":29,"props":1688,"children":1689},{},[1690],{"type":40,"value":1691},"It also panics when unwrapped and containing an error.\n当被解析出一个错误(error)时，它也会panic",{"type":28,"tag":29,"props":1693,"children":1694},{},[1695],{"type":40,"value":1696},"变量绑定具有生命周期 (lifetime):",{"type":28,"tag":79,"props":1698,"children":1701},{"className":1699,"code":1700,"language":23,"meta":9},[82],"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        println!(\"x = {}\", x);\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n",[1702],{"type":28,"tag":70,"props":1703,"children":1704},{"__ignoreMap":9},[1705],{"type":40,"value":1700},{"type":28,"tag":29,"props":1707,"children":1708},{},[1709],{"type":40,"value":1710},"引用同样也有生命周期",{"type":28,"tag":79,"props":1712,"children":1715},{"className":1713,"code":1714,"language":23,"meta":9},[82],"fn main() {\n    // `x` doesn't exist yet\n    {\n        let x = 42; // `x` starts existing\n        let x_ref = &x; // `x_ref` starts existing - it borrows `x`\n        println!(\"x_ref = {}\", x_ref);\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n",[1716],{"type":28,"tag":70,"props":1717,"children":1718},{"__ignoreMap":9},[1719],{"type":40,"value":1714},{"type":28,"tag":29,"props":1721,"children":1722},{},[1723],{"type":40,"value":1724},"引用的生命周期不能超过其借用的变量绑定的生命周期期:",{"type":28,"tag":79,"props":1726,"children":1729},{"className":1727,"code":1728,"language":23,"meta":9},[82],"fn main() {\n    let x_ref = {\n        let x = 42;\n        &x\n    };\n    println!(\"x_ref = {}\", x_ref);\n    // error: `x` does not live long enough\n}\n",[1730],{"type":28,"tag":70,"props":1731,"children":1732},{"__ignoreMap":9},[1733],{"type":40,"value":1728},{"type":28,"tag":29,"props":1735,"children":1736},{},[1737],{"type":40,"value":1738},"A variable binding can be immutably borrowed multiple times:\n可以多次不可变地借用变量绑定:",{"type":28,"tag":79,"props":1740,"children":1743},{"className":1741,"code":1742,"language":23,"meta":9},[82],"fn main() {\n    let x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &x;\n    let x_ref3 = &x;\n    println!(\"{} {} {}\", x_ref1, x_ref2, x_ref3);\n}\n",[1744],{"type":28,"tag":70,"props":1745,"children":1746},{"__ignoreMap":9},[1747],{"type":40,"value":1742},{"type":28,"tag":29,"props":1749,"children":1750},{},[1751],{"type":40,"value":1752},"借用时，变量绑定不能发生变化",{"type":28,"tag":79,"props":1754,"children":1757},{"className":1755,"code":1756,"language":23,"meta":9},[82],"fn main() {\n    let mut x = 42;\n    let x_ref = &x;\n    x = 13;\n    println!(\"x_ref = {}\", x_ref);\n    // error: cannot assign to `x` because it is borrowed\n}\n",[1758],{"type":28,"tag":70,"props":1759,"children":1760},{"__ignoreMap":9},[1761],{"type":40,"value":1756},{"type":28,"tag":29,"props":1763,"children":1764},{},[1765],{"type":40,"value":1766},"不可变借用时，变量不能再被可变借用",{"type":28,"tag":79,"props":1768,"children":1771},{"className":1769,"code":1770,"language":23,"meta":9},[82],"fn main() {\n    let mut x = 42;\n    let x_ref1 = &x;\n    let x_ref2 = &mut x;\n    // error: cannot borrow `x` as mutable because it is also borrowed as immutable\n    println!(\"x_ref1 = {}\", x_ref1);\n}\n",[1772],{"type":28,"tag":70,"props":1773,"children":1774},{"__ignoreMap":9},[1775],{"type":40,"value":1770},{"type":28,"tag":1777,"props":1778,"children":1779},"ul",{},[1780,1785],{"type":28,"tag":585,"props":1781,"children":1782},{},[1783],{"type":40,"value":1784},"在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。",{"type":28,"tag":585,"props":1786,"children":1787},{},[1788],{"type":40,"value":1789},"引用必须总是有效的。",{"type":28,"tag":29,"props":1791,"children":1792},{},[1793],{"type":40,"value":1794},"函数参数中的引用也有生命周期:",{"type":28,"tag":79,"props":1796,"children":1799},{"className":1797,"code":1798,"language":23,"meta":9},[82],"fn print(x: &i32) {\n    // `x` is borrowed (from the outside) for the\n    // entire time this function is called.\n}\n",[1800],{"type":28,"tag":70,"props":1801,"children":1802},{"__ignoreMap":9},[1803],{"type":40,"value":1798},{"type":28,"tag":29,"props":1805,"children":1806},{},[1807],{"type":40,"value":1808},"具有引用参数的函数可以通过具有不同生命周期的借用来调用，因此:",{"type":28,"tag":1777,"props":1810,"children":1811},{},[1812,1817],{"type":28,"tag":585,"props":1813,"children":1814},{},[1815],{"type":40,"value":1816},"所有接受引用参数的函数都是泛型的",{"type":28,"tag":585,"props":1818,"children":1819},{},[1820],{"type":40,"value":1821},"生命周期是一个泛型的参数",{"type":28,"tag":29,"props":1823,"children":1824},{},[1825,1827,1833],{"type":40,"value":1826},"生命周期的名称以单引号",{"type":28,"tag":70,"props":1828,"children":1830},{"className":1829},[],[1831],{"type":40,"value":1832},"'",{"type":40,"value":1834},"开头",{"type":28,"tag":79,"props":1836,"children":1839},{"className":1837,"code":1838,"language":23,"meta":9},[82],"// elided (non-named) lifetimes:\nfn print(x: &i32) {}\n\n// named lifetimes:\nfn print\u003C'a>(x: &'a i32) {}\n",[1840],{"type":28,"tag":70,"props":1841,"children":1842},{"__ignoreMap":9},[1843],{"type":40,"value":1838},{"type":28,"tag":29,"props":1845,"children":1846},{},[1847],{"type":40,"value":1848},"This allows returning references whose lifetime depend on the lifetime of the arguments:\n谁的生命周期依赖于参数的生命周期，就返回谁的引用",{"type":28,"tag":79,"props":1850,"children":1853},{"className":1851,"code":1852,"language":23,"meta":9},[82],"struct Number {\n    value: i32,\n}\n\nfn number_value\u003C'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn main() {\n    let n = Number { value: 47 };\n    let v = number_value(&n);\n    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.\n    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.\n}\n",[1854],{"type":28,"tag":70,"props":1855,"children":1856},{"__ignoreMap":9},[1857],{"type":40,"value":1852},{"type":28,"tag":29,"props":1859,"children":1860},{},[1861],{"type":40,"value":1862},"当输入只有一个生命周期时，不需要命名，并且所有东西都有相同的生命周期，因此下面的两个函数是等价的",{"type":28,"tag":79,"props":1864,"children":1867},{"className":1865,"code":1866,"language":23,"meta":9},[82],"fn number_value\u003C'a>(num: &'a Number) -> &'a i32 {\n    &num.value\n}\n\nfn number_value(num: &Number) -> &i32 {\n    &num.value\n}\n",[1868],{"type":28,"tag":70,"props":1869,"children":1870},{"__ignoreMap":9},[1871],{"type":40,"value":1866},{"type":28,"tag":29,"props":1873,"children":1874},{},[1875],{"type":40,"value":1876},"Structs can also be generic over lifetimes, which allows them to hold references:\n结构体可以在生命周期里都是泛型的，这使其可以接受引用",{"type":28,"tag":79,"props":1878,"children":1881},{"className":1879,"code":1880,"language":23,"meta":9},[82],"struct NumRef\u003C'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = NumRef { x: &x };\n    // `x_ref` cannot outlive `x`, etc.\n}\n",[1882],{"type":28,"tag":70,"props":1883,"children":1884},{"__ignoreMap":9},[1885],{"type":40,"value":1880},{"type":28,"tag":29,"props":1887,"children":1888},{},[1889],{"type":40,"value":1890},"同样的代码，额外添加了函数",{"type":28,"tag":79,"props":1892,"children":1895},{"className":1893,"code":1894,"language":23,"meta":9},[82],"struct NumRef\u003C'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref\u003C'a>(x: &'a i32) -> NumRef\u003C'a> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n",[1896],{"type":28,"tag":70,"props":1897,"children":1898},{"__ignoreMap":9},[1899],{"type":40,"value":1894},{"type":28,"tag":29,"props":1901,"children":1902},{},[1903],{"type":40,"value":1904},"The same code, but with \"elided\" lifetimes:\n同样的代码，省略了声明周期",{"type":28,"tag":79,"props":1906,"children":1909},{"className":1907,"code":1908,"language":23,"meta":9},[82],"struct NumRef\u003C'a> {\n    x: &'a i32,\n}\n\nfn as_num_ref(x: &i32) -> NumRef\u003C'_> {\n    NumRef { x: &x }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_ref = as_num_ref(&x);\n    // `x_ref` cannot outlive `x`, etc.\n}\n",[1910],{"type":28,"tag":70,"props":1911,"children":1912},{"__ignoreMap":9},[1913],{"type":40,"value":1908},{"type":28,"tag":29,"props":1915,"children":1916},{},[1917,1923],{"type":28,"tag":70,"props":1918,"children":1920},{"className":1919},[],[1921],{"type":40,"value":1922},"impl",{"type":40,"value":1924}," 代码块在生命周期里也是泛型的:",{"type":28,"tag":79,"props":1926,"children":1929},{"className":1927,"code":1928,"language":23,"meta":9},[82],"impl\u003C'a> NumRef\u003C'a> {\n    fn as_i32_ref(&'a self) -> &'a i32 {\n        self.x\n    }\n}\n\nfn main() {\n    let x: i32 = 99;\n    let x_num_ref = NumRef { x: &x };\n    let x_i32_ref = x_num_ref.as_i32_ref();\n    // neither ref can outlive `x`\n}\n",[1930],{"type":28,"tag":70,"props":1931,"children":1932},{"__ignoreMap":9},[1933],{"type":40,"value":1928},{"type":28,"tag":29,"props":1935,"children":1936},{},[1937],{"type":40,"value":1938},"但你也可以省略",{"type":28,"tag":79,"props":1940,"children":1943},{"className":1941,"code":1942,"language":23,"meta":9},[82],"impl\u003C'a> NumRef\u003C'a> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n",[1944],{"type":28,"tag":70,"props":1945,"children":1946},{"__ignoreMap":9},[1947],{"type":40,"value":1942},{"type":28,"tag":29,"props":1949,"children":1950},{},[1951],{"type":40,"value":1952},"如果不需要这个生命周期的名字，你可以狠狠地省略:",{"type":28,"tag":79,"props":1954,"children":1957},{"className":1955,"code":1956,"language":23,"meta":9},[82],"impl NumRef\u003C'_> {\n    fn as_i32_ref(&self) -> &i32 {\n        self.x\n    }\n}\n",[1958],{"type":28,"tag":70,"props":1959,"children":1960},{"__ignoreMap":9},[1961],{"type":40,"value":1956},{"type":28,"tag":29,"props":1963,"children":1964},{},[1965,1967,1973],{"type":40,"value":1966},"有一个特殊的生命周期:",{"type":28,"tag":70,"props":1968,"children":1970},{"className":1969},[],[1971],{"type":40,"value":1972},"static",{"type":40,"value":1974},"，它对整个程序的生命周期都有效。(类比其他语言里的静态全局变量)",{"type":28,"tag":29,"props":1976,"children":1977},{},[1978,1980,1986],{"type":40,"value":1979},"String 是",{"type":28,"tag":70,"props":1981,"children":1983},{"className":1982},[],[1984],{"type":40,"value":1985},"'static",{"type":40,"value":1987},"(静态全局)的",{"type":28,"tag":79,"props":1989,"children":1992},{"className":1990,"code":1991,"language":23,"meta":9},[82],"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let p = Person {\n        name: \"fasterthanlime\",\n    };\n}\n",[1993],{"type":28,"tag":70,"props":1994,"children":1995},{"__ignoreMap":9},[1996],{"type":40,"value":1991},{"type":28,"tag":29,"props":1998,"children":1999},{},[2000,2002,2007],{"type":40,"value":2001},"但是 string的所有者不是",{"type":28,"tag":70,"props":2003,"children":2005},{"className":2004},[],[2006],{"type":40,"value":1972},{"type":40,"value":2008},"的:",{"type":28,"tag":79,"props":2010,"children":2013},{"className":2011,"code":2012,"language":23,"meta":9},[82],"struct Person {\n    name: &'static str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // error: `name` does not live long enough\n}\n",[2014],{"type":28,"tag":70,"props":2015,"children":2016},{"__ignoreMap":9},[2017],{"type":40,"value":2012},{"type":28,"tag":29,"props":2019,"children":2020},{},[2021,2023,2029,2031,2037,2039,2044],{"type":40,"value":2022},"在最后一个示例中，变量",{"type":28,"tag":70,"props":2024,"children":2026},{"className":2025},[],[2027],{"type":40,"value":2028},"name",{"type":40,"value":2030},"不是 ",{"type":28,"tag":70,"props":2032,"children":2034},{"className":2033},[],[2035],{"type":40,"value":2036},"&'static str",{"type":40,"value":2038},"，而是 ",{"type":28,"tag":70,"props":2040,"children":2042},{"className":2041},[],[2043],{"type":40,"value":749},{"type":40,"value":2045},"。它是动态分配的，会被释放。它的生命周期小于整个程序(即使它在 main 中)。",{"type":28,"tag":29,"props":2047,"children":2048},{},[2049,2051,2057,2059,2064],{"type":40,"value":2050},"To store a non- string in , it needs to either:'staticPerson\n要想在结构体",{"type":28,"tag":70,"props":2052,"children":2054},{"className":2053},[],[2055],{"type":40,"value":2056},"Person",{"type":40,"value":2058},"中存储非",{"type":28,"tag":70,"props":2060,"children":2062},{"className":2061},[],[2063],{"type":40,"value":1985},{"type":40,"value":2065},"的string，需要满足\nA) 在生命周期里是泛型:",{"type":28,"tag":79,"props":2067,"children":2070},{"className":2068,"code":2069,"language":23,"meta":9},[82],"struct Person\u003C'a> {\n    name: &'a str,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: &name };\n    // `p` cannot outlive `name`\n}\n",[2071],{"type":28,"tag":70,"props":2072,"children":2073},{"__ignoreMap":9},[2074],{"type":40,"value":2069},{"type":28,"tag":29,"props":2076,"children":2077},{},[2078],{"type":40,"value":2079},"或者\nB) 获得string的所有权",{"type":28,"tag":79,"props":2081,"children":2084},{"className":2082,"code":2083,"language":23,"meta":9},[82],"struct Person {\n    name: String,\n}\n\nfn main() {\n    let name = format!(\"fasterthan{}\", \"lime\");\n    let p = Person { name: name };\n    // `name` was moved into `p`, their lifetimes are no longer tied.\n}\n",[2085],{"type":28,"tag":70,"props":2086,"children":2087},{"__ignoreMap":9},[2088],{"type":40,"value":2083},{"type":28,"tag":29,"props":2090,"children":2091},{},[2092],{"type":40,"value":2093},"在结构体中，当字段与变量绑定同名时",{"type":28,"tag":79,"props":2095,"children":2098},{"className":2096,"code":2097,"language":23,"meta":9},[82],"    let p = Person { name: name };\n",[2099],{"type":28,"tag":70,"props":2100,"children":2101},{"__ignoreMap":9},[2102],{"type":40,"value":2097},{"type":28,"tag":29,"props":2104,"children":2105},{},[2106],{"type":40,"value":2107},"可以简写成:",{"type":28,"tag":79,"props":2109,"children":2112},{"className":2110,"code":2111,"language":23,"meta":9},[82],"    let p = Person { name };\n",[2113],{"type":28,"tag":70,"props":2114,"children":2115},{"__ignoreMap":9},[2116],{"type":40,"value":2111},{"type":28,"tag":29,"props":2118,"children":2119},{},[2120,2122,2128,2130,2136],{"type":40,"value":2121},"Rust 中的许多类型，有",{"type":28,"tag":70,"props":2123,"children":2125},{"className":2124},[],[2126],{"type":40,"value":2127},"所有者",{"type":40,"value":2129},"(owned)的和",{"type":28,"tag":70,"props":2131,"children":2133},{"className":2132},[],[2134],{"type":40,"value":2135},"非所有者",{"type":40,"value":2137},"(nom-owned)的变体:",{"type":28,"tag":213,"props":2139,"children":2140},{},[2141],{"type":28,"tag":29,"props":2142,"children":2143},{},[2144],{"type":40,"value":2145},"引用可以在没有所有权的情况下使用被绑定的变量",{"type":28,"tag":1777,"props":2147,"children":2148},{},[2149,2154,2159],{"type":28,"tag":585,"props":2150,"children":2151},{},[2152],{"type":40,"value":2153},"Strings: String 是所有者, &str 是引用(reference)",{"type":28,"tag":585,"props":2155,"children":2156},{},[2157],{"type":40,"value":2158},"Paths: PathBuf 是所有者, &Path 是引用",{"type":28,"tag":585,"props":2160,"children":2161},{},[2162,2164,2170,2172,2178],{"type":40,"value":2163},"Collections: ",{"type":28,"tag":70,"props":2165,"children":2167},{"className":2166},[],[2168],{"type":40,"value":2169},"Vec\u003CT>",{"type":40,"value":2171}," 所有者, ",{"type":28,"tag":70,"props":2173,"children":2175},{"className":2174},[],[2176],{"type":40,"value":2177},"&[T]",{"type":40,"value":2179},"是引用",{"type":28,"tag":29,"props":2181,"children":2182},{},[2183],{"type":40,"value":2184},"Rust 有切片(slice)-切片是对多个连续元素的引用\n可以借用 vector 的切片，例如",{"type":28,"tag":79,"props":2186,"children":2189},{"className":2187,"code":2188,"language":23,"meta":9},[82],"fn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    let v2 = &v[2..4];\n    println!(\"v2 = {:?}\", v2);\n}\n\n// output:\n// v2 = [3, 4]\n",[2190],{"type":28,"tag":70,"props":2191,"children":2192},{"__ignoreMap":9},[2193],{"type":40,"value":2188},{"type":28,"tag":29,"props":2195,"children":2196},{},[2197,2199,2205,2207,2213,2215,2220,2222,2228],{"type":40,"value":2198},"这不足为奇。利用",{"type":28,"tag":70,"props":2200,"children":2202},{"className":2201},[],[2203],{"type":40,"value":2204},"Index",{"type":40,"value":2206},"和",{"type":28,"tag":70,"props":2208,"children":2210},{"className":2209},[],[2211],{"type":40,"value":2212},"IndexMut",{"type":40,"value":2214},"的",{"type":28,"tag":70,"props":2216,"children":2218},{"className":2217},[],[2219],{"type":40,"value":1056},{"type":40,"value":2221},"就可以重载索引运算(",{"type":28,"tag":70,"props":2223,"children":2225},{"className":2224},[],[2226],{"type":40,"value":2227},"foo[index]",{"type":40,"value":2229},")。",{"type":28,"tag":29,"props":2231,"children":2232},{},[2233,2235,2241],{"type":40,"value":2234},"(两个点)",{"type":28,"tag":70,"props":2236,"children":2238},{"className":2237},[],[2239],{"type":40,"value":2240},"..",{"type":40,"value":2242},"语法只是表示范围(range),range只是在标准库里定义的少数结构体",{"type":28,"tag":29,"props":2244,"children":2245},{},[2246,2248,2254],{"type":40,"value":2247},"范围是开放式的，一般是左闭右开区间，如果最右端使用等号",{"type":28,"tag":70,"props":2249,"children":2251},{"className":2250},[],[2252],{"type":40,"value":2253},"=",{"type":40,"value":2255},"，右端就是闭区间",{"type":28,"tag":79,"props":2257,"children":2260},{"className":2258,"code":2259,"language":23,"meta":9},[82],"fn main() {\n    // 0 or greater\n    println!(\"{:?}\", (0..).contains(&100)); // true\n    // strictly less than 20\n    println!(\"{:?}\", (..20).contains(&20)); // false\n    // 20 or less than 20\n    println!(\"{:?}\", (..=20).contains(&20)); // true\n    // only 3, 4, 5\n    println!(\"{:?}\", (3..6).contains(&4)); // true\n}\n",[2261],{"type":28,"tag":70,"props":2262,"children":2263},{"__ignoreMap":9},[2264],{"type":40,"value":2259},{"type":28,"tag":29,"props":2266,"children":2267},{},[2268],{"type":40,"value":2269},"借用规则也适用于切片",{"type":28,"tag":79,"props":2271,"children":2274},{"className":2272,"code":2273,"language":23,"meta":9},[82],"fn tail(s: &[u8]) -> &[u8] {\n  &s[1..] \n}\n\nfn main() {\n    let x = &[1, 2, 3, 4, 5];\n    let y = tail(x);\n    println!(\"y = {:?}\", y);\n}\n",[2275],{"type":28,"tag":70,"props":2276,"children":2277},{"__ignoreMap":9},[2278],{"type":40,"value":2273},{"type":28,"tag":29,"props":2280,"children":2281},{},[2282],{"type":40,"value":2283},"等价于",{"type":28,"tag":79,"props":2285,"children":2288},{"className":2286,"code":2287,"language":23,"meta":9},[82],"fn tail\u003C'a>(s: &'a [u8]) -> &'a [u8] {\n  &s[1..] \n}\n",[2289],{"type":28,"tag":70,"props":2290,"children":2291},{"__ignoreMap":9},[2292],{"type":40,"value":2287},{"type":28,"tag":29,"props":2294,"children":2295},{},[2296],{"type":40,"value":2297},"这是合法的",{"type":28,"tag":79,"props":2299,"children":2302},{"className":2300,"code":2301,"language":23,"meta":9},[82],"fn main() {\n    let y = {\n        let x = &[1, 2, 3, 4, 5];\n        tail(x)\n    };\n    println!(\"y = {:?}\", y);\n}\n",[2303],{"type":28,"tag":70,"props":2304,"children":2305},{"__ignoreMap":9},[2306],{"type":40,"value":2301},{"type":28,"tag":29,"props":2308,"children":2309},{},[2310,2312,2318],{"type":40,"value":2311},"但这因为",{"type":28,"tag":70,"props":2313,"children":2315},{"className":2314},[],[2316],{"type":40,"value":2317},"[1,2,3,4,5]",{"type":40,"value":2319},"是一个静态数组",{"type":28,"tag":29,"props":2321,"children":2322},{},[2323],{"type":40,"value":2324},"而这是不合法的:",{"type":28,"tag":79,"props":2326,"children":2329},{"className":2327,"code":2328,"language":23,"meta":9},[82],"fn main() {\n    let y = {\n        let v = vec![1, 2, 3, 4, 5];\n        tail(&v)\n        // error: `v` does not live long enough\n    };\n    println!(\"y = {:?}\", y);\n}\n",[2330],{"type":28,"tag":70,"props":2331,"children":2332},{"__ignoreMap":9},[2333],{"type":40,"value":2328},{"type":28,"tag":29,"props":2335,"children":2336},{},[2337,2339,2344],{"type":40,"value":2338},"因为vector是分配在堆上的，没有",{"type":28,"tag":70,"props":2340,"children":2342},{"className":2341},[],[2343],{"type":40,"value":1985},{"type":40,"value":2345},"的生命周期",{"type":28,"tag":29,"props":2347,"children":2348},{},[2349],{"type":40,"value":2350},"&str实际上是切片:",{"type":28,"tag":79,"props":2352,"children":2355},{"className":2353,"code":2354,"language":23,"meta":9},[82],"fn file_ext(name: &str) -> Option\u003C&str> {\n    // this does not create a new string - it returns\n    // a slice of the argument.\n    name.split(\".\").last()\n}\n\nfn main() {\n    let name = \"Read me. Or don't.txt\";\n    if let Some(ext) = file_ext(name) {\n        println!(\"file extension: {}\", ext);\n    } else {\n        println!(\"no file extension\");\n    }\n}\n",[2356],{"type":28,"tag":70,"props":2357,"children":2358},{"__ignoreMap":9},[2359],{"type":40,"value":2354},{"type":28,"tag":29,"props":2361,"children":2362},{},[2363],{"type":40,"value":2364},"所以借用规则也适用于此:",{"type":28,"tag":79,"props":2366,"children":2369},{"className":2367,"code":2368,"language":23,"meta":9},[82],"fn main() {\n    let ext = {\n        let name = String::from(\"Read me. Or don't.txt\");\n        file_ext(&name).unwrap_or(\"\")\n        // error: `name` does not live long enough\n    };\n    println!(\"extension: {:?}\", ext);\n}\n",[2370],{"type":28,"tag":70,"props":2371,"children":2372},{"__ignoreMap":9},[2373],{"type":40,"value":2368},{"type":28,"tag":29,"props":2375,"children":2376},{},[2377,2379],{"type":40,"value":2378},"函数可以失败并特别地返回一个",{"type":28,"tag":70,"props":2380,"children":2382},{"className":2381},[],[2383],{"type":40,"value":764},{"type":28,"tag":79,"props":2385,"children":2388},{"className":2386,"code":2387,"language":23,"meta":9},[82],"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]);\n    println!(\"{:?}\", s);\n    // prints: Ok(\"🍉\")\n\n    let s = std::str::from_utf8(&[195, 40]);\n    println!(\"{:?}\", s);\n    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })\n}\n",[2389],{"type":28,"tag":70,"props":2390,"children":2391},{"__ignoreMap":9},[2392],{"type":40,"value":2387},{"type":28,"tag":29,"props":2394,"children":2395},{},[2396,2398,2403,2405],{"type":40,"value":2397},"如果你想在失败的情况下",{"type":28,"tag":70,"props":2399,"children":2401},{"className":2400},[],[2402],{"type":40,"value":1602},{"type":40,"value":2404},",可以使用",{"type":28,"tag":70,"props":2406,"children":2408},{"className":2407},[],[2409],{"type":40,"value":2410},".unwrap()",{"type":28,"tag":79,"props":2412,"children":2415},{"className":2413,"code":2414,"language":23,"meta":9},[82],"fn main() {\n    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();\n    println!(\"{:?}\", s);\n    // prints: \"🍉\"\n\n    let s = std::str::from_utf8(&[195, 40]).unwrap();\n    // prints: thread 'main' panicked at 'called `Result::unwrap()`\n    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',\n    // src/libcore/result.rs:1165:5\n}\n",[2416],{"type":28,"tag":70,"props":2417,"children":2418},{"__ignoreMap":9},[2419],{"type":40,"value":2414},{"type":28,"tag":29,"props":2421,"children":2422},{},[2423],{"type":40,"value":2424},"或者用 .expect(), 可以自定义信息",{"type":28,"tag":79,"props":2426,"children":2429},{"className":2427,"code":2428,"language":23,"meta":9},[82],"fn main() {\n    let s = std::str::from_utf8(&[195, 40]).expect(\"valid utf-8\");\n    // prints: thread 'main' panicked at 'valid utf-8: Utf8Error\n    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5\n}\n",[2430],{"type":28,"tag":70,"props":2431,"children":2432},{"__ignoreMap":9},[2433],{"type":40,"value":2428},{"type":28,"tag":29,"props":2435,"children":2436},{},[2437,2439],{"type":40,"value":2438},"或者使用模式匹配",{"type":28,"tag":70,"props":2440,"children":2442},{"className":2441},[],[2443],{"type":40,"value":482},{"type":28,"tag":79,"props":2445,"children":2448},{"className":2446,"code":2447,"language":23,"meta":9},[82],"fn main() {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => panic!(e),\n    }\n    // prints 🍉\n}\n",[2449],{"type":28,"tag":70,"props":2450,"children":2451},{"__ignoreMap":9},[2452],{"type":40,"value":2447},{"type":28,"tag":29,"props":2454,"children":2455},{},[2456,2458],{"type":40,"value":2457},"或者使用:",{"type":28,"tag":70,"props":2459,"children":2461},{"className":2460},[],[2462],{"type":40,"value":2463},"if let",{"type":28,"tag":79,"props":2465,"children":2468},{"className":2466,"code":2467,"language":23,"meta":9},[82],"fn main() {\n    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {\n        println!(\"{}\", s);\n    }\n    // prints 🍉\n}\n",[2469],{"type":28,"tag":70,"props":2470,"children":2471},{"__ignoreMap":9},[2472],{"type":40,"value":2467},{"type":28,"tag":29,"props":2474,"children":2475},{},[2476],{"type":40,"value":2477},"或者将错误上报:",{"type":28,"tag":79,"props":2479,"children":2482},{"className":2480,"code":2481,"language":23,"meta":9},[82],"fn main() -> Result\u003C(), std::str::Utf8Error> {\n    match std::str::from_utf8(&[240, 159, 141, 137]) {\n        Ok(s) => println!(\"{}\", s),\n        Err(e) => return Err(e),\n    }\n    Ok(())\n}\n",[2483],{"type":28,"tag":70,"props":2484,"children":2485},{"__ignoreMap":9},[2486],{"type":40,"value":2481},{"type":28,"tag":29,"props":2488,"children":2489},{},[2490,2492,2498],{"type":40,"value":2491},"或者使用 ",{"type":28,"tag":70,"props":2493,"children":2495},{"className":2494},[],[2496],{"type":40,"value":2497},"?",{"type":40,"value":2499}," 简单处理",{"type":28,"tag":79,"props":2501,"children":2504},{"className":2502,"code":2503,"language":23,"meta":9},[82],"fn main() -> Result\u003C(), std::str::Utf8Error> {\n    let s = std::str::from_utf8(&[240, 159, 141, 137])?;\n    println!(\"{}\", s);\n    Ok(())\n}\n",[2505],{"type":28,"tag":70,"props":2506,"children":2507},{"__ignoreMap":9},[2508],{"type":40,"value":2503},{"type":28,"tag":29,"props":2510,"children":2511},{},[2512,2514,2519],{"type":40,"value":2513},"操作符 ",{"type":28,"tag":70,"props":2515,"children":2517},{"className":2516},[],[2518],{"type":40,"value":669},{"type":40,"value":2520}," 可以用于解引用，但是您不需要这样来访问字段或调用方法:",{"type":28,"tag":79,"props":2522,"children":2525},{"className":2523,"code":2524,"language":23,"meta":9},[82],"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    println!(\"({}, {})\", p_ref.x, p_ref.y);\n}\n\n// prints `(1, 3)`\n",[2526],{"type":28,"tag":70,"props":2527,"children":2528},{"__ignoreMap":9},[2529],{"type":40,"value":2524},{"type":28,"tag":29,"props":2531,"children":2532},{},[2533],{"type":40,"value":2534},"如果类型为Copy时只需要这样:",{"type":28,"tag":79,"props":2536,"children":2539},{"className":2537,"code":2538,"language":23,"meta":9},[82],"struct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref);\n    // error: cannot move out of `*p_ref` which is behind a shared reference\n}\n",[2540],{"type":28,"tag":70,"props":2541,"children":2542},{"__ignoreMap":9},[2543],{"type":40,"value":2538},{"type":28,"tag":79,"props":2545,"children":2548},{"className":2546,"code":2547,"language":23,"meta":9},[82],"// now `Point` is `Copy`\n#[derive(Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nfn negate(p: Point) -> Point {\n    Point {\n        x: -p.x,\n        y: -p.y,\n    }\n}\n\nfn main() {\n    let p = Point { x: 1.0, y: 3.0 };\n    let p_ref = &p;\n    negate(*p_ref); // ...and now this works\n}\n",[2549],{"type":28,"tag":70,"props":2550,"children":2551},{"__ignoreMap":9},[2552],{"type":40,"value":2547},{"type":28,"tag":29,"props":2554,"children":2555},{},[2556,2562,2564,2570,2572,2578,2580,2586,2588,2594],{"type":28,"tag":70,"props":2557,"children":2559},{"className":2558},[],[2560],{"type":40,"value":2561},"Closure",{"type":40,"value":2563},"(闭包)只是 ",{"type":28,"tag":70,"props":2565,"children":2567},{"className":2566},[],[2568],{"type":40,"value":2569},"Fn",{"type":40,"value":2571},"、 ",{"type":28,"tag":70,"props":2573,"children":2575},{"className":2574},[],[2576],{"type":40,"value":2577},"FnMut",{"type":40,"value":2579}," 或 ",{"type":28,"tag":70,"props":2581,"children":2583},{"className":2582},[],[2584],{"type":40,"value":2585},"FnOnce",{"type":40,"value":2587}," 类型的函数，具有一定的",{"type":28,"tag":70,"props":2589,"children":2591},{"className":2590},[],[2592],{"type":40,"value":2593},"context",{"type":40,"value":2595},"(语境/运行环境/上下文)",{"type":28,"tag":29,"props":2597,"children":2598},{},[2599],{"type":40,"value":2600},"Their parameters are a comma-separated list of names within a pair of pipes (). They don't need curly braces, unless you want to have multiple statements.|\nClosure的参数是一对管道(|)中以逗号分隔的名称列表。不需要花括号，除非您想要有多个语句。",{"type":28,"tag":79,"props":2602,"children":2605},{"className":2603,"code":2604,"language":23,"meta":9},[82],"fn for_each_planet\u003CF>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    for_each_planet(|planet| println!(\"Hello, {}\", planet));\n}\n\n// prints:\n// Hello, Earth\n// Hello, Mars\n// Hello, Jupiter\n",[2606],{"type":28,"tag":70,"props":2607,"children":2608},{"__ignoreMap":9},[2609],{"type":40,"value":2604},{"type":28,"tag":29,"props":2611,"children":2612},{},[2613],{"type":40,"value":2614},"借用规则也适用与此",{"type":28,"tag":79,"props":2616,"children":2619},{"className":2617,"code":2618,"language":23,"meta":9},[82],"fn for_each_planet\u003CF>(f: F)\n    where F: Fn(&'static str)\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n \nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // our closure borrows `greeting`, so it cannot outlive it\n}\n",[2620],{"type":28,"tag":70,"props":2621,"children":2622},{"__ignoreMap":9},[2623],{"type":40,"value":2618},{"type":28,"tag":29,"props":2625,"children":2626},{},[2627],{"type":40,"value":2628},"这个例子不能运行:",{"type":28,"tag":79,"props":2630,"children":2633},{"className":2631,"code":2632,"language":23,"meta":9},[82],"fn for_each_planet\u003CF>(f: F)\n    where F: Fn(&'static str) + 'static // `F` must now have \"'static\" lifetime\n{\n    f(\"Earth\");\n    f(\"Mars\");\n    f(\"Jupiter\");\n}\n\nfn main() {\n    let greeting = String::from(\"Good to see you\");\n    for_each_planet(|planet| println!(\"{}, {}\", greeting, planet));\n    // error: closure may outlive the current function, but it borrows\n    // `greeting`, which is owned by the current function\n}\n",[2634],{"type":28,"tag":70,"props":2635,"children":2636},{"__ignoreMap":9},[2637],{"type":40,"value":2632},{"type":28,"tag":29,"props":2639,"children":2640},{},[2641],{"type":40,"value":2642},"但这个可以:",{"type":28,"tag":79,"props":2644,"children":2647},{"className":2645,"code":2646,"language":23,"meta":9},[82],"fn main() {\n    let greeting = String::from(\"You're doing great\");\n    for_each_planet(move |planet| println!(\"{}, {}\", greeting, planet));\n    // `greeting` is no longer borrowed, it is *moved* into\n    // the closure.\n}\n",[2648],{"type":28,"tag":70,"props":2649,"children":2650},{"__ignoreMap":9},[2651],{"type":40,"value":2646},{"type":28,"tag":29,"props":2653,"children":2654},{},[2655,2657,2662],{"type":40,"value":2656},"An needs to be mutably borrowed to be called, so it can only be called once at a time.FnMut\n",{"type":28,"tag":70,"props":2658,"children":2660},{"className":2659},[],[2661],{"type":40,"value":2577},{"type":40,"value":2663}," 需要可变地借用才能被调用，因此一次只能调用一次",{"type":28,"tag":29,"props":2665,"children":2666},{},[2667],{"type":40,"value":2668},"这是合法的:",{"type":28,"tag":79,"props":2670,"children":2673},{"className":2671,"code":2672,"language":23,"meta":9},[82],"fn foobar\u003CF>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n",[2674],{"type":28,"tag":70,"props":2675,"children":2676},{"__ignoreMap":9},[2677],{"type":40,"value":2672},{"type":28,"tag":29,"props":2679,"children":2680},{},[2681],{"type":40,"value":2682},"而这不合法:",{"type":28,"tag":79,"props":2684,"children":2687},{"className":2685,"code":2686,"language":23,"meta":9},[82],"fn foobar\u003CF>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n    // error: cannot borrow `f` as mutable more than once at a time\n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n",[2688],{"type":28,"tag":70,"props":2689,"children":2690},{"__ignoreMap":9},[2691],{"type":40,"value":2686},{"type":28,"tag":29,"props":2693,"children":2694},{},[2695],{"type":40,"value":2696},"这也是合法的:",{"type":28,"tag":79,"props":2698,"children":2701},{"className":2699,"code":2700,"language":23,"meta":9},[82],"fn foobar\u003CF>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    foobar(|x| x * 2);\n}\n\n// output: 8\n",[2702],{"type":28,"tag":70,"props":2703,"children":2704},{"__ignoreMap":9},[2705],{"type":40,"value":2700},{"type":28,"tag":29,"props":2707,"children":2708},{},[2709,2714],{"type":28,"tag":70,"props":2710,"children":2712},{"className":2711},[],[2713],{"type":40,"value":2577},{"type":40,"value":2715}," 之所以存在，是因为一些闭包可变地借用本地变量",{"type":28,"tag":79,"props":2717,"children":2720},{"className":2718,"code":2719,"language":23,"meta":9},[82],"fn foobar\u003CF>(mut f: F)\n    where F: FnMut(i32) -> i32\n{\n    let tmp = f(2);\n    println!(\"{}\", f(tmp)); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        x * acc\n    });\n}\n\n// output: 24\n",[2721],{"type":28,"tag":70,"props":2722,"children":2723},{"__ignoreMap":9},[2724],{"type":40,"value":2719},{"type":28,"tag":29,"props":2726,"children":2727},{},[2728],{"type":40,"value":2729},"这些闭包不能被传递给期望的 Fn 函数:",{"type":28,"tag":79,"props":2731,"children":2734},{"className":2732,"code":2733,"language":23,"meta":9},[82],"fn foobar\u003CF>(f: F)\n    where F: Fn(i32) -> i32\n{\n    println!(\"{}\", f(f(2))); \n}\n \nfn main() {\n    let mut acc = 2;\n    foobar(|x| {\n        acc += 1;\n        // error: cannot assign to `acc`, as it is a\n        // captured variable in a `Fn` closure.\n        // the compiler suggests \"changing foobar\n        // to accept closures that implement `FnMut`\"\n        x * acc\n    });\n}\n",[2735],{"type":28,"tag":70,"props":2736,"children":2737},{"__ignoreMap":9},[2738],{"type":40,"value":2733},{"type":28,"tag":29,"props":2740,"children":2741},{},[2742],{"type":40,"value":2743},"FnOnce 闭包只能调用一次。它们之所以存在，是因为某些闭包移出了在捕获时被移动的变量",{"type":28,"tag":79,"props":2745,"children":2748},{"className":2746,"code":2747,"language":23,"meta":9},[82],"fn foobar\u003CF>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n}\n \nfn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    // `s` was moved into our closure, and our\n    // closures moves it to the caller by returning\n    // it. Remember that `String` is not `Copy`.\n}\n",[2749],{"type":28,"tag":70,"props":2750,"children":2751},{"__ignoreMap":9},[2752],{"type":40,"value":2747},{"type":28,"tag":29,"props":2754,"children":2755},{},[2756],{"type":40,"value":2757},"这是自然执行的，因为需要移动 FnOnce 闭包才能被调用。",{"type":28,"tag":29,"props":2759,"children":2760},{},[2761],{"type":40,"value":2762},"所以这个例子是不合法的:",{"type":28,"tag":79,"props":2764,"children":2767},{"className":2765,"code":2766,"language":23,"meta":9},[82],"fn foobar\u003CF>(f: F)\n    where F: FnOnce() -> String\n{\n    println!(\"{}\", f()); \n    println!(\"{}\", f()); \n    // error: use of moved value: `f`\n}\n",[2768],{"type":28,"tag":70,"props":2769,"children":2770},{"__ignoreMap":9},[2771],{"type":40,"value":2766},{"type":28,"tag":29,"props":2773,"children":2774},{},[2775],{"type":40,"value":2776},"而且，如果你需要说服我们的关闭确实移动 s，这也是非法的",{"type":28,"tag":79,"props":2778,"children":2781},{"className":2779,"code":2780,"language":23,"meta":9},[82],"fn main() {\n    let s = String::from(\"alright\");\n    foobar(move || s);\n    foobar(move || s);\n    // use of moved value: `s`\n}\n",[2782],{"type":28,"tag":70,"props":2783,"children":2784},{"__ignoreMap":9},[2785],{"type":40,"value":2780},{"type":28,"tag":29,"props":2787,"children":2788},{},[2789],{"type":40,"value":2790},"但这个是对的:",{"type":28,"tag":79,"props":2792,"children":2795},{"className":2793,"code":2794,"language":23,"meta":9},[82],"fn main() {\n    let s = String::from(\"alright\");\n    foobar(|| s.clone());\n    foobar(|| s.clone());\n}\n",[2796],{"type":28,"tag":70,"props":2797,"children":2798},{"__ignoreMap":9},[2799],{"type":40,"value":2794},{"type":28,"tag":29,"props":2801,"children":2802},{},[2803],{"type":40,"value":2804},"带有两个参数的闭包:",{"type":28,"tag":79,"props":2806,"children":2809},{"className":2807,"code":2808,"language":23,"meta":9},[82],"fn foobar\u003CF>(x: i32, y: i32, is_greater: F)\n    where F: Fn(i32, i32) -> bool\n{\n    let (greater, smaller) = if is_greater(x, y) {\n        (x, y)\n    } else {\n        (y, x)\n    };\n    println!(\"{} is greater than {}\", greater, smaller);\n}\n \nfn main() {\n    foobar(32, 64, |x, y| x > y);\n}\n",[2810],{"type":28,"tag":70,"props":2811,"children":2812},{"__ignoreMap":9},[2813],{"type":40,"value":2808},{"type":28,"tag":29,"props":2815,"children":2816},{},[2817],{"type":40,"value":2818},"省略所有参数的闭包:",{"type":28,"tag":79,"props":2820,"children":2823},{"className":2821,"code":2822,"language":23,"meta":9},[82],"fn main() {\n    foobar(32, 64, |_, _| panic!(\"Comparing is futile!\"));\n}\n",[2824],{"type":28,"tag":70,"props":2825,"children":2826},{"__ignoreMap":9},[2827],{"type":40,"value":2822},{"type":28,"tag":29,"props":2829,"children":2830},{},[2831],{"type":40,"value":2832},"Here's a slightly worrying closure:",{"type":28,"tag":79,"props":2834,"children":2837},{"className":2835,"code":2836,"language":23,"meta":9},[82],"fn countdown\u003CF>(count: usize, tick: F)\n    where F: Fn(usize)\n{\n    for i in (1..=count).rev() {\n        tick(i);\n    }\n}\n \nfn main() {\n    countdown(3, |i| println!(\"tick {}...\", i));\n}\n\n// output:\n// tick 3...\n// tick 2...\n// tick 1...\n",[2838],{"type":28,"tag":70,"props":2839,"children":2840},{"__ignoreMap":9},[2841],{"type":40,"value":2836},{"type":28,"tag":29,"props":2843,"children":2844},{},[2845],{"type":40,"value":2846},"And here's a toilet closure:",{"type":28,"tag":79,"props":2848,"children":2851},{"className":2849,"code":2850,"language":23,"meta":9},[82],"fn main() {\n    countdown(3, |_| ());\n}\n",[2852],{"type":28,"tag":70,"props":2853,"children":2854},{"__ignoreMap":9},[2855],{"type":40,"value":2850},{"type":28,"tag":29,"props":2857,"children":2858},{},[2859,2861,2867],{"type":40,"value":2860},"这样叫是因为",{"type":28,"tag":70,"props":2862,"children":2864},{"className":2863},[],[2865],{"type":40,"value":2866},"|_| ()",{"type":40,"value":2868},"看起来像厕所",{"type":28,"tag":29,"props":2870,"children":2871},{},[2872,2874,2880],{"type":40,"value":2873},"任何可迭代的内容都可以在 ",{"type":28,"tag":70,"props":2875,"children":2877},{"className":2876},[],[2878],{"type":40,"value":2879},"for in",{"type":40,"value":2881}," 循环中使用。",{"type":28,"tag":29,"props":2883,"children":2884},{},[2885,2887,2891],{"type":40,"value":2886},"We've just seen a range being used, but it also works with a ",{"type":28,"tag":2888,"props":2889,"children":2890},"vec",{},[],{"type":40,"value":2892},"\n我们之前看了range的使用，也可以用于Vec",{"type":28,"tag":79,"props":2894,"children":2897},{"className":2895,"code":2896,"language":23,"meta":9},[82],"fn main() {\n    for i in vec![52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n",[2898],{"type":28,"tag":70,"props":2899,"children":2900},{"__ignoreMap":9},[2901],{"type":40,"value":2896},{"type":28,"tag":29,"props":2903,"children":2904},{},[2905],{"type":40,"value":2906},"或用于切片:",{"type":28,"tag":79,"props":2908,"children":2911},{"className":2909,"code":2910,"language":23,"meta":9},[82],"fn main() {\n    for i in &[52, 49, 21] {\n        println!(\"I like the number {}\", i);\n    }\n}\n\n// output:\n// I like the number 52\n// I like the number 49\n// I like the number 21\n",[2912],{"type":28,"tag":70,"props":2913,"children":2914},{"__ignoreMap":9},[2915],{"type":40,"value":2910},{"type":28,"tag":29,"props":2917,"children":2918},{},[2919],{"type":40,"value":2920},"或一个实际的迭代器(actual iterator)",{"type":28,"tag":79,"props":2922,"children":2925},{"className":2923,"code":2924,"language":23,"meta":9},[82],"fn main() {\n    // note: `&str` also has a `.bytes()` iterator.\n    // Rust's `char` type is a \"Unicode scalar value\"\n    for c in \"rust\".chars() {\n        println!(\"Give me a {}\", c);\n    }\n}\n\n// output:\n// Give me a r\n// Give me a u\n// Give me a s\n// Give me a t\n",[2926],{"type":28,"tag":70,"props":2927,"children":2928},{"__ignoreMap":9},[2929],{"type":40,"value":2924},{"type":28,"tag":29,"props":2931,"children":2932},{},[2933],{"type":40,"value":2934},"即使迭代项被过滤、映射和扁平化",{"type":28,"tag":79,"props":2936,"children":2939},{"className":2937,"code":2938,"language":23,"meta":9},[82],"fn main() {\n    for c in \"SuRPRISE INbOUND\"\n        .chars()\n        .filter(|c| c.is_lowercase())\n        .flat_map(|c| c.to_uppercase())\n    {\n        print!(\"{}\", c);\n    }\n    println!();\n}\n\n// output: UB\n",[2940],{"type":28,"tag":70,"props":2941,"children":2942},{"__ignoreMap":9},[2943],{"type":40,"value":2938},{"type":28,"tag":29,"props":2945,"children":2946},{},[2947],{"type":40,"value":2948},"你可以从函数返回一个闭包",{"type":28,"tag":79,"props":2950,"children":2953},{"className":2951,"code":2952,"language":23,"meta":9},[82],"fn make_tester(answer: String) -> impl Fn(&str) -> bool {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    // you can use `.into()` to perform conversions\n    // between various types, here `&'static str` and `String`\n    let test = make_tester(\"hunter2\".into());\n    println!(\"{}\", test(\"******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n",[2954],{"type":28,"tag":70,"props":2955,"children":2956},{"__ignoreMap":9},[2957],{"type":40,"value":2952},{"type":28,"tag":29,"props":2959,"children":2960},{},[2961],{"type":40,"value":2962},"你甚至可以将一个对函数参数的引用移动到它返回的闭包中:",{"type":28,"tag":79,"props":2964,"children":2967},{"className":2965,"code":2966,"language":23,"meta":9},[82],"fn make_tester\u003C'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {\n    move |challenge| {\n        challenge == answer\n    }\n}\n\nfn main() {\n    let test = make_tester(\"hunter2\");\n    println!(\"{}\", test(\"*******\"));\n    println!(\"{}\", test(\"hunter2\"));\n}\n\n// output:\n// false\n// true\n",[2968],{"type":28,"tag":70,"props":2969,"children":2970},{"__ignoreMap":9},[2971],{"type":40,"value":2966},{"type":28,"tag":29,"props":2973,"children":2974},{},[2975],{"type":40,"value":2976},"或者略掉生命周期",{"type":28,"tag":79,"props":2978,"children":2981},{"className":2979,"code":2980,"language":23,"meta":9},[82],"fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {\n    move |challenge| {\n        challenge == answer\n    }\n}\n",[2982],{"type":28,"tag":70,"props":2983,"children":2984},{"__ignoreMap":9},[2985],{"type":40,"value":2980},{"title":9,"searchDepth":2987,"depth":2988,"links":2989},2,3,[],"markdown","content:essay:32.(翻译)rust半小时学习.md","content","essay/32.(翻译)rust半小时学习.md","essay/32.(翻译)rust半小时学习","md",["Reactive",2997],{},["Set"],["ShallowReactive",3000],{"content-query-OLutn989hy":3001},null,true,"/essay/32.(%E7%BF%BB%E8%AF%91)%E5%8D%8A%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%B9%A0rust"]</script>
<script>window.__NUXT__={};window.__NUXT__.config={public:{mdc:{components:{prose:true,map:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"}},headings:{anchorLinks:{h1:false,h2:true,h3:true,h4:true,h5:false,h6:false}}},content:{locales:[],defaultLocale:"",integrity:1758123881472,experimental:{stripQueryParameters:false,advanceQuery:false,clientDB:false},respectPathCase:false,api:{baseURL:"/api/_content"},navigation:{fields:[]},tags:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"},highlight:false,wsUrl:"",documentDriven:false,host:"",trailingSlash:false,search:"",contentHead:true,anchorLinks:{depth:4,exclude:[1]}}},app:{baseURL:"/",buildId:"9dcb8f7a-67a6-4558-a09e-619b477e7690",buildAssetsDir:"/_nuxt/",cdnURL:"/"}}</script></body></html>